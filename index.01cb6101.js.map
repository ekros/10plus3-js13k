{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,MC4BM,EACA,EACA,EACA,EACA,EArBN,IAHA,EAAA,EAAA,kBAIA,EAAA,EAAA,aACA,EAAA,EAAA,WACA,EAAA,EAAA,eACA,EAAA,EAAA,sBAGA,AAAA,CAAA,EAAA,EAAA,kBAAkB,AAAlB,EAAmB,CAAA,GAEnB,AAAA,CAAA,EAAA,EAAA,gBAAgB,AAAhB,EAAiB,CAAA,GAIjB,IAAM,EAAiB,IAAI,EAAA,KAAI,CAAE,EAAE,EAAE,SAAS,EACxC,EAAgB,IAAI,EAAA,KAAI,CAAE,EAAE,EAAE,WAAW,IAAI,aAAa,GAAG,EAQ7D,EAAY,AAAA,EAAA,UAAS,CAAE,OAAO,CAC9B,EAAQ,EACR,EAAW,aAAa,OAAO,CAAC,YAGhC,EAAiB,AAAC,IACtB,EAAU,QAAQ,CAAC,OAAO,CAAC,AAAA,IACrB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","sources":["<anon>","src/index.ts","node_modules/littlejsengine/dist/littlejs.esm.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","src/helpers.ts","src/constants.ts","src/types.ts","src/render-functions.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"8RSWf\":[function(require,module,exports) {\n/*\n    10 + 3 Math puzzle game\n    \n    In the middle there is a random number.\n    Using the up, down, left and right operations in the correct order\n    try to get 13 as a result.\n\n    Controls: Use arrow keys to select the operations!\n*/ var _littlejsengine = require(\"littlejsengine\");\nvar _helpers = require(\"./helpers\");\nvar _types = require(\"./types\");\nvar _constants = require(\"./constants\");\nvar _renderFunctions = require(\"./render-functions\");\n// do not use pixelated rendering\n(0, _littlejsengine.setCanvasPixelated)(false);\n// remove watermark\n(0, _littlejsengine.setShowWatermark)(false);\n// sound effects\nconst sound_goodMove = new (0, _littlejsengine.Sound)([\n    ,\n    0,\n    349.2282\n]);\nconst sound_badMove = new (0, _littlejsengine.Sound)([\n    ,\n    0,\n    146.8324,\n    ,\n    ,\n    .5,\n    ,\n    .3,\n    ,\n    ,\n    ,\n    ,\n    ,\n    ,\n    ,\n    ,\n    ,\n    ,\n    .2\n]);\n// ***********game variables************\nlet gameRound;\nlet addOperand;\nlet subOperand;\nlet divOperand;\nlet mulOperand;\nlet gameState = (0, _constants.GAME_STATE).PLAYING;\nlet level = 1;\nlet maxLevel = localStorage.getItem(\"maxLevel\");\n// *************************************\nconst createOperands = (gameRound)=>{\n    gameRound.sequence.forEach((op)=>{\n        if (op.type === (0, _types.OPERATION_TYPE).ADD) addOperand = op.value;\n        else if (op.type === (0, _types.OPERATION_TYPE).SUB) subOperand = op.value;\n        else if (op.type === (0, _types.OPERATION_TYPE).MUL) mulOperand = op.value;\n        else if (op.type === (0, _types.OPERATION_TYPE).DIV) divOperand = op.value;\n    });\n};\nconst resetOperands = ()=>{\n    addOperand = undefined;\n    subOperand = undefined;\n    divOperand = undefined;\n    mulOperand = undefined;\n};\nconst resetGame = ()=>{\n    maxLevel = localStorage.getItem(\"maxLevel\");\n    let currentDifficulty = (0, _constants.DIFFICULTY).easy;\n    if (level > 10) currentDifficulty = (0, _constants.DIFFICULTY).hard;\n    else if (level > 5) currentDifficulty = (0, _constants.DIFFICULTY).medium;\n    gameRound = (0, _helpers.startGameRound)(currentDifficulty);\n    resetOperands();\n    createOperands(gameRound);\n    gameState = (0, _constants.GAME_STATE).PLAYING;\n};\nconst nextLevel = ()=>{\n    if (level !== 12) level += 1;\n    else level = level + 2;\n    resetGame();\n};\nconst updateCurrentResult = (op)=>{\n    if (op.type === (0, _types.OPERATION_TYPE).ADD) gameRound.initialNumber += op.value;\n    else if (op.type === (0, _types.OPERATION_TYPE).SUB) gameRound.initialNumber -= op.value;\n    else if (op.type === (0, _types.OPERATION_TYPE).MUL) gameRound.initialNumber *= op.value;\n    else if (op.type === (0, _types.OPERATION_TYPE).DIV) gameRound.initialNumber /= op.value;\n};\nfunction gameInit() {\n    gameRound = (0, _helpers.startGameRound)();\n    createOperands(gameRound);\n}\nfunction gameUpdate() {\n    const sendAnswer = (answerOperation)=>{\n        const op = gameRound.sequence.pop();\n        if (op.type === answerOperation) {\n            resetOperands();\n            createOperands(gameRound);\n            updateCurrentResult(op);\n            sound_goodMove.play();\n            if (gameRound.sequence.length === 0) gameState = (0, _constants.GAME_STATE).WIN;\n        } else {\n            gameState = (0, _constants.GAME_STATE).LOSE;\n            sound_badMove.play();\n            if (level > Number(maxLevel)) localStorage.setItem(\"maxLevel\", String(level));\n        }\n    };\n    if (gameState === (0, _constants.GAME_STATE).PLAYING && (0, _littlejsengine.keyWasPressed)(\"ArrowUp\") && addOperand) sendAnswer((0, _types.OPERATION_TYPE).ADD);\n    else if (gameState === (0, _constants.GAME_STATE).PLAYING && (0, _littlejsengine.keyWasPressed)(\"ArrowRight\") && mulOperand) sendAnswer((0, _types.OPERATION_TYPE).MUL);\n    else if (gameState === (0, _constants.GAME_STATE).PLAYING && (0, _littlejsengine.keyWasPressed)(\"ArrowDown\") && subOperand) sendAnswer((0, _types.OPERATION_TYPE).SUB);\n    else if (gameState === (0, _constants.GAME_STATE).PLAYING && (0, _littlejsengine.keyWasPressed)(\"ArrowLeft\") && divOperand) sendAnswer((0, _types.OPERATION_TYPE).DIV);\n    else if (gameState === (0, _constants.GAME_STATE).WIN && (0, _littlejsengine.keyWasPressed)(\"Enter\")) nextLevel();\n    else if (gameState === (0, _constants.GAME_STATE).LOSE && (0, _littlejsengine.keyWasPressed)(\"Enter\")) {\n        level = 1;\n        resetGame();\n    }\n}\nfunction gameUpdatePost() {}\nfunction gameRender() {\n    (0, _renderFunctions.renderBackground)();\n    (0, _renderFunctions.renderLevel)(level);\n    if (maxLevel) (0, _renderFunctions.renderMaxLevel)(maxLevel);\n    if (gameState === (0, _constants.GAME_STATE).WIN) (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(-0.05, 0), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).GREEN);\n    else (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(-0.05, 0), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).BLUE);\n    (0, _littlejsengine.drawText)(gameRound.initialNumber.toString(), (0, _littlejsengine.vec2)(0, 0), 1, (0, _constants.COLOR_PALETTE).WHITE, 4, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n    if (addOperand) {\n        (0, _littlejsengine.drawText)(\"+\", (0, _littlejsengine.vec2)(0, 2), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawText)(String(addOperand), (0, _littlejsengine.vec2)(0, 4), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(0, 4), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).ORANGE);\n    }\n    if (subOperand) {\n        (0, _littlejsengine.drawText)(\"-\", (0, _littlejsengine.vec2)(0, -2), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawText)(String(subOperand), (0, _littlejsengine.vec2)(0, -4), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(0, -4), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).ORANGE);\n    }\n    if (mulOperand) {\n        (0, _littlejsengine.drawText)(\"x\", (0, _littlejsengine.vec2)(2, 0), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawText)(String(mulOperand), (0, _littlejsengine.vec2)(4, 0), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(4, 0), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).ORANGE);\n    }\n    if (divOperand) {\n        (0, _littlejsengine.drawText)(\"/\", (0, _littlejsengine.vec2)(-2, 0), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawText)(String(divOperand), (0, _littlejsengine.vec2)(-4, 0), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n        (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(-4, 0), (0, _littlejsengine.vec2)(1.7, 1.7), (0, _constants.COLOR_PALETTE).ORANGE);\n    }\n    if (level <= 3) (0, _renderFunctions.renderInstructions)();\n    switch(gameState){\n        case (0, _constants.GAME_STATE).WIN:\n            (0, _littlejsengine.drawText)(\"Correct! Press enter to continue...\", (0, _littlejsengine.vec2)(0, 6), 1, (0, _constants.COLOR_PALETTE).GREEN, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n            break;\n        case (0, _constants.GAME_STATE).LOSE:\n            (0, _littlejsengine.drawText)(\"Wrong! Press enter to continue...\", (0, _littlejsengine.vec2)(0, 6), 1, (0, _constants.COLOR_PALETTE).RED, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n            break;\n    }\n}\nfunction gameRenderPost() {}\n///////////////////////////////////////////////////////////////////////////////\n// Startup LittleJS Engine\n(0, _littlejsengine.engineInit)(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);\n\n},{\"littlejsengine\":\"gSdBJ\",\"./helpers\":\"8HL3d\",\"./types\":\"dHDQY\",\"./constants\":\"7NbOs\",\"./render-functions\":\"fQxwN\"}],\"gSdBJ\":[function(require,module,exports) {\n// LittleJS - MIT License - Copyright 2021 Frank Force\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\n/** \r\n * LittleJS Module Export\r\n * - Export engine as a module\r\n */ parcelHelpers.export(exports, \"engineName\", ()=>// Engine\n    engineName);\nparcelHelpers.export(exports, \"engineVersion\", ()=>engineVersion);\nparcelHelpers.export(exports, \"frameRate\", ()=>frameRate);\nparcelHelpers.export(exports, \"timeDelta\", ()=>timeDelta);\nparcelHelpers.export(exports, \"engineObjects\", ()=>engineObjects);\nparcelHelpers.export(exports, \"frame\", ()=>frame);\nparcelHelpers.export(exports, \"time\", ()=>time);\nparcelHelpers.export(exports, \"timeReal\", ()=>timeReal);\nparcelHelpers.export(exports, \"paused\", ()=>paused);\nparcelHelpers.export(exports, \"setPaused\", ()=>setPaused);\nparcelHelpers.export(exports, \"engineInit\", ()=>engineInit);\nparcelHelpers.export(exports, \"engineObjectsUpdate\", ()=>engineObjectsUpdate);\nparcelHelpers.export(exports, \"engineObjectsDestroy\", ()=>engineObjectsDestroy);\nparcelHelpers.export(exports, \"engineObjectsCallback\", ()=>engineObjectsCallback);\nparcelHelpers.export(exports, \"engineAddPlugin\", ()=>engineAddPlugin);\nparcelHelpers.export(exports, \"debug\", ()=>// Globals\n    debug);\nparcelHelpers.export(exports, \"debugOverlay\", ()=>debugOverlay);\nparcelHelpers.export(exports, \"showWatermark\", ()=>showWatermark);\nparcelHelpers.export(exports, \"ASSERT\", ()=>// Debug\n    ASSERT);\nparcelHelpers.export(exports, \"debugRect\", ()=>debugRect);\nparcelHelpers.export(exports, \"debugPoly\", ()=>debugPoly);\nparcelHelpers.export(exports, \"debugCircle\", ()=>debugCircle);\nparcelHelpers.export(exports, \"debugPoint\", ()=>debugPoint);\nparcelHelpers.export(exports, \"debugLine\", ()=>debugLine);\nparcelHelpers.export(exports, \"debugOverlap\", ()=>debugOverlap);\nparcelHelpers.export(exports, \"debugText\", ()=>debugText);\nparcelHelpers.export(exports, \"debugClear\", ()=>debugClear);\nparcelHelpers.export(exports, \"debugSaveCanvas\", ()=>debugSaveCanvas);\nparcelHelpers.export(exports, \"debugSaveText\", ()=>debugSaveText);\nparcelHelpers.export(exports, \"debugSaveDataURL\", ()=>debugSaveDataURL);\nparcelHelpers.export(exports, \"cameraPos\", ()=>// Settings\n    cameraPos);\nparcelHelpers.export(exports, \"cameraScale\", ()=>cameraScale);\nparcelHelpers.export(exports, \"canvasMaxSize\", ()=>canvasMaxSize);\nparcelHelpers.export(exports, \"canvasFixedSize\", ()=>canvasFixedSize);\nparcelHelpers.export(exports, \"canvasPixelated\", ()=>canvasPixelated);\nparcelHelpers.export(exports, \"fontDefault\", ()=>fontDefault);\nparcelHelpers.export(exports, \"showSplashScreen\", ()=>showSplashScreen);\nparcelHelpers.export(exports, \"headlessMode\", ()=>headlessMode);\nparcelHelpers.export(exports, \"tileSizeDefault\", ()=>tileSizeDefault);\nparcelHelpers.export(exports, \"tileFixBleedScale\", ()=>tileFixBleedScale);\nparcelHelpers.export(exports, \"enablePhysicsSolver\", ()=>enablePhysicsSolver);\nparcelHelpers.export(exports, \"objectDefaultMass\", ()=>objectDefaultMass);\nparcelHelpers.export(exports, \"objectDefaultDamping\", ()=>objectDefaultDamping);\nparcelHelpers.export(exports, \"objectDefaultAngleDamping\", ()=>objectDefaultAngleDamping);\nparcelHelpers.export(exports, \"objectDefaultElasticity\", ()=>objectDefaultElasticity);\nparcelHelpers.export(exports, \"objectDefaultFriction\", ()=>objectDefaultFriction);\nparcelHelpers.export(exports, \"objectMaxSpeed\", ()=>objectMaxSpeed);\nparcelHelpers.export(exports, \"gravity\", ()=>gravity);\nparcelHelpers.export(exports, \"particleEmitRateScale\", ()=>particleEmitRateScale);\nparcelHelpers.export(exports, \"glEnable\", ()=>glEnable);\nparcelHelpers.export(exports, \"glOverlay\", ()=>glOverlay);\nparcelHelpers.export(exports, \"gamepadsEnable\", ()=>gamepadsEnable);\nparcelHelpers.export(exports, \"gamepadDirectionEmulateStick\", ()=>gamepadDirectionEmulateStick);\nparcelHelpers.export(exports, \"inputWASDEmulateDirection\", ()=>inputWASDEmulateDirection);\nparcelHelpers.export(exports, \"touchGamepadEnable\", ()=>touchGamepadEnable);\nparcelHelpers.export(exports, \"touchGamepadAnalog\", ()=>touchGamepadAnalog);\nparcelHelpers.export(exports, \"touchGamepadSize\", ()=>touchGamepadSize);\nparcelHelpers.export(exports, \"touchGamepadAlpha\", ()=>touchGamepadAlpha);\nparcelHelpers.export(exports, \"vibrateEnable\", ()=>vibrateEnable);\nparcelHelpers.export(exports, \"soundEnable\", ()=>soundEnable);\nparcelHelpers.export(exports, \"soundVolume\", ()=>soundVolume);\nparcelHelpers.export(exports, \"soundDefaultRange\", ()=>soundDefaultRange);\nparcelHelpers.export(exports, \"soundDefaultTaper\", ()=>soundDefaultTaper);\nparcelHelpers.export(exports, \"medalDisplayTime\", ()=>medalDisplayTime);\nparcelHelpers.export(exports, \"medalDisplaySlideTime\", ()=>medalDisplaySlideTime);\nparcelHelpers.export(exports, \"medalDisplaySize\", ()=>medalDisplaySize);\nparcelHelpers.export(exports, \"medalDisplayIconSize\", ()=>medalDisplayIconSize);\nparcelHelpers.export(exports, \"setCameraPos\", ()=>// Setters for globals\n    setCameraPos);\nparcelHelpers.export(exports, \"setCameraScale\", ()=>setCameraScale);\nparcelHelpers.export(exports, \"setCanvasMaxSize\", ()=>setCanvasMaxSize);\nparcelHelpers.export(exports, \"setCanvasFixedSize\", ()=>setCanvasFixedSize);\nparcelHelpers.export(exports, \"setCanvasPixelated\", ()=>setCanvasPixelated);\nparcelHelpers.export(exports, \"setFontDefault\", ()=>setFontDefault);\nparcelHelpers.export(exports, \"setShowSplashScreen\", ()=>setShowSplashScreen);\nparcelHelpers.export(exports, \"setHeadlessMode\", ()=>setHeadlessMode);\nparcelHelpers.export(exports, \"setGlEnable\", ()=>setGlEnable);\nparcelHelpers.export(exports, \"setGlOverlay\", ()=>setGlOverlay);\nparcelHelpers.export(exports, \"setTileSizeDefault\", ()=>setTileSizeDefault);\nparcelHelpers.export(exports, \"setTileFixBleedScale\", ()=>setTileFixBleedScale);\nparcelHelpers.export(exports, \"setEnablePhysicsSolver\", ()=>setEnablePhysicsSolver);\nparcelHelpers.export(exports, \"setObjectDefaultMass\", ()=>setObjectDefaultMass);\nparcelHelpers.export(exports, \"setObjectDefaultDamping\", ()=>setObjectDefaultDamping);\nparcelHelpers.export(exports, \"setObjectDefaultAngleDamping\", ()=>setObjectDefaultAngleDamping);\nparcelHelpers.export(exports, \"setObjectDefaultElasticity\", ()=>setObjectDefaultElasticity);\nparcelHelpers.export(exports, \"setObjectDefaultFriction\", ()=>setObjectDefaultFriction);\nparcelHelpers.export(exports, \"setObjectMaxSpeed\", ()=>setObjectMaxSpeed);\nparcelHelpers.export(exports, \"setGravity\", ()=>setGravity);\nparcelHelpers.export(exports, \"setParticleEmitRateScale\", ()=>setParticleEmitRateScale);\nparcelHelpers.export(exports, \"setTouchInputEnable\", ()=>setTouchInputEnable);\nparcelHelpers.export(exports, \"setGamepadsEnable\", ()=>setGamepadsEnable);\nparcelHelpers.export(exports, \"setGamepadDirectionEmulateStick\", ()=>setGamepadDirectionEmulateStick);\nparcelHelpers.export(exports, \"setInputWASDEmulateDirection\", ()=>setInputWASDEmulateDirection);\nparcelHelpers.export(exports, \"setTouchGamepadEnable\", ()=>setTouchGamepadEnable);\nparcelHelpers.export(exports, \"setTouchGamepadAnalog\", ()=>setTouchGamepadAnalog);\nparcelHelpers.export(exports, \"setTouchGamepadSize\", ()=>setTouchGamepadSize);\nparcelHelpers.export(exports, \"setTouchGamepadAlpha\", ()=>setTouchGamepadAlpha);\nparcelHelpers.export(exports, \"setVibrateEnable\", ()=>setVibrateEnable);\nparcelHelpers.export(exports, \"setSoundEnable\", ()=>setSoundEnable);\nparcelHelpers.export(exports, \"setSoundVolume\", ()=>setSoundVolume);\nparcelHelpers.export(exports, \"setSoundDefaultRange\", ()=>setSoundDefaultRange);\nparcelHelpers.export(exports, \"setSoundDefaultTaper\", ()=>setSoundDefaultTaper);\nparcelHelpers.export(exports, \"setMedalDisplayTime\", ()=>setMedalDisplayTime);\nparcelHelpers.export(exports, \"setMedalDisplaySlideTime\", ()=>setMedalDisplaySlideTime);\nparcelHelpers.export(exports, \"setMedalDisplaySize\", ()=>setMedalDisplaySize);\nparcelHelpers.export(exports, \"setMedalDisplayIconSize\", ()=>setMedalDisplayIconSize);\nparcelHelpers.export(exports, \"setMedalsPreventUnlock\", ()=>setMedalsPreventUnlock);\nparcelHelpers.export(exports, \"setShowWatermark\", ()=>setShowWatermark);\nparcelHelpers.export(exports, \"setDebugKey\", ()=>setDebugKey);\nparcelHelpers.export(exports, \"PI\", ()=>// Utilities\n    PI);\nparcelHelpers.export(exports, \"abs\", ()=>abs);\nparcelHelpers.export(exports, \"min\", ()=>min);\nparcelHelpers.export(exports, \"max\", ()=>max);\nparcelHelpers.export(exports, \"sign\", ()=>sign);\nparcelHelpers.export(exports, \"mod\", ()=>mod);\nparcelHelpers.export(exports, \"clamp\", ()=>clamp);\nparcelHelpers.export(exports, \"percent\", ()=>percent);\nparcelHelpers.export(exports, \"distanceWrap\", ()=>distanceWrap);\nparcelHelpers.export(exports, \"lerpWrap\", ()=>lerpWrap);\nparcelHelpers.export(exports, \"distanceAngle\", ()=>distanceAngle);\nparcelHelpers.export(exports, \"lerpAngle\", ()=>lerpAngle);\nparcelHelpers.export(exports, \"lerp\", ()=>lerp);\nparcelHelpers.export(exports, \"smoothStep\", ()=>smoothStep);\nparcelHelpers.export(exports, \"nearestPowerOfTwo\", ()=>nearestPowerOfTwo);\nparcelHelpers.export(exports, \"isOverlapping\", ()=>isOverlapping);\nparcelHelpers.export(exports, \"wave\", ()=>wave);\nparcelHelpers.export(exports, \"formatTime\", ()=>formatTime);\nparcelHelpers.export(exports, \"rand\", ()=>// Random\n    rand);\nparcelHelpers.export(exports, \"randInt\", ()=>randInt);\nparcelHelpers.export(exports, \"randSign\", ()=>randSign);\nparcelHelpers.export(exports, \"randInCircle\", ()=>randInCircle);\nparcelHelpers.export(exports, \"randVector\", ()=>randVector);\nparcelHelpers.export(exports, \"randColor\", ()=>randColor);\nparcelHelpers.export(exports, \"RandomGenerator\", ()=>// Utility Classes\n    RandomGenerator);\nparcelHelpers.export(exports, \"Vector2\", ()=>Vector2);\nparcelHelpers.export(exports, \"Color\", ()=>Color);\nparcelHelpers.export(exports, \"Timer\", ()=>Timer);\nparcelHelpers.export(exports, \"vec2\", ()=>vec2);\nparcelHelpers.export(exports, \"rgb\", ()=>rgb);\nparcelHelpers.export(exports, \"hsl\", ()=>hsl);\nparcelHelpers.export(exports, \"textureInfos\", ()=>// Draw\n    textureInfos);\nparcelHelpers.export(exports, \"tile\", ()=>tile);\nparcelHelpers.export(exports, \"TileInfo\", ()=>TileInfo);\nparcelHelpers.export(exports, \"TextureInfo\", ()=>TextureInfo);\nparcelHelpers.export(exports, \"mainCanvas\", ()=>mainCanvas);\nparcelHelpers.export(exports, \"mainContext\", ()=>mainContext);\nparcelHelpers.export(exports, \"overlayCanvas\", ()=>overlayCanvas);\nparcelHelpers.export(exports, \"overlayContext\", ()=>overlayContext);\nparcelHelpers.export(exports, \"mainCanvasSize\", ()=>mainCanvasSize);\nparcelHelpers.export(exports, \"screenToWorld\", ()=>screenToWorld);\nparcelHelpers.export(exports, \"worldToScreen\", ()=>worldToScreen);\nparcelHelpers.export(exports, \"drawTile\", ()=>drawTile);\nparcelHelpers.export(exports, \"drawRect\", ()=>drawRect);\nparcelHelpers.export(exports, \"drawLine\", ()=>drawLine);\nparcelHelpers.export(exports, \"drawCanvas2D\", ()=>drawCanvas2D);\nparcelHelpers.export(exports, \"setBlendMode\", ()=>setBlendMode);\nparcelHelpers.export(exports, \"drawTextScreen\", ()=>drawTextScreen);\nparcelHelpers.export(exports, \"drawText\", ()=>drawText);\nparcelHelpers.export(exports, \"engineFontImage\", ()=>engineFontImage);\nparcelHelpers.export(exports, \"FontImage\", ()=>FontImage);\nparcelHelpers.export(exports, \"isFullscreen\", ()=>isFullscreen);\nparcelHelpers.export(exports, \"toggleFullscreen\", ()=>toggleFullscreen);\nparcelHelpers.export(exports, \"getCameraSize\", ()=>getCameraSize);\nparcelHelpers.export(exports, \"glCanvas\", ()=>// WebGL\n    glCanvas);\nparcelHelpers.export(exports, \"glContext\", ()=>glContext);\nparcelHelpers.export(exports, \"glSetTexture\", ()=>glSetTexture);\nparcelHelpers.export(exports, \"glCompileShader\", ()=>glCompileShader);\nparcelHelpers.export(exports, \"glCreateProgram\", ()=>glCreateProgram);\nparcelHelpers.export(exports, \"glCreateTexture\", ()=>glCreateTexture);\nparcelHelpers.export(exports, \"keyIsDown\", ()=>// Input\n    keyIsDown);\nparcelHelpers.export(exports, \"keyWasPressed\", ()=>keyWasPressed);\nparcelHelpers.export(exports, \"keyWasReleased\", ()=>keyWasReleased);\nparcelHelpers.export(exports, \"clearInput\", ()=>clearInput);\nparcelHelpers.export(exports, \"mouseIsDown\", ()=>mouseIsDown);\nparcelHelpers.export(exports, \"mouseWasPressed\", ()=>mouseWasPressed);\nparcelHelpers.export(exports, \"mouseWasReleased\", ()=>mouseWasReleased);\nparcelHelpers.export(exports, \"mousePos\", ()=>mousePos);\nparcelHelpers.export(exports, \"mousePosScreen\", ()=>mousePosScreen);\nparcelHelpers.export(exports, \"mouseWheel\", ()=>mouseWheel);\nparcelHelpers.export(exports, \"isUsingGamepad\", ()=>isUsingGamepad);\nparcelHelpers.export(exports, \"preventDefaultInput\", ()=>preventDefaultInput);\nparcelHelpers.export(exports, \"gamepadIsDown\", ()=>gamepadIsDown);\nparcelHelpers.export(exports, \"gamepadWasPressed\", ()=>gamepadWasPressed);\nparcelHelpers.export(exports, \"gamepadWasReleased\", ()=>gamepadWasReleased);\nparcelHelpers.export(exports, \"gamepadStick\", ()=>gamepadStick);\nparcelHelpers.export(exports, \"mouseToScreen\", ()=>mouseToScreen);\nparcelHelpers.export(exports, \"gamepadsUpdate\", ()=>gamepadsUpdate);\nparcelHelpers.export(exports, \"vibrate\", ()=>vibrate);\nparcelHelpers.export(exports, \"vibrateStop\", ()=>vibrateStop);\nparcelHelpers.export(exports, \"isTouchDevice\", ()=>isTouchDevice);\nparcelHelpers.export(exports, \"Sound\", ()=>// Audio\n    Sound);\nparcelHelpers.export(exports, \"SoundWave\", ()=>SoundWave);\nparcelHelpers.export(exports, \"Music\", ()=>Music);\nparcelHelpers.export(exports, \"playAudioFile\", ()=>playAudioFile);\nparcelHelpers.export(exports, \"speak\", ()=>speak);\nparcelHelpers.export(exports, \"speakStop\", ()=>speakStop);\nparcelHelpers.export(exports, \"getNoteFrequency\", ()=>getNoteFrequency);\nparcelHelpers.export(exports, \"audioContext\", ()=>audioContext);\nparcelHelpers.export(exports, \"playSamples\", ()=>playSamples);\nparcelHelpers.export(exports, \"zzfx\", ()=>zzfx);\nparcelHelpers.export(exports, \"EngineObject\", ()=>// Base Object\n    EngineObject);\nparcelHelpers.export(exports, \"tileCollision\", ()=>// Tiles\n    tileCollision);\nparcelHelpers.export(exports, \"tileCollisionSize\", ()=>tileCollisionSize);\nparcelHelpers.export(exports, \"initTileCollision\", ()=>initTileCollision);\nparcelHelpers.export(exports, \"setTileCollisionData\", ()=>setTileCollisionData);\nparcelHelpers.export(exports, \"getTileCollisionData\", ()=>getTileCollisionData);\nparcelHelpers.export(exports, \"tileCollisionTest\", ()=>tileCollisionTest);\nparcelHelpers.export(exports, \"tileCollisionRaycast\", ()=>tileCollisionRaycast);\nparcelHelpers.export(exports, \"TileLayerData\", ()=>TileLayerData);\nparcelHelpers.export(exports, \"TileLayer\", ()=>TileLayer);\nparcelHelpers.export(exports, \"ParticleEmitter\", ()=>// Particles\n    ParticleEmitter);\nparcelHelpers.export(exports, \"Particle\", ()=>Particle);\nparcelHelpers.export(exports, \"medals\", ()=>// Medals\n    medals);\nparcelHelpers.export(exports, \"medalsPreventUnlock\", ()=>medalsPreventUnlock);\nparcelHelpers.export(exports, \"medalsInit\", ()=>medalsInit);\nparcelHelpers.export(exports, \"Medal\", ()=>Medal);\n\"use strict\";\n/** \r\n * LittleJS Debug System\r\n * - Press Esc to show debug overlay with mouse pick\r\n * - Number keys toggle debug functions\r\n * - +/- apply time scale\r\n * - Debug primitive rendering\r\n * - Save a 2d canvas as a png image\r\n * @namespace Debug\r\n */ /** True if debug is enabled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */ const debug = true;\n/** True if asserts are enaled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */ const enableAsserts = true;\n/** Size to render debug points by default\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Debug */ const debugPointSize = .5;\n/** True if watermark with FPS should be shown, false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */ let showWatermark = true;\n/** Key code used to toggle debug mode, Esc by default\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Debug */ let debugKey = \"Escape\";\n/** True if the debug overlay is active, always false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */ let debugOverlay = false;\n// Engine internal variables not exposed to documentation\nlet debugPrimitives = [], debugPhysics = false, debugRaycast = false, debugParticles = false, debugGamepads = false, debugMedals = false, debugTakeScreenshot, downloadLink;\n///////////////////////////////////////////////////////////////////////////////\n// Debug helper functions\n/** Asserts if the expression is false, does not do anything in release builds\r\n *  @param {Boolean} assert\r\n *  @param {Object} [output]\r\n *  @memberof Debug */ function ASSERT(assert, output) {\n    if (enableAsserts) output ? console.assert(assert, output) : console.assert(assert);\n}\n/** Draw a debug rectangle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=Vector2()]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */ function debugRect(pos, size = vec2(), color = \"#fff\", time = 0, angle = 0, fill = false) {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    debugPrimitives.push({\n        pos,\n        size: vec2(size),\n        color,\n        time: new Timer(time),\n        angle,\n        fill\n    });\n}\n/** Draw a debug poly in world space\r\n *  @param {Vector2} pos\r\n *  @param {Array}   points\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */ function debugPoly(pos, points, color = \"#fff\", time = 0, angle = 0, fill = false) {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    debugPrimitives.push({\n        pos,\n        points,\n        color,\n        time: new Timer(time),\n        angle,\n        fill\n    });\n}\n/** Draw a debug circle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [radius]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */ function debugCircle(pos, radius = 0, color = \"#fff\", time = 0, fill = false) {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    debugPrimitives.push({\n        pos,\n        size: radius,\n        color,\n        time: new Timer(time),\n        angle: 0,\n        fill\n    });\n}\n/** Draw a debug point in world space\r\n *  @param {Vector2} pos\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @memberof Debug */ function debugPoint(pos, color, time, angle) {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    debugRect(pos, undefined, color, time, angle);\n}\n/** Draw a debug line in world space\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {String}  [color]\r\n *  @param {Number}  [thickness]\r\n *  @param {Number}  [time]\r\n *  @memberof Debug */ function debugLine(posA, posB, color, thickness = .1, time) {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    const halfDelta = vec2((posB.x - posA.x) / 2, (posB.y - posA.y) / 2);\n    const size = vec2(thickness, halfDelta.length() * 2);\n    debugRect(posA.add(halfDelta), size, color, time, halfDelta.angle(), true);\n}\n/** Draw a debug combined axis aligned bounding box in world space\r\n *  @param {Vector2} pA - position A\r\n *  @param {Vector2} sA - size A\r\n *  @param {Vector2} pB - position B\r\n *  @param {Vector2} sB - size B\r\n *  @param {String}  [color]\r\n *  @memberof Debug */ function debugOverlap(pA, sA, pB, sB, color) {\n    const minPos = vec2(min(pA.x - sA.x / 2, pB.x - sB.x / 2), min(pA.y - sA.y / 2, pB.y - sB.y / 2));\n    const maxPos = vec2(max(pA.x + sA.x / 2, pB.x + sB.x / 2), max(pA.y + sA.y / 2, pB.y + sB.y / 2));\n    debugRect(minPos.lerp(maxPos, .5), maxPos.subtract(minPos), color);\n}\n/** Draw a debug axis aligned bounding box in world space\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {String}  [font]\r\n *  @memberof Debug */ function debugText(text, pos, size = 1, color = \"#fff\", time = 0, angle = 0, font = \"monospace\") {\n    ASSERT(typeof color == \"string\", \"pass in css color strings\");\n    debugPrimitives.push({\n        text,\n        pos,\n        size,\n        color,\n        time: new Timer(time),\n        angle,\n        font\n    });\n}\n/** Clear all debug primitives in the list\r\n *  @memberof Debug */ function debugClear() {\n    debugPrimitives = [];\n}\n/** Save a canvas to disk \r\n *  @param {HTMLCanvasElement} canvas\r\n *  @param {String}            [filename]\r\n *  @param {String}            [type]\r\n *  @memberof Debug */ function debugSaveCanvas(canvas, filename = \"screenshot\", type = \"image/png\") {\n    debugSaveDataURL(canvas.toDataURL(type), filename);\n}\n/** Save a text file to disk \r\n *  @param {String}     text\r\n *  @param {String}     [filename]\r\n *  @param {String}     [type]\r\n *  @memberof Debug */ function debugSaveText(text, filename = \"text\", type = \"text/plain\") {\n    debugSaveDataURL(URL.createObjectURL(new Blob([\n        text\n    ], {\n        \"type\": type\n    })), filename);\n}\n/** Save a data url to disk \r\n *  @param {String}     dataURL\r\n *  @param {String}     filename\r\n *  @memberof Debug */ function debugSaveDataURL(dataURL, filename) {\n    downloadLink.download = filename;\n    downloadLink.href = dataURL;\n    downloadLink.click();\n}\n///////////////////////////////////////////////////////////////////////////////\n// Engine debug function (called automatically)\nfunction debugInit() {\n    // create link for saving screenshots\n    downloadLink = document.createElement(\"a\");\n}\nfunction debugUpdate() {\n    if (!debug) return;\n    if (keyWasPressed(debugKey)) debugOverlay = !debugOverlay;\n    if (debugOverlay) {\n        if (keyWasPressed(\"Digit0\")) showWatermark = !showWatermark;\n        if (keyWasPressed(\"Digit1\")) debugPhysics = !debugPhysics, debugParticles = false;\n        if (keyWasPressed(\"Digit2\")) debugParticles = !debugParticles, debugPhysics = false;\n        if (keyWasPressed(\"Digit3\")) debugGamepads = !debugGamepads;\n        if (keyWasPressed(\"Digit4\")) debugRaycast = !debugRaycast;\n        if (keyWasPressed(\"Digit5\")) debugTakeScreenshot = 1;\n    }\n}\nfunction debugRender() {\n    glCopyToContext(mainContext);\n    if (debugTakeScreenshot) {\n        // composite canvas\n        glCopyToContext(mainContext, true);\n        mainContext.drawImage(overlayCanvas, 0, 0);\n        overlayCanvas.width |= 0;\n        // remove alpha and save\n        const w = mainCanvas.width, h = mainCanvas.height;\n        overlayContext.fillRect(0, 0, w, h);\n        overlayContext.drawImage(mainCanvas, 0, 0);\n        debugSaveCanvas(overlayCanvas);\n        debugTakeScreenshot = 0;\n    }\n    if (debugGamepads && gamepadsEnable && navigator.getGamepads) {\n        // gamepad debug display\n        const gamepads = navigator.getGamepads();\n        for(let i = gamepads.length; i--;){\n            const gamepad = gamepads[i];\n            if (gamepad) {\n                const stickScale = 1;\n                const buttonScale = .2;\n                const centerPos = cameraPos;\n                const sticks = gamepadStickData[i];\n                for(let j = sticks.length; j--;){\n                    const drawPos = centerPos.add(vec2(j * stickScale * 2, i * stickScale * 3));\n                    const stickPos = drawPos.add(sticks[j].scale(stickScale));\n                    debugCircle(drawPos, stickScale, \"#fff7\", 0, true);\n                    debugLine(drawPos, stickPos, \"#f00\");\n                    debugPoint(stickPos, \"#f00\");\n                }\n                for(let j = gamepad.buttons.length; j--;){\n                    const drawPos = centerPos.add(vec2(j * buttonScale * 2, i * stickScale * 3 - stickScale - buttonScale));\n                    const pressed = gamepad.buttons[j].pressed;\n                    debugCircle(drawPos, buttonScale, pressed ? \"#f00\" : \"#fff7\", 0, true);\n                    debugText(\"\" + j, drawPos, .2);\n                }\n            }\n        }\n    }\n    let debugObject;\n    if (debugOverlay) {\n        const saveContext = mainContext;\n        mainContext = overlayContext;\n        // draw red rectangle around screen\n        const cameraSize = getCameraSize();\n        debugRect(cameraPos, cameraSize.subtract(vec2(.1)), \"#f008\");\n        // mouse pick\n        let bestDistance = Infinity;\n        for (const o of engineObjects){\n            if (o.canvas || o.destroyed) continue;\n            o.renderDebugInfo();\n            if (!o.size.x || !o.size.y) continue;\n            const distance = mousePos.distanceSquared(o.pos);\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                debugObject = o;\n            }\n        }\n        if (tileCollisionSize.x > 0 && tileCollisionSize.y > 0) drawRect(mousePos.floor().add(vec2(.5)), vec2(1), rgb(0, 0, 1, .5), 0, false);\n        mainContext = saveContext;\n    //glCopyToContext(mainContext = saveContext);\n    }\n    {\n        // draw debug primitives\n        overlayContext.lineWidth = 2;\n        const pointSize = debugPointSize * cameraScale;\n        debugPrimitives.forEach((p)=>{\n            overlayContext.save();\n            // create canvas transform from world space to screen space\n            const pos = worldToScreen(p.pos);\n            overlayContext.translate(pos.x | 0, pos.y | 0);\n            overlayContext.rotate(p.angle);\n            overlayContext.scale(1, -1);\n            overlayContext.fillStyle = overlayContext.strokeStyle = p.color;\n            if (p.text != undefined) {\n                overlayContext.font = p.size * cameraScale + \"px \" + p.font;\n                overlayContext.textAlign = \"center\";\n                overlayContext.textBaseline = \"middle\";\n                overlayContext.fillText(p.text, 0, 0);\n            } else if (p.points != undefined) {\n                // poly\n                overlayContext.beginPath();\n                for (const point of p.points){\n                    const p2 = point.scale(cameraScale).floor();\n                    overlayContext.lineTo(p2.x, p2.y);\n                }\n                overlayContext.closePath();\n                p.fill && overlayContext.fill();\n                overlayContext.stroke();\n            } else if (p.size == 0 || p.size.x === 0 && p.size.y === 0) {\n                // point\n                overlayContext.fillRect(-pointSize / 2, -1, pointSize, 3);\n                overlayContext.fillRect(-1, -pointSize / 2, 3, pointSize);\n            } else if (p.size.x != undefined) {\n                // rect\n                const s = p.size.scale(cameraScale).floor();\n                const w = s.x, h = s.y;\n                p.fill && overlayContext.fillRect(-w / 2 | 0, -h / 2 | 0, w, h);\n                overlayContext.strokeRect(-w / 2 | 0, -h / 2 | 0, w, h);\n            } else {\n                // circle\n                overlayContext.beginPath();\n                overlayContext.arc(0, 0, p.size * cameraScale, 0, 9);\n                p.fill && overlayContext.fill();\n                overlayContext.stroke();\n            }\n            overlayContext.restore();\n        });\n        // remove expired primitives\n        debugPrimitives = debugPrimitives.filter((r)=>r.time < 0);\n    }\n    if (debugObject) {\n        const saveContext = mainContext;\n        mainContext = overlayContext;\n        const raycastHitPos = tileCollisionRaycast(debugObject.pos, mousePos);\n        raycastHitPos && drawRect(raycastHitPos.floor().add(vec2(.5)), vec2(1), rgb(0, 1, 1, .3));\n        drawLine(mousePos, debugObject.pos, .1, raycastHitPos ? rgb(1, 0, 0, .5) : rgb(0, 1, 0, .5), false);\n        const debugText = \"mouse pos = \" + mousePos + \"\\nmouse collision = \" + getTileCollisionData(mousePos) + \"\\n\\n--- object info ---\\n\" + debugObject.toString();\n        drawTextScreen(debugText, mousePosScreen, 24, rgb(), .05, undefined, \"center\", \"monospace\");\n        mainContext = saveContext;\n    }\n    {\n        // draw debug overlay\n        overlayContext.save();\n        overlayContext.fillStyle = \"#fff\";\n        overlayContext.textAlign = \"left\";\n        overlayContext.textBaseline = \"top\";\n        overlayContext.font = \"28px monospace\";\n        overlayContext.shadowColor = \"#000\";\n        overlayContext.shadowBlur = 9;\n        let x = 9, y = -20, h = 30;\n        if (debugOverlay) {\n            overlayContext.fillText(engineName, x, y += h);\n            overlayContext.fillText(\"Objects: \" + engineObjects.length, x, y += h);\n            overlayContext.fillText(\"Time: \" + formatTime(time), x, y += h);\n            overlayContext.fillText(\"---------\", x, y += h);\n            overlayContext.fillStyle = \"#f00\";\n            overlayContext.fillText(\"ESC: Debug Overlay\", x, y += h);\n            overlayContext.fillStyle = debugPhysics ? \"#f00\" : \"#fff\";\n            overlayContext.fillText(\"1: Debug Physics\", x, y += h);\n            overlayContext.fillStyle = debugParticles ? \"#f00\" : \"#fff\";\n            overlayContext.fillText(\"2: Debug Particles\", x, y += h);\n            overlayContext.fillStyle = debugGamepads ? \"#f00\" : \"#fff\";\n            overlayContext.fillText(\"3: Debug Gamepads\", x, y += h);\n            overlayContext.fillStyle = debugRaycast ? \"#f00\" : \"#fff\";\n            overlayContext.fillText(\"4: Debug Raycasts\", x, y += h);\n            overlayContext.fillStyle = \"#fff\";\n            overlayContext.fillText(\"5: Save Screenshot\", x, y += h);\n            let keysPressed = \"\";\n            for(const i in inputData[0])if (keyIsDown(i, 0)) keysPressed += i + \" \";\n            keysPressed && overlayContext.fillText(\"Keys Down: \" + keysPressed, x, y += h);\n            let buttonsPressed = \"\";\n            if (inputData[1]) {\n                for(const i in inputData[1])if (keyIsDown(i, 1)) buttonsPressed += i + \" \";\n            }\n            buttonsPressed && overlayContext.fillText(\"Gamepad: \" + buttonsPressed, x, y += h);\n        } else {\n            overlayContext.fillText(debugPhysics ? \"Debug Physics\" : \"\", x, y += h);\n            overlayContext.fillText(debugParticles ? \"Debug Particles\" : \"\", x, y += h);\n            overlayContext.fillText(debugRaycast ? \"Debug Raycasts\" : \"\", x, y += h);\n            overlayContext.fillText(debugGamepads ? \"Debug Gamepads\" : \"\", x, y += h);\n        }\n        overlayContext.restore();\n    }\n}\n/**\r\n * LittleJS Utility Classes and Functions\r\n * - General purpose math library\r\n * - Vector2 - fast, simple, easy 2D vector class\r\n * - Color - holds a rgba color with some math functions\r\n * - Timer - tracks time automatically\r\n * - RandomGenerator - seeded random number generator\r\n * @namespace Utilities\r\n */ /** A shortcut to get Math.PI\r\n *  @type {Number}\r\n *  @default Math.PI\r\n *  @memberof Utilities */ const PI = Math.PI;\n/** Returns absoulte value of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */ function abs(value) {\n    return Math.abs(value);\n}\n/** Returns lowest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */ function min(valueA, valueB) {\n    return Math.min(valueA, valueB);\n}\n/** Returns highest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */ function max(valueA, valueB) {\n    return Math.max(valueA, valueB);\n}\n/** Returns the sign of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */ function sign(value) {\n    return Math.sign(value);\n}\n/** Returns first parm modulo the second param, but adjusted so negative numbers work as expected\r\n *  @param {Number} dividend\r\n *  @param {Number} [divisor]\r\n *  @return {Number}\r\n *  @memberof Utilities */ function mod(dividend, divisor = 1) {\n    return (dividend % divisor + divisor) % divisor;\n}\n/** Clamps the value beween max and min\r\n *  @param {Number} value\r\n *  @param {Number} [min]\r\n *  @param {Number} [max]\r\n *  @return {Number}\r\n *  @memberof Utilities */ function clamp(value, min = 0, max = 1) {\n    return value < min ? min : value > max ? max : value;\n}\n/** Returns what percentage the value is between valueA and valueB\r\n *  @param {Number} value\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */ function percent(value, valueA, valueB) {\n    return (valueB -= valueA) ? clamp((value - valueA) / valueB) : 0;\n}\n/** Linearly interpolates between values passed in using percent\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */ function lerp(percent, valueA, valueB) {\n    return valueA + clamp(percent) * (valueB - valueA);\n}\n/** Returns signed wrapped distance between the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */ function distanceWrap(valueA, valueB, wrapSize = 1) {\n    const d = (valueA - valueB) % wrapSize;\n    return d * 2 % wrapSize - d;\n}\n/** Linearly interpolates between values passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */ function lerpWrap(percent, valueA, valueB, wrapSize = 1) {\n    return valueB + clamp(percent) * distanceWrap(valueA, valueB, wrapSize);\n}\n/** Returns signed wrapped distance between the two angles passed in\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */ function distanceAngle(angleA, angleB) {\n    return distanceWrap(angleA, angleB, 2 * PI);\n}\n/** Linearly interpolates between the angles passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */ function lerpAngle(percent, angleA, angleB) {\n    return lerpWrap(percent, angleA, angleB, 2 * PI);\n}\n/** Applies smoothstep function to the percentage value\r\n *  @param {Number} percent\r\n *  @return {Number}\r\n *  @memberof Utilities */ function smoothStep(percent) {\n    return percent * percent * (3 - 2 * percent);\n}\n/** Returns the nearest power of two not less then the value\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */ function nearestPowerOfTwo(value) {\n    return 2 ** Math.ceil(Math.log2(value));\n}\n/** Returns true if two axis aligned bounding boxes are overlapping \r\n *  @param {Vector2} posA          - Center of box A\r\n *  @param {Vector2} sizeA         - Size of box A\r\n *  @param {Vector2} posB          - Center of box B\r\n *  @param {Vector2} [sizeB=(0,0)] - Size of box B, a point if undefined\r\n *  @return {Boolean}              - True if overlapping\r\n *  @memberof Utilities */ function isOverlapping(posA, sizeA, posB, sizeB = vec2()) {\n    return abs(posA.x - posB.x) * 2 < sizeA.x + sizeB.x && abs(posA.y - posB.y) * 2 < sizeA.y + sizeB.y;\n}\n/** Returns true if a line segment is intersecting an axis aligned box\r\n *  @param {Vector2} start - Start of raycast\r\n *  @param {Vector2} end   - End of raycast\r\n *  @param {Vector2} pos   - Center of box\r\n *  @param {Vector2} size  - Size of box\r\n *  @return {Boolean}      - True if intersecting\r\n *  @memberof Utilities */ function isIntersecting(start, end, pos, size) {\n    // Liang-Barsky algorithm\n    const boxMin = pos.subtract(size.scale(.5));\n    const boxMax = boxMin.add(size);\n    const delta = end.subtract(start);\n    const a = start.subtract(boxMin);\n    const b = start.subtract(boxMax);\n    const p = [\n        -delta.x,\n        delta.x,\n        -delta.y,\n        delta.y\n    ];\n    const q = [\n        a.x,\n        -b.x,\n        a.y,\n        -b.y\n    ];\n    let tMin = 0, tMax = 1;\n    for(let i = 4; i--;){\n        if (p[i]) {\n            const t = q[i] / p[i];\n            if (p[i] < 0) {\n                if (t > tMax) return false;\n                tMin = max(t, tMin);\n            } else {\n                if (t < tMin) return false;\n                tMax = min(t, tMax);\n            }\n        } else if (q[i] < 0) return false;\n    }\n    return true;\n}\n/** Returns an oscillating wave between 0 and amplitude with frequency of 1 Hz by default\r\n *  @param {Number} [frequency] - Frequency of the wave in Hz\r\n *  @param {Number} [amplitude] - Amplitude (max height) of the wave\r\n *  @param {Number} [t=time]    - Value to use for time of the wave\r\n *  @return {Number}            - Value waving between 0 and amplitude\r\n *  @memberof Utilities */ function wave(frequency = 1, amplitude = 1, t = time) {\n    return amplitude / 2 * (1 - Math.cos(t * frequency * 2 * PI));\n}\n/** Formats seconds to mm:ss style for display purposes \r\n *  @param {Number} t - time in seconds\r\n *  @return {String}\r\n *  @memberof Utilities */ function formatTime(t) {\n    return (t / 60 | 0) + \":\" + (t % 60 < 10 ? \"0\" : \"\") + (t % 60 | 0);\n}\n///////////////////////////////////////////////////////////////////////////////\n/** Random global functions\r\n *  @namespace Random */ /** Returns a random value between the two values passed in\r\n *  @param {Number} [valueA]\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */ function rand(valueA = 1, valueB = 0) {\n    return valueB + Math.random() * (valueA - valueB);\n}\n/** Returns a floored random value the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */ function randInt(valueA, valueB = 0) {\n    return Math.floor(rand(valueA, valueB));\n}\n/** Randomly returns either -1 or 1\r\n *  @return {Number}\r\n *  @memberof Random */ function randSign() {\n    return randInt(2) * 2 - 1;\n}\n/** Returns a random Vector2 with the passed in length\r\n *  @param {Number} [length]\r\n *  @return {Vector2}\r\n *  @memberof Random */ function randVector(length = 1) {\n    return new Vector2().setAngle(rand(2 * PI), length);\n}\n/** Returns a random Vector2 within a circular shape\r\n *  @param {Number} [radius]\r\n *  @param {Number} [minRadius]\r\n *  @return {Vector2}\r\n *  @memberof Random */ function randInCircle(radius = 1, minRadius = 0) {\n    return radius > 0 ? randVector(radius * rand(minRadius / radius, 1) ** .5) : new Vector2;\n}\n/** Returns a random color between the two passed in colors, combine components if linear\r\n *  @param {Color}   [colorA=(1,1,1,1)]\r\n *  @param {Color}   [colorB=(0,0,0,1)]\r\n *  @param {Boolean} [linear]\r\n *  @return {Color}\r\n *  @memberof Random */ function randColor(colorA = new Color, colorB = new Color(0, 0, 0, 1), linear = false) {\n    return linear ? colorA.lerp(colorB, rand()) : new Color(rand(colorA.r, colorB.r), rand(colorA.g, colorB.g), rand(colorA.b, colorB.b), rand(colorA.a, colorB.a));\n}\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Seeded random number generator\r\n * - Can be used to create a deterministic random number sequence\r\n * @example\r\n * let r = new RandomGenerator(123); // random number generator with seed 123\r\n * let a = r.float();                // random value between 0 and 1\r\n * let b = r.int(10);                // random integer between 0 and 9\r\n * r.seed = 123;                     // reset the seed\r\n * let c = r.float();                // the same value as a\r\n */ class RandomGenerator {\n    /** Create a random number generator with the seed passed in\r\n     *  @param {Number} seed - Starting seed */ constructor(seed){\n        /** @property {Number} - random seed */ this.seed = seed;\n    }\n    /** Returns a seeded random value between the two values passed in\r\n    *  @param {Number} [valueA]\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */ float(valueA = 1, valueB = 0) {\n        // xorshift algorithm\n        this.seed ^= this.seed << 13;\n        this.seed ^= this.seed >>> 17;\n        this.seed ^= this.seed << 5;\n        return valueB + (valueA - valueB) * abs(this.seed % 1e8) / 1e8;\n    }\n    /** Returns a floored seeded random value the two values passed in\r\n    *  @param {Number} valueA\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */ int(valueA, valueB = 0) {\n        return Math.floor(this.float(valueA, valueB));\n    }\n    /** Randomly returns either -1 or 1 deterministically\r\n    *  @return {Number} */ sign() {\n        return this.float() > .5 ? 1 : -1;\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Create a 2d vector, can take another Vector2 to copy, 2 scalars, or 1 scalar\r\n * @param {(Number|Vector2)} [x]\r\n * @param {Number} [y]\r\n * @return {Vector2}\r\n * @example\r\n * let a = vec2(0, 1); // vector with coordinates (0, 1)\r\n * let b = vec2(a);    // copy a into b\r\n * a = vec2(5);        // set a to (5, 5)\r\n * b = vec2();         // set b to (0, 0)\r\n * @memberof Utilities\r\n */ function vec2(x = 0, y) {\n    return typeof x == \"number\" ? new Vector2(x, y == undefined ? x : y) : new Vector2(x.x, x.y);\n}\n/** \r\n * Check if object is a valid Vector2\r\n * @param {any} v\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */ function isVector2(v) {\n    return v instanceof Vector2;\n}\n/** \r\n * 2D Vector object with vector math library\r\n * - Functions do not change this so they can be chained together\r\n * @example\r\n * let a = new Vector2(2, 3); // vector with coordinates (2, 3)\r\n * let b = new Vector2;       // vector with coordinates (0, 0)\r\n * let c = vec2(4, 2);        // use the vec2 function to make a Vector2\r\n * let d = a.add(b).scale(5); // operators can be chained\r\n */ class Vector2 {\n    /** Create a 2D vector with the x and y passed in, can also be created with vec2()\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location */ constructor(x = 0, y = 0){\n        ASSERT(typeof x == \"number\" && typeof y == \"number\");\n        /** @property {Number} - X axis location */ this.x = x;\n        /** @property {Number} - Y axis location */ this.y = y;\n    }\n    /** Sets values of this vector and returns self\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location\r\n     *  @return {Vector2} */ set(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /** Returns a new vector that is a copy of this\r\n     *  @return {Vector2} */ copy() {\n        return new Vector2(this.x, this.y);\n    }\n    /** Returns a copy of this vector plus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */ add(v) {\n        ASSERT(isVector2(v));\n        return new Vector2(this.x + v.x, this.y + v.y);\n    }\n    /** Returns a copy of this vector minus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */ subtract(v) {\n        ASSERT(isVector2(v));\n        return new Vector2(this.x - v.x, this.y - v.y);\n    }\n    /** Returns a copy of this vector times the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */ multiply(v) {\n        ASSERT(isVector2(v));\n        return new Vector2(this.x * v.x, this.y * v.y);\n    }\n    /** Returns a copy of this vector divided by the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */ divide(v) {\n        ASSERT(isVector2(v));\n        return new Vector2(this.x / v.x, this.y / v.y);\n    }\n    /** Returns a copy of this vector scaled by the vector passed in\r\n     *  @param {Number} s - scale\r\n     *  @return {Vector2} */ scale(s) {\n        ASSERT(!isVector2(s));\n        return new Vector2(this.x * s, this.y * s);\n    }\n    /** Returns the length of this vector\r\n     * @return {Number} */ length() {\n        return this.lengthSquared() ** .5;\n    }\n    /** Returns the length of this vector squared\r\n     * @return {Number} */ lengthSquared() {\n        return this.x ** 2 + this.y ** 2;\n    }\n    /** Returns the distance from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */ distance(v) {\n        ASSERT(isVector2(v));\n        return this.distanceSquared(v) ** .5;\n    }\n    /** Returns the distance squared from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */ distanceSquared(v) {\n        ASSERT(isVector2(v));\n        return (this.x - v.x) ** 2 + (this.y - v.y) ** 2;\n    }\n    /** Returns a new vector in same direction as this one with the length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */ normalize(length = 1) {\n        const l = this.length();\n        return l ? this.scale(length / l) : new Vector2(0, length);\n    }\n    /** Returns a new vector clamped to length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */ clampLength(length = 1) {\n        const l = this.length();\n        return l > length ? this.scale(length / l) : this;\n    }\n    /** Returns the dot product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */ dot(v) {\n        ASSERT(isVector2(v));\n        return this.x * v.x + this.y * v.y;\n    }\n    /** Returns the cross product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */ cross(v) {\n        ASSERT(isVector2(v));\n        return this.x * v.y - this.y * v.x;\n    }\n    /** Returns the angle of this vector, up is angle 0\r\n     * @return {Number} */ angle() {\n        return Math.atan2(this.x, this.y);\n    }\n    /** Sets this vector with angle and length passed in\r\n     * @param {Number} [angle]\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */ setAngle(angle = 0, length = 1) {\n        this.x = length * Math.sin(angle);\n        this.y = length * Math.cos(angle);\n        return this;\n    }\n    /** Returns copy of this vector rotated by the angle passed in\r\n     * @param {Number} angle\r\n     * @return {Vector2} */ rotate(angle) {\n        const c = Math.cos(angle), s = Math.sin(angle);\n        return new Vector2(this.x * c - this.y * s, this.x * s + this.y * c);\n    }\n    /** Set the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @param {Number} [direction]\r\n     * @param {Number} [length] */ setDirection(direction, length = 1) {\n        ASSERT(direction == 0 || direction == 1 || direction == 2 || direction == 3);\n        return vec2(direction % 2 ? direction - 1 ? -length : length : 0, direction % 2 ? 0 : direction ? -length : length);\n    }\n    /** Returns the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @return {Number} */ direction() {\n        return abs(this.x) > abs(this.y) ? this.x < 0 ? 3 : 1 : this.y < 0 ? 2 : 0;\n    }\n    /** Returns a copy of this vector that has been inverted\r\n     * @return {Vector2} */ invert() {\n        return new Vector2(this.y, -this.x);\n    }\n    /** Returns a copy of this vector with each axis floored\r\n     * @return {Vector2} */ floor() {\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\n    }\n    /** Returns the area this vector covers as a rectangle\r\n     * @return {Number} */ area() {\n        return abs(this.x * this.y);\n    }\n    /** Returns a new vector that is p percent between this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @param {Number}  percent\r\n     * @return {Vector2} */ lerp(v, percent) {\n        ASSERT(isVector2(v));\n        return this.add(v.subtract(this).scale(clamp(percent)));\n    }\n    /** Returns true if this vector is within the bounds of an array size passed in\r\n     * @param {Vector2} arraySize\r\n     * @return {Boolean} */ arrayCheck(arraySize) {\n        ASSERT(isVector2(arraySize));\n        return this.x >= 0 && this.y >= 0 && this.x < arraySize.x && this.y < arraySize.y;\n    }\n    /** Returns this vector expressed as a string\r\n     * @param {Number} digits - precision to display\r\n     * @return {String} */ toString(digits = 3) {\n        if (debug) return `(${(this.x < 0 ? \"\" : \" \") + this.x.toFixed(digits)},${(this.y < 0 ? \"\" : \" \") + this.y.toFixed(digits)} )`;\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Create a color object with RGBA values, white by default\r\n * @param {Number} [r=1] - red\r\n * @param {Number} [g=1] - green\r\n * @param {Number} [b=1] - blue\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */ function rgb(r, g, b, a) {\n    return new Color(r, g, b, a);\n}\n/** \r\n * Create a color object with HSLA values, white by default\r\n * @param {Number} [h=0] - hue\r\n * @param {Number} [s=0] - saturation\r\n * @param {Number} [l=1] - lightness\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */ function hsl(h, s, l, a) {\n    return new Color().setHSLA(h, s, l, a);\n}\n/** \r\n * Check if object is a valid Color\r\n * @param {any} c\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */ function isColor(c) {\n    return c instanceof Color;\n}\n/** \r\n * Color object (red, green, blue, alpha) with some helpful functions\r\n * @example\r\n * let a = new Color;              // white\r\n * let b = new Color(1, 0, 0);     // red\r\n * let c = new Color(0, 0, 0, 0);  // transparent black\r\n * let d = rgb(0, 0, 1);           // blue using rgb color\r\n * let e = hsl(.3, 1, .5);         // green using hsl color\r\n */ class Color {\n    /** Create a color with the rgba components passed in, white by default\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha*/ constructor(r = 1, g = 1, b = 1, a = 1){\n        /** @property {Number} - Red */ this.r = r;\n        /** @property {Number} - Green */ this.g = g;\n        /** @property {Number} - Blue */ this.b = b;\n        /** @property {Number} - Alpha */ this.a = a;\n    }\n    /** Sets values of this color and returns self\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha\r\n     *  @return {Color} */ set(r = 1, g = 1, b = 1, a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        return this;\n    }\n    /** Returns a new color that is a copy of this\r\n     * @return {Color} */ copy() {\n        return new Color(this.r, this.g, this.b, this.a);\n    }\n    /** Returns a copy of this color plus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */ add(c) {\n        ASSERT(isColor(c));\n        return new Color(this.r + c.r, this.g + c.g, this.b + c.b, this.a + c.a);\n    }\n    /** Returns a copy of this color minus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */ subtract(c) {\n        ASSERT(isColor(c));\n        return new Color(this.r - c.r, this.g - c.g, this.b - c.b, this.a - c.a);\n    }\n    /** Returns a copy of this color times the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */ multiply(c) {\n        ASSERT(isColor(c));\n        return new Color(this.r * c.r, this.g * c.g, this.b * c.b, this.a * c.a);\n    }\n    /** Returns a copy of this color divided by the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */ divide(c) {\n        ASSERT(isColor(c));\n        return new Color(this.r / c.r, this.g / c.g, this.b / c.b, this.a / c.a);\n    }\n    /** Returns a copy of this color scaled by the value passed in, alpha can be scaled separately\r\n     * @param {Number} scale\r\n     * @param {Number} [alphaScale=scale]\r\n     * @return {Color} */ scale(scale, alphaScale = scale) {\n        return new Color(this.r * scale, this.g * scale, this.b * scale, this.a * alphaScale);\n    }\n    /** Returns a copy of this color clamped to the valid range between 0 and 1\r\n     * @return {Color} */ clamp() {\n        return new Color(clamp(this.r), clamp(this.g), clamp(this.b), clamp(this.a));\n    }\n    /** Returns a new color that is p percent between this and the color passed in\r\n     * @param {Color}  c - other color\r\n     * @param {Number} percent\r\n     * @return {Color} */ lerp(c, percent) {\n        ASSERT(isColor(c));\n        return this.add(c.subtract(this).scale(clamp(percent)));\n    }\n    /** Sets this color given a hue, saturation, lightness, and alpha\r\n     * @param {Number} [h] - hue\r\n     * @param {Number} [s] - saturation\r\n     * @param {Number} [l] - lightness\r\n     * @param {Number} [a] - alpha\r\n     * @return {Color} */ setHSLA(h = 0, s = 0, l = 1, a = 1) {\n        h = mod(h, 1);\n        s = clamp(s);\n        l = clamp(l);\n        const q = l < .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q, f = (p, q, t)=>(t = mod(t, 1)) * 6 < 1 ? p + (q - p) * 6 * t : t * 2 < 1 ? q : t * 3 < 2 ? p + (q - p) * (4 - t * 6) : p;\n        this.r = f(p, q, h + 1 / 3);\n        this.g = f(p, q, h);\n        this.b = f(p, q, h - 1 / 3);\n        this.a = a;\n        return this;\n    }\n    /** Returns this color expressed in hsla format\r\n     * @return {Array} */ HSLA() {\n        const r = clamp(this.r);\n        const g = clamp(this.g);\n        const b = clamp(this.b);\n        const a = clamp(this.a);\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        const l = (max + min) / 2;\n        let h = 0, s = 0;\n        if (max != min) {\n            let d = max - min;\n            s = l > .5 ? d / (2 - max - min) : d / (max + min);\n            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);\n            else if (g == max) h = (b - r) / d + 2;\n            else if (b == max) h = (r - g) / d + 4;\n        }\n        return [\n            h / 6,\n            s,\n            l,\n            a\n        ];\n    }\n    /** Returns a new color that has each component randomly adjusted\r\n     * @param {Number} [amount]\r\n     * @param {Number} [alphaAmount]\r\n     * @return {Color} */ mutate(amount = .05, alphaAmount = 0) {\n        return new Color(this.r + rand(amount, -amount), this.g + rand(amount, -amount), this.b + rand(amount, -amount), this.a + rand(alphaAmount, -alphaAmount)).clamp();\n    }\n    /** Returns this color expressed as a hex color code\r\n     * @param {Boolean} [useAlpha] - if alpha should be included in result\r\n     * @return {String} */ toString(useAlpha = true) {\n        const toHex = (c)=>((c = c * 255 | 0) < 16 ? \"0\" : \"\") + c.toString(16);\n        return \"#\" + toHex(this.r) + toHex(this.g) + toHex(this.b) + (useAlpha ? toHex(this.a) : \"\");\n    }\n    /** Set this color from a hex code\r\n     * @param {String} hex - html hex code\r\n     * @return {Color} */ setHex(hex) {\n        const fromHex = (c)=>clamp(parseInt(hex.slice(c, c + 2), 16) / 255);\n        this.r = fromHex(1);\n        this.g = fromHex(3), this.b = fromHex(5);\n        this.a = hex.length > 7 ? fromHex(7) : 1;\n        return this;\n    }\n    /** Returns this color expressed as 32 bit RGBA value\r\n     * @return {Number} */ rgbaInt() {\n        const r = clamp(this.r) * 255 | 0;\n        const g = clamp(this.g) * 255 << 8;\n        const b = clamp(this.b) * 255 << 16;\n        const a = clamp(this.a) * 255 << 24;\n        return r + g + b + a;\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n// default colors\n/** Color - White\r\n *  @type {Color}\r\n *  @memberof Utilities */ const WHITE = rgb();\n/** Color - Black\r\n *  @type {Color}\r\n *  @memberof Utilities */ const BLACK = rgb(0, 0, 0);\n/** Color - Gray\r\n *  @type {Color}\r\n *  @memberof Utilities */ const GRAY = rgb(.5, .5, .5);\n/** Color - Red\r\n *  @type {Color}\r\n *  @memberof Utilities */ const RED = rgb(1, 0, 0);\n/** Color - Orange\r\n *  @type {Color}\r\n *  @memberof Utilities */ const ORANGE = rgb(1, .5, 0);\n/** Color - Yellow\r\n *  @type {Color}\r\n *  @memberof Utilities */ const YELLOW = rgb(1, 1, 0);\n/** Color - Green\r\n *  @type {Color}\r\n *  @memberof Utilities */ const GREEN = rgb(0, 1, 0);\n/** Color - Cyan\r\n *  @type {Color}\r\n *  @memberof Utilities */ const CYAN = rgb(0, 1, 1);\n/** Color - Blue\r\n *  @type {Color}\r\n *  @memberof Utilities */ const BLUE = rgb(0, 0, 1);\n/** Color - Purple\r\n *  @type {Color}\r\n *  @memberof Utilities */ const PURPLE = rgb(.5, 0, 1);\n/** Color - Magenta\r\n *  @type {Color}\r\n *  @memberof Utilities */ const MAGENTA = rgb(1, 0, 1);\n///////////////////////////////////////////////////////////////////////////////\n/**\r\n * Timer object tracks how long has passed since it was set\r\n * @example\r\n * let a = new Timer;    // creates a timer that is not set\r\n * a.set(3);             // sets the timer to 3 seconds\r\n *\r\n * let b = new Timer(1); // creates a timer with 1 second left\r\n * b.unset();            // unsets the timer\r\n */ class Timer {\n    /** Create a timer object set time passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer elapses in seconds */ constructor(timeLeft){\n        this.time = timeLeft == undefined ? undefined : time + timeLeft;\n        this.setTime = timeLeft;\n    }\n    /** Set the timer with seconds passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer is elapsed in seconds */ set(timeLeft = 0) {\n        this.time = time + timeLeft;\n        this.setTime = timeLeft;\n    }\n    /** Unset the timer */ unset() {\n        this.time = undefined;\n    }\n    /** Returns true if set\r\n     * @return {Boolean} */ isSet() {\n        return this.time != undefined;\n    }\n    /** Returns true if set and has not elapsed\r\n     * @return {Boolean} */ active() {\n        return time < this.time;\n    }\n    /** Returns true if set and elapsed\r\n     * @return {Boolean} */ elapsed() {\n        return time >= this.time;\n    }\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */ get() {\n        return this.isSet() ? time - this.time : 0;\n    }\n    /** Get percentage elapsed based on time it was set to, returns 0 if not set\r\n     * @return {Number} */ getPercent() {\n        return this.isSet() ? percent(this.time - time, this.setTime, 0) : 0;\n    }\n    /** Returns this timer expressed as a string\r\n     * @return {String} */ toString() {\n        if (debug) return this.isSet() ? Math.abs(this.get()) + \" seconds \" + (this.get() < 0 ? \"before\" : \"after\") : \"unset\";\n    }\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */ valueOf() {\n        return this.get();\n    }\n}\n/**\r\n * LittleJS Engine Settings\r\n * - All settings for the engine are here\r\n * @namespace Settings\r\n */ ///////////////////////////////////////////////////////////////////////////////\n// Camera settings\n/** Position of camera in world space\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */ let cameraPos = vec2();\n/** Scale of camera in world space\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let cameraScale = 32;\n///////////////////////////////////////////////////////////////////////////////\n// Display settings\n/** The max size of the canvas, centered if window is larger\r\n *  @type {Vector2}\r\n *  @default Vector2(1920,1080)\r\n *  @memberof Settings */ let canvasMaxSize = vec2(1920, 1080);\n/** Fixed size of the canvas, if enabled canvas size never changes\r\n * - you may also need to set mainCanvasSize if using screen space coords in startup\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */ let canvasFixedSize = vec2();\n/** Disables filtering for crisper pixel art if true\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let canvasPixelated = true;\n/** Default font used for text rendering\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Settings */ let fontDefault = \"arial\";\n/** Enable to show the LittleJS splash screen be shown on startup\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let showSplashScreen = false;\n/** Disables all rendering, audio, and input for servers\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let headlessMode = false;\n///////////////////////////////////////////////////////////////////////////////\n// WebGL settings\n/** Enable webgl rendering, webgl can be disabled and removed from build (with some features disabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let glEnable = true;\n/** Fixes slow rendering in some browsers by not compositing the WebGL canvas\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let glOverlay = true;\n///////////////////////////////////////////////////////////////////////////////\n// Tile sheet settings\n/** Default size of tiles in pixels\r\n *  @type {Vector2}\r\n *  @default Vector2(16,16)\r\n *  @memberof Settings */ let tileSizeDefault = vec2(16);\n/** How many pixels smaller to draw tiles to prevent bleeding from neighbors\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let tileFixBleedScale = .5;\n///////////////////////////////////////////////////////////////////////////////\n// Object settings\n/** Enable physics solver for collisions between objects\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let enablePhysicsSolver = true;\n/** Default object mass for collision calcuations (how heavy objects are)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectDefaultMass = 1;\n/** How much to slow velocity by each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectDefaultDamping = 1;\n/** How much to slow angular velocity each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectDefaultAngleDamping = 1;\n/** How much to bounce when a collision occurs (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectDefaultElasticity = 0;\n/** How much to slow when touching (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectDefaultFriction = .8;\n/** Clamp max speed to avoid fast objects missing collisions\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let objectMaxSpeed = 1;\n/** How much gravity to apply to objects along the Y axis, negative is down\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let gravity = 0;\n/** Scales emit rate of particles, useful for low graphics mode (0 disables particle emitters)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let particleEmitRateScale = 1;\n///////////////////////////////////////////////////////////////////////////////\n// Input settings\n/** Should gamepads be allowed\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let gamepadsEnable = true;\n/** If true, the dpad input is also routed to the left analog stick (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let gamepadDirectionEmulateStick = true;\n/** If true the WASD keys are also routed to the direction keys (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let inputWASDEmulateDirection = true;\n/** True if touch input is enabled for mobile devices\r\n *  - Touch events will be routed to mouse events\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let touchInputEnable = true;\n/** True if touch gamepad should appear on mobile devices\r\n *  - Supports left analog stick, 4 face buttons and start button (button 9)\r\n *  - Must be set by end of gameInit to be activated\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let touchGamepadEnable = false;\n/** True if touch gamepad should be analog stick or false to use if 8 way dpad\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let touchGamepadAnalog = true;\n/** Size of virtual gamepad for touch devices in pixels\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let touchGamepadSize = 99;\n/** Transparency of touch gamepad overlay\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let touchGamepadAlpha = .3;\n/** Allow vibration hardware if it exists\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let vibrateEnable = true;\n///////////////////////////////////////////////////////////////////////////////\n// Audio settings\n/** All audio code can be disabled and removed from build\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let soundEnable = true;\n/** Volume scale to apply to all sound, music and speech\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let soundVolume = .3;\n/** Default range where sound no longer plays\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let soundDefaultRange = 40;\n/** Default range percent to start tapering off sound (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let soundDefaultTaper = .7;\n///////////////////////////////////////////////////////////////////////////////\n// Medals settings\n/** How long to show medals for in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let medalDisplayTime = 5;\n/** How quickly to slide on/off medals in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let medalDisplaySlideTime = .5;\n/** Size of medal display\r\n *  @type {Vector2}\r\n *  @default Vector2(640,80)\r\n *  @memberof Settings */ let medalDisplaySize = vec2(640, 80);\n/** Size of icon in medal display\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */ let medalDisplayIconSize = 50;\n/** Set to stop medals from being unlockable (like if cheats are enabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */ let medalsPreventUnlock = false;\n///////////////////////////////////////////////////////////////////////////////\n// Setters for global variables\n/** Set position of camera in world space\r\n *  @param {Vector2} pos\r\n *  @memberof Settings */ function setCameraPos(pos) {\n    cameraPos = pos;\n}\n/** Set scale of camera in world space\r\n *  @param {Number} scale\r\n *  @memberof Settings */ function setCameraScale(scale) {\n    cameraScale = scale;\n}\n/** Set max size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */ function setCanvasMaxSize(size) {\n    canvasMaxSize = size;\n}\n/** Set fixed size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */ function setCanvasFixedSize(size) {\n    canvasFixedSize = size;\n}\n/** Disables anti aliasing for pixel art if true\r\n *  @param {Boolean} pixelated\r\n *  @memberof Settings */ function setCanvasPixelated(pixelated) {\n    canvasPixelated = pixelated;\n}\n/** Set default font used for text rendering\r\n *  @param {String} font\r\n *  @memberof Settings */ function setFontDefault(font) {\n    fontDefault = font;\n}\n/** Set if the LittleJS splash screen be shown on startup\r\n *  @param {Boolean} show\r\n *  @memberof Settings */ function setShowSplashScreen(show) {\n    showSplashScreen = show;\n}\n/** Set to disalbe rendering, audio, and input for servers\r\n *  @param {Boolean} headless\r\n *  @memberof Settings */ function setHeadlessMode(headless) {\n    headlessMode = headless;\n}\n/** Set if webgl rendering is enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setGlEnable(enable) {\n    glEnable = enable;\n}\n/** Set to not composite the WebGL canvas\r\n *  @param {Boolean} overlay\r\n *  @memberof Settings */ function setGlOverlay(overlay) {\n    glOverlay = overlay;\n}\n/** Set default size of tiles in pixels\r\n *  @param {Vector2} size\r\n *  @memberof Settings */ function setTileSizeDefault(size) {\n    tileSizeDefault = size;\n}\n/** Set to prevent tile bleeding from neighbors in pixels\r\n *  @param {Number} scale\r\n *  @memberof Settings */ function setTileFixBleedScale(scale) {\n    tileFixBleedScale = scale;\n}\n/** Set if collisions between objects are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setEnablePhysicsSolver(enable) {\n    enablePhysicsSolver = enable;\n}\n/** Set default object mass for collison calcuations\r\n *  @param {Number} mass\r\n *  @memberof Settings */ function setObjectDefaultMass(mass) {\n    objectDefaultMass = mass;\n}\n/** Set how much to slow velocity by each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */ function setObjectDefaultDamping(damp) {\n    objectDefaultDamping = damp;\n}\n/** Set how much to slow angular velocity each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */ function setObjectDefaultAngleDamping(damp) {\n    objectDefaultAngleDamping = damp;\n}\n/** Set how much to bounce when a collision occur\r\n *  @param {Number} elasticity\r\n *  @memberof Settings */ function setObjectDefaultElasticity(elasticity) {\n    objectDefaultElasticity = elasticity;\n}\n/** Set how much to slow when touching\r\n *  @param {Number} friction\r\n *  @memberof Settings */ function setObjectDefaultFriction(friction) {\n    objectDefaultFriction = friction;\n}\n/** Set max speed to avoid fast objects missing collisions\r\n *  @param {Number} speed\r\n *  @memberof Settings */ function setObjectMaxSpeed(speed) {\n    objectMaxSpeed = speed;\n}\n/** Set how much gravity to apply to objects along the Y axis\r\n *  @param {Number} newGravity\r\n *  @memberof Settings */ function setGravity(newGravity) {\n    gravity = newGravity;\n}\n/** Set to scales emit rate of particles\r\n *  @param {Number} scale\r\n *  @memberof Settings */ function setParticleEmitRateScale(scale) {\n    particleEmitRateScale = scale;\n}\n/** Set if gamepads are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setGamepadsEnable(enable) {\n    gamepadsEnable = enable;\n}\n/** Set if the dpad input is also routed to the left analog stick\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setGamepadDirectionEmulateStick(enable) {\n    gamepadDirectionEmulateStick = enable;\n}\n/** Set if true the WASD keys are also routed to the direction keys\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setInputWASDEmulateDirection(enable) {\n    inputWASDEmulateDirection = enable;\n}\n/** Set if touch input is allowed\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setTouchInputEnable(enable) {\n    touchInputEnable = enable;\n}\n/** Set if touch gamepad should appear on mobile devices\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setTouchGamepadEnable(enable) {\n    touchGamepadEnable = enable;\n}\n/** Set if touch gamepad should be analog stick or 8 way dpad\r\n *  @param {Boolean} analog\r\n *  @memberof Settings */ function setTouchGamepadAnalog(analog) {\n    touchGamepadAnalog = analog;\n}\n/** Set size of virutal gamepad for touch devices in pixels\r\n *  @param {Number} size\r\n *  @memberof Settings */ function setTouchGamepadSize(size) {\n    touchGamepadSize = size;\n}\n/** Set transparency of touch gamepad overlay\r\n *  @param {Number} alpha\r\n *  @memberof Settings */ function setTouchGamepadAlpha(alpha) {\n    touchGamepadAlpha = alpha;\n}\n/** Set to allow vibration hardware if it exists\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setVibrateEnable(enable) {\n    vibrateEnable = enable;\n}\n/** Set to disable all audio code\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */ function setSoundEnable(enable) {\n    soundEnable = enable;\n}\n/** Set volume scale to apply to all sound, music and speech\r\n *  @param {Number} volume\r\n *  @memberof Settings */ function setSoundVolume(volume) {\n    soundVolume = volume;\n    if (soundEnable && !headlessMode && audioGainNode) audioGainNode.gain.value = volume; // update gain immediatly\n}\n/** Set default range where sound no longer plays\r\n *  @param {Number} range\r\n *  @memberof Settings */ function setSoundDefaultRange(range) {\n    soundDefaultRange = range;\n}\n/** Set default range percent to start tapering off sound\r\n *  @param {Number} taper\r\n *  @memberof Settings */ function setSoundDefaultTaper(taper) {\n    soundDefaultTaper = taper;\n}\n/** Set how long to show medals for in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */ function setMedalDisplayTime(time) {\n    medalDisplayTime = time;\n}\n/** Set how quickly to slide on/off medals in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */ function setMedalDisplaySlideTime(time) {\n    medalDisplaySlideTime = time;\n}\n/** Set size of medal display\r\n *  @param {Vector2} size\r\n *  @memberof Settings */ function setMedalDisplaySize(size) {\n    medalDisplaySize = size;\n}\n/** Set size of icon in medal display\r\n *  @param {Number} size\r\n *  @memberof Settings */ function setMedalDisplayIconSize(size) {\n    medalDisplayIconSize = size;\n}\n/** Set to stop medals from being unlockable\r\n *  @param {Boolean} preventUnlock\r\n *  @memberof Settings */ function setMedalsPreventUnlock(preventUnlock) {\n    medalsPreventUnlock = preventUnlock;\n}\n/** Set if watermark with FPS should be shown\r\n *  @param {Boolean} show\r\n *  @memberof Debug */ function setShowWatermark(show) {\n    showWatermark = show;\n}\n/** Set key code used to toggle debug mode, Esc by default\r\n *  @param {String} key\r\n *  @memberof Debug */ function setDebugKey(key) {\n    debugKey = key;\n}\n/** \r\n * LittleJS Object System\r\n */ /** \r\n * LittleJS Object Base Object Class\r\n * - Top level object class used by the engine\r\n * - Automatically adds self to object list\r\n * - Will be updated and rendered each frame\r\n * - Renders as a sprite from a tilesheet by default\r\n * - Can have color and additive color applied\r\n * - 2D Physics and collision system\r\n * - Sorted by renderOrder\r\n * - Objects can have children attached\r\n * - Parents are updated before children, and set child transform\r\n * - Call destroy() to get rid of objects\r\n *\r\n * The physics system used by objects is simple and fast with some caveats...\r\n * - Collision uses the axis aligned size, the object's rotation angle is only for rendering\r\n * - Objects are guaranteed to not intersect tile collision from physics\r\n * - If an object starts or is moved inside tile collision, it will not collide with that tile\r\n * - Collision for objects can be set to be solid to block other objects\r\n * - Objects may get pushed into overlapping other solid objects, if so they will push away\r\n * - Solid objects are more performance intensive and should be used sparingly\r\n * @example\r\n * // create an engine object, normally you would first extend the class with your own\r\n * const pos = vec2(2,3);\r\n * const object = new EngineObject(pos); \r\n */ class EngineObject {\n    /** Create an engine object and adds it to the list of objects\r\n     *  @param {Vector2}  [pos=(0,0)]       - World space position of the object\r\n     *  @param {Vector2}  [size=(1,1)]      - World space size of the object\r\n     *  @param {TileInfo} [tileInfo]        - Tile info to render object (undefined is untextured)\r\n     *  @param {Number}   [angle]           - Angle the object is rotated by\r\n     *  @param {Color}    [color=(1,1,1,1)] - Color to apply to tile when rendered\r\n     *  @param {Number}   [renderOrder]     - Objects sorted by renderOrder before being rendered\r\n     */ constructor(pos = vec2(), size = vec2(1), tileInfo, angle = 0, color, renderOrder = 0){\n        // set passed in params\n        ASSERT(isVector2(pos) && isVector2(size), \"ensure pos and size are vec2s\");\n        ASSERT(typeof tileInfo !== \"number\" || !tileInfo, \"old style tile setup\");\n        /** @property {Vector2} - World space position of the object */ this.pos = pos.copy();\n        /** @property {Vector2} - World space width and height of the object */ this.size = size;\n        /** @property {Vector2} - Size of object used for drawing, uses size if not set */ this.drawSize = undefined;\n        /** @property {TileInfo} - Tile info to render object (undefined is untextured) */ this.tileInfo = tileInfo;\n        /** @property {Number}  - Angle to rotate the object */ this.angle = angle;\n        /** @property {Color}   - Color to apply when rendered */ this.color = color;\n        /** @property {Color}   - Additive color to apply when rendered */ this.additiveColor = undefined;\n        /** @property {Boolean} - Should it flip along y axis when rendered */ this.mirror = false;\n        // physical properties\n        /** @property {Number} [mass=objectDefaultMass]                 - How heavy the object is, static if 0 */ this.mass = objectDefaultMass;\n        /** @property {Number} [damping=objectDefaultDamping]           - How much to slow down velocity each frame (0-1) */ this.damping = objectDefaultDamping;\n        /** @property {Number} [angleDamping=objectDefaultAngleDamping] - How much to slow down rotation each frame (0-1) */ this.angleDamping = objectDefaultAngleDamping;\n        /** @property {Number} [elasticity=objectDefaultElasticity]     - How bouncy the object is when colliding (0-1) */ this.elasticity = objectDefaultElasticity;\n        /** @property {Number} [friction=objectDefaultFriction]         - How much friction to apply when sliding (0-1) */ this.friction = objectDefaultFriction;\n        /** @property {Number}  - How much to scale gravity by for this object */ this.gravityScale = 1;\n        /** @property {Number}  - Objects are sorted by render order */ this.renderOrder = renderOrder;\n        /** @property {Vector2} - Velocity of the object */ this.velocity = vec2();\n        /** @property {Number}  - Angular velocity of the object */ this.angleVelocity = 0;\n        /** @property {Number}  - Track when object was created  */ this.spawnTime = time;\n        /** @property {Array}   - List of children of this object */ this.children = [];\n        /** @property {Boolean}  - Limit object speed using linear or circular math */ this.clampSpeedLinear = true;\n        // parent child system\n        /** @property {EngineObject} - Parent of object if in local space  */ this.parent = undefined;\n        /** @property {Vector2}      - Local position if child */ this.localPos = vec2();\n        /** @property {Number}       - Local angle if child  */ this.localAngle = 0;\n        // collision flags\n        /** @property {Boolean} - Object collides with the tile collision */ this.collideTiles = false;\n        /** @property {Boolean} - Object collides with solid objects */ this.collideSolidObjects = false;\n        /** @property {Boolean} - Object collides with and blocks other objects */ this.isSolid = false;\n        /** @property {Boolean} - Object collides with raycasts */ this.collideRaycast = false;\n        // add to list of objects\n        engineObjects.push(this);\n    }\n    /** Update the object transform, called automatically by engine even when paused */ updateTransforms() {\n        const parent = this.parent;\n        if (parent) {\n            // copy parent pos/angle\n            const mirror = parent.getMirrorSign();\n            this.pos = this.localPos.multiply(vec2(mirror, 1)).rotate(-parent.angle).add(parent.pos);\n            this.angle = mirror * this.localAngle + parent.angle;\n        }\n        // update children\n        for (const child of this.children)child.updateTransforms();\n    }\n    /** Update the object physics, called automatically by engine once each frame */ update() {\n        // child objects do not have physics\n        if (this.parent) return;\n        // limit max speed to prevent missing collisions\n        if (this.clampSpeedLinear) {\n            this.velocity.x = clamp(this.velocity.x, -objectMaxSpeed, objectMaxSpeed);\n            this.velocity.y = clamp(this.velocity.y, -objectMaxSpeed, objectMaxSpeed);\n        } else {\n            const length2 = this.velocity.lengthSquared();\n            if (length2 > objectMaxSpeed * objectMaxSpeed) {\n                const s = objectMaxSpeed / length2 ** .5;\n                this.velocity.x *= s;\n                this.velocity.y *= s;\n            }\n        }\n        // apply physics\n        const oldPos = this.pos.copy();\n        this.velocity.y += gravity * this.gravityScale;\n        this.pos.x += this.velocity.x *= this.damping;\n        this.pos.y += this.velocity.y *= this.damping;\n        this.angle += this.angleVelocity *= this.angleDamping;\n        // physics sanity checks\n        ASSERT(this.angleDamping >= 0 && this.angleDamping <= 1);\n        ASSERT(this.damping >= 0 && this.damping <= 1);\n        if (!enablePhysicsSolver || !this.mass) return;\n        const wasMovingDown = this.velocity.y < 0;\n        if (this.groundObject) {\n            // apply friction in local space of ground object\n            const groundSpeed = this.groundObject.velocity ? this.groundObject.velocity.x : 0;\n            this.velocity.x = groundSpeed + (this.velocity.x - groundSpeed) * this.friction;\n            this.groundObject = 0;\n        //debugOverlay && debugPhysics && debugPoint(this.pos.subtract(vec2(0,this.size.y/2)), '#0f0');\n        }\n        if (this.collideSolidObjects) {\n            // check collisions against solid objects\n            const epsilon = .001; // necessary to push slightly outside of the collision\n            for (const o of engineObjectsCollide){\n                // non solid objects don't collide with eachother\n                if (!this.isSolid && !o.isSolid || o.destroyed || o.parent || o == this) continue;\n                // check collision\n                if (!isOverlapping(this.pos, this.size, o.pos, o.size)) continue;\n                // notify objects of collision and check if should be resolved\n                const collide1 = this.collideWithObject(o);\n                const collide2 = o.collideWithObject(this);\n                if (!collide1 || !collide2) continue;\n                if (isOverlapping(oldPos, this.size, o.pos, o.size)) {\n                    // if already was touching, try to push away\n                    const deltaPos = oldPos.subtract(o.pos);\n                    const length = deltaPos.length();\n                    const pushAwayAccel = .001; // push away if already overlapping\n                    const velocity = length < .01 ? randVector(pushAwayAccel) : deltaPos.scale(pushAwayAccel / length);\n                    this.velocity = this.velocity.add(velocity);\n                    if (o.mass) o.velocity = o.velocity.subtract(velocity);\n                    debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, \"#f00\");\n                    continue;\n                }\n                // check for collision\n                const sizeBoth = this.size.add(o.size);\n                const smallStepUp = (oldPos.y - o.pos.y) * 2 > sizeBoth.y + gravity; // prefer to push up if small delta\n                const isBlockedX = abs(oldPos.y - o.pos.y) * 2 < sizeBoth.y;\n                const isBlockedY = abs(oldPos.x - o.pos.x) * 2 < sizeBoth.x;\n                const elasticity = max(this.elasticity, o.elasticity);\n                if (smallStepUp || isBlockedY || !isBlockedX) {\n                    // push outside object collision\n                    this.pos.y = o.pos.y + (sizeBoth.y / 2 + epsilon) * sign(oldPos.y - o.pos.y);\n                    if (o.groundObject && wasMovingDown || !o.mass) {\n                        // set ground object if landed on something\n                        if (wasMovingDown) this.groundObject = o;\n                        // bounce if other object is fixed or grounded\n                        this.velocity.y *= -elasticity;\n                    } else if (o.mass) {\n                        // inelastic collision\n                        const inelastic = (this.mass * this.velocity.y + o.mass * o.velocity.y) / (this.mass + o.mass);\n                        // elastic collision\n                        const elastic0 = this.velocity.y * (this.mass - o.mass) / (this.mass + o.mass) + o.velocity.y * 2 * o.mass / (this.mass + o.mass);\n                        const elastic1 = o.velocity.y * (o.mass - this.mass) / (this.mass + o.mass) + this.velocity.y * 2 * this.mass / (this.mass + o.mass);\n                        // lerp betwen elastic or inelastic based on elasticity\n                        this.velocity.y = lerp(elasticity, inelastic, elastic0);\n                        o.velocity.y = lerp(elasticity, inelastic, elastic1);\n                    }\n                }\n                if (!smallStepUp && isBlockedX) {\n                    // push outside collision\n                    this.pos.x = o.pos.x + (sizeBoth.x / 2 + epsilon) * sign(oldPos.x - o.pos.x);\n                    if (o.mass) {\n                        // inelastic collision\n                        const inelastic = (this.mass * this.velocity.x + o.mass * o.velocity.x) / (this.mass + o.mass);\n                        // elastic collision\n                        const elastic0 = this.velocity.x * (this.mass - o.mass) / (this.mass + o.mass) + o.velocity.x * 2 * o.mass / (this.mass + o.mass);\n                        const elastic1 = o.velocity.x * (o.mass - this.mass) / (this.mass + o.mass) + this.velocity.x * 2 * this.mass / (this.mass + o.mass);\n                        // lerp betwen elastic or inelastic based on elasticity\n                        this.velocity.x = lerp(elasticity, inelastic, elastic0);\n                        o.velocity.x = lerp(elasticity, inelastic, elastic1);\n                    } else this.velocity.x *= -elasticity;\n                }\n                debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, \"#f0f\");\n            }\n        }\n        if (this.collideTiles) {\n            // check collision against tiles\n            if (tileCollisionTest(this.pos, this.size, this)) // if already was stuck in collision, don't do anything\n            // this should not happen unless something starts in collision\n            {\n                if (!tileCollisionTest(oldPos, this.size, this)) {\n                    // test which side we bounced off (or both if a corner)\n                    const isBlockedY = tileCollisionTest(vec2(oldPos.x, this.pos.y), this.size, this);\n                    const isBlockedX = tileCollisionTest(vec2(this.pos.x, oldPos.y), this.size, this);\n                    if (isBlockedY || !isBlockedX) {\n                        // set if landed on ground\n                        this.groundObject = wasMovingDown;\n                        // bounce velocity\n                        this.velocity.y *= -this.elasticity;\n                        // adjust next velocity to settle on ground\n                        const o = (oldPos.y - this.size.y / 2 | 0) - (oldPos.y - this.size.y / 2);\n                        if (o < 0 && o > this.damping * this.velocity.y + gravity * this.gravityScale) this.velocity.y = this.damping ? (o - gravity * this.gravityScale) / this.damping : 0;\n                        // move to previous position\n                        this.pos.y = oldPos.y;\n                    }\n                    if (isBlockedX) {\n                        // move to previous position and bounce\n                        this.pos.x = oldPos.x;\n                        this.velocity.x *= -this.elasticity;\n                    }\n                }\n            }\n        }\n    }\n    /** Render the object, draws a tile by default, automatically called each frame, sorted by renderOrder */ render() {\n        // default object render\n        drawTile(this.pos, this.drawSize || this.size, this.tileInfo, this.color, this.angle, this.mirror, this.additiveColor);\n    }\n    /** Destroy this object, destroy it's children, detach it's parent, and mark it for removal */ destroy() {\n        if (this.destroyed) return;\n        // disconnect from parent and destroy chidren\n        this.destroyed = 1;\n        this.parent && this.parent.removeChild(this);\n        for (const child of this.children)child.destroy(child.parent = 0);\n    }\n    /** Convert from local space to world space\r\n     *  @param {Vector2} pos - local space point */ localToWorld(pos) {\n        return this.pos.add(pos.rotate(-this.angle));\n    }\n    /** Convert from world space to local space\r\n     *  @param {Vector2} pos - world space point */ worldToLocal(pos) {\n        return pos.subtract(this.pos).rotate(this.angle);\n    }\n    /** Convert from local space to world space for a vector (rotation only)\r\n     *  @param {Vector2} vec - local space vector */ localToWorldVector(vec) {\n        return vec.rotate(this.angle);\n    }\n    /** Convert from world space to local space for a vector (rotation only)\r\n     *  @param {Vector2} vec - world space vector */ worldToLocalVector(vec) {\n        return vec.rotate(-this.angle);\n    }\n    /** Called to check if a tile collision should be resolved\r\n     *  @param {Number}  tileData - the value of the tile at the position\r\n     *  @param {Vector2} pos      - tile where the collision occured\r\n     *  @return {Boolean}         - true if the collision should be resolved */ collideWithTile(tileData, pos) {\n        return tileData > 0;\n    }\n    /** Called to check if a object collision should be resolved\r\n     *  @param {EngineObject} object - the object to test against\r\n     *  @return {Boolean}            - true if the collision should be resolved\r\n     */ collideWithObject(object) {\n        return true;\n    }\n    /** How long since the object was created\r\n     *  @return {Number} */ getAliveTime() {\n        return time - this.spawnTime;\n    }\n    /** Apply acceleration to this object (adjust velocity, not affected by mass)\r\n     *  @param {Vector2} acceleration */ applyAcceleration(acceleration) {\n        if (this.mass) this.velocity = this.velocity.add(acceleration);\n    }\n    /** Apply force to this object (adjust velocity, affected by mass)\r\n     *  @param {Vector2} force */ applyForce(force) {\n        this.applyAcceleration(force.scale(1 / this.mass));\n    }\n    /** Get the direction of the mirror\r\n     *  @return {Number} -1 if this.mirror is true, or 1 if not mirrored */ getMirrorSign() {\n        return this.mirror ? -1 : 1;\n    }\n    /** Attaches a child to this with a given local transform\r\n     *  @param {EngineObject} child\r\n     *  @param {Vector2}      [localPos=(0,0)]\r\n     *  @param {Number}       [localAngle] */ addChild(child, localPos = vec2(), localAngle = 0) {\n        ASSERT(!child.parent && !this.children.includes(child));\n        this.children.push(child);\n        child.parent = this;\n        child.localPos = localPos.copy();\n        child.localAngle = localAngle;\n    }\n    /** Removes a child from this one\r\n     *  @param {EngineObject} child */ removeChild(child) {\n        ASSERT(child.parent == this && this.children.includes(child));\n        this.children.splice(this.children.indexOf(child), 1);\n        child.parent = 0;\n    }\n    /** Set how this object collides\r\n     *  @param {Boolean} [collideSolidObjects] - Does it collide with solid objects?\r\n     *  @param {Boolean} [isSolid]             - Does it collide with and block other objects? (expensive in large numbers)\r\n     *  @param {Boolean} [collideTiles]        - Does it collide with the tile collision?\r\n     *  @param {Boolean} [collideRaycast]      - Does it collide with raycasts? */ setCollision(collideSolidObjects = true, isSolid = true, collideTiles = true, collideRaycast = true) {\n        ASSERT(collideSolidObjects || !isSolid, \"solid objects must be set to collide\");\n        this.collideSolidObjects = collideSolidObjects;\n        this.isSolid = isSolid;\n        this.collideTiles = collideTiles;\n        this.collideRaycast = collideRaycast;\n    }\n    /** Returns string containg info about this object for debugging\r\n     *  @return {String} */ toString() {\n        if (debug) {\n            let text = \"type = \" + this.constructor.name;\n            if (this.pos.x || this.pos.y) text += \"\\npos = \" + this.pos;\n            if (this.velocity.x || this.velocity.y) text += \"\\nvelocity = \" + this.velocity;\n            if (this.size.x || this.size.y) text += \"\\nsize = \" + this.size;\n            if (this.angle) text += \"\\nangle = \" + this.angle.toFixed(3);\n            if (this.color) text += \"\\ncolor = \" + this.color;\n            return text;\n        }\n    }\n    /** Render debug info for this object  */ renderDebugInfo() {\n        if (debug) {\n            // show object info for debugging\n            const size = vec2(max(this.size.x, .2), max(this.size.y, .2));\n            const color1 = rgb(this.collideTiles ? 1 : 0, this.collideSolidObjects ? 1 : 0, this.isSolid ? 1 : 0, this.parent ? .2 : .5);\n            const color2 = this.parent ? rgb(1, 1, 1, .5) : rgb(0, 0, 0, .8);\n            drawRect(this.pos, size, color1, this.angle, false);\n            drawRect(this.pos, size.scale(.8), color2, this.angle, false);\n            this.parent && drawLine(this.pos, this.parent.pos, .1, rgb(0, 0, 1, .5), false);\n        }\n    }\n}\n/** \r\n * LittleJS Drawing System\r\n * - Hybrid system with both Canvas2D and WebGL available\r\n * - Super fast tile sheet rendering with WebGL\r\n * - Can apply rotation, mirror, color and additive color\r\n * - Font rendering system with built in engine font\r\n * - Many useful utility functions\r\n * \r\n * LittleJS uses a hybrid rendering solution with the best of both Canvas2D and WebGL.\r\n * There are 3 canvas/contexts available to draw to...\r\n * mainCanvas - 2D background canvas, non WebGL stuff like tile layers are drawn here.\r\n * glCanvas - Used by the accelerated WebGL batch rendering system.\r\n * overlayCanvas - Another 2D canvas that appears on top of the other 2 canvases.\r\n * \r\n * The WebGL rendering system is very fast with some caveats...\r\n * - Switching blend modes (additive) or textures causes another draw call which is expensive in excess\r\n * - Group additive rendering together using renderOrder to mitigate this issue\r\n * \r\n * The LittleJS rendering solution is intentionally simple, feel free to adjust it for your needs!\r\n * @namespace Draw\r\n */ /** The primary 2D canvas visible to the user\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */ let mainCanvas;\n/** 2d context for mainCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */ let mainContext;\n/** A canvas that appears on top of everything the same size as mainCanvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */ let overlayCanvas;\n/** 2d context for overlayCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */ let overlayContext;\n/** The size of the main canvas (and other secondary canvases) \r\n *  @type {Vector2}\r\n *  @memberof Draw */ let mainCanvasSize = vec2();\n/** Array containing texture info for batch rendering system\r\n *  @type {Array}\r\n *  @memberof Draw */ let textureInfos = [];\n// Keep track of how many draw calls there were each frame for debugging\nlet drawCount;\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Create a tile info object\r\n * - This can take vecs or floats for easier use and conversion\r\n * - If an index is passed in, the tile size and index will determine the position\r\n * @param {(Number|Vector2)} [pos=(0,0)]            - Top left corner of tile in pixels or index\r\n * @param {(Number|Vector2)} [size=tileSizeDefault] - Size of tile in pixels\r\n * @param {Number} [textureIndex]                   - Texture index to use\r\n * @return {TileInfo}\r\n * @example\r\n * tile(2)                       // a tile at index 2 using the default tile size of 16\r\n * tile(5, 8)                    // a tile at index 5 using a tile size of 8\r\n * tile(1, 16, 3)                // a tile at index 1 of size 16 on texture 3\r\n * tile(vec2(4,8), vec2(30,10))  // a tile at pixel location (4,8) with a size of (30,10)\r\n * @memberof Draw\r\n */ function tile(pos = vec2(), size = tileSizeDefault, textureIndex = 0) {\n    if (headlessMode) return new TileInfo;\n    // if size is a number, make it a vector\n    if (typeof size === \"number\") {\n        ASSERT(size > 0);\n        size = vec2(size);\n    }\n    // if pos is a number, use it as a tile index\n    if (typeof pos === \"number\") {\n        const textureInfo = textureInfos[textureIndex];\n        ASSERT(textureInfo, \"Texture not loaded\");\n        const cols = textureInfo.size.x / size.x | 0;\n        pos = vec2(pos % cols * size.x, (pos / cols | 0) * size.y);\n    }\n    // return a tile info object\n    return new TileInfo(pos, size, textureIndex);\n}\n/** \r\n * Tile Info - Stores info about how to draw a tile\r\n */ class TileInfo {\n    /** Create a tile info object\r\n     *  @param {Vector2} [pos=(0,0)]            - Top left corner of tile in pixels\r\n     *  @param {Vector2} [size=tileSizeDefault] - Size of tile in pixels\r\n     *  @param {Number}  [textureIndex]         - Texture index to use\r\n     */ constructor(pos = vec2(), size = tileSizeDefault, textureIndex = 0){\n        /** @property {Vector2} - Top left corner of tile in pixels */ this.pos = pos.copy();\n        /** @property {Vector2} - Size of tile in pixels */ this.size = size.copy();\n        /** @property {Number} - Texture index to use */ this.textureIndex = textureIndex;\n    }\n    /** Returns a copy of this tile offset by a vector\r\n    *  @param {Vector2} offset - Offset to apply in pixels\r\n    *  @return {TileInfo}\r\n    */ offset(offset) {\n        return new TileInfo(this.pos.add(offset), this.size, this.textureIndex);\n    }\n    /** Returns a copy of this tile offset by a number of animation frames\r\n    *  @param {Number} frame - Offset to apply in animation frames\r\n    *  @return {TileInfo}\r\n    */ frame(frame) {\n        ASSERT(typeof frame == \"number\");\n        return this.offset(vec2(frame * this.size.x, 0));\n    }\n    /** Returns the texture info for this tile\r\n    *  @return {TextureInfo}\r\n    */ getTextureInfo() {\n        return textureInfos[this.textureIndex];\n    }\n}\n/** Texture Info - Stores info about each texture */ class TextureInfo {\n    /**\r\n     * Create a TextureInfo, called automatically by the engine\r\n     * @param {HTMLImageElement} image\r\n     */ constructor(image){\n        /** @property {HTMLImageElement} - image source */ this.image = image;\n        /** @property {Vector2} - size of the image */ this.size = vec2(image.width, image.height);\n        /** @property {WebGLTexture} - webgl texture */ this.glTexture = glEnable && glCreateTexture(image);\n        /** @property {Vector2} - size to adjust tile to fix bleeding */ this.fixBleedSize = vec2(tileFixBleedScale).divide(this.size);\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n/** Convert from screen to world space coordinates\r\n *  @param {Vector2} screenPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */ function screenToWorld(screenPos) {\n    return new Vector2((screenPos.x - mainCanvasSize.x / 2 + .5) / cameraScale + cameraPos.x, (screenPos.y - mainCanvasSize.y / 2 + .5) / -cameraScale + cameraPos.y);\n}\n/** Convert from world to screen space coordinates\r\n *  @param {Vector2} worldPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */ function worldToScreen(worldPos) {\n    return new Vector2((worldPos.x - cameraPos.x) * cameraScale + mainCanvasSize.x / 2 - .5, (worldPos.y - cameraPos.y) * -cameraScale + mainCanvasSize.y / 2 - .5);\n}\n/** Get the camera's visible area in world space\r\n *  @return {Vector2}\r\n *  @memberof Draw */ function getCameraSize() {\n    return mainCanvasSize.scale(1 / cameraScale);\n}\n/** Draw textured tile centered in world space, with color applied if using WebGL\r\n *  @param {Vector2} pos                        - Center of the tile in world space\r\n *  @param {Vector2} [size=(1,1)]               - Size of the tile in world space\r\n *  @param {TileInfo}[tileInfo]                 - Tile info to use, untextured if undefined\r\n *  @param {Color}   [color=(1,1,1,1)]          - Color to modulate with\r\n *  @param {Number}  [angle]                    - Angle to rotate by\r\n *  @param {Boolean} [mirror]                   - If true image is flipped along the Y axis\r\n *  @param {Color}   [additiveColor=(0,0,0,0)]  - Additive color to be applied\r\n *  @param {Boolean} [useWebGL=glEnable]        - Use accelerated WebGL rendering\r\n *  @param {Boolean} [screenSpace=false]        - If true the pos and size are in screen space\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context] - Canvas 2D context to draw to\r\n *  @memberof Draw */ function drawTile(pos, size = vec2(1), tileInfo, color = new Color, angle = 0, mirror, additiveColor = new Color(0, 0, 0, 0), useWebGL = glEnable, screenSpace, context) {\n    ASSERT(!context || !useWebGL, \"context only supported in canvas 2D mode\");\n    ASSERT(typeof tileInfo !== \"number\" || !tileInfo, \"this is an old style calls, to fix replace it with tile(tileIndex, tileSize)\");\n    const textureInfo = tileInfo && tileInfo.getTextureInfo();\n    if (useWebGL) {\n        if (screenSpace) {\n            // convert to world space\n            pos = screenToWorld(pos);\n            size = size.scale(1 / cameraScale);\n        }\n        if (textureInfo) {\n            // calculate uvs and render\n            const x = tileInfo.pos.x / textureInfo.size.x;\n            const y = tileInfo.pos.y / textureInfo.size.y;\n            const w = tileInfo.size.x / textureInfo.size.x;\n            const h = tileInfo.size.y / textureInfo.size.y;\n            const tileImageFixBleed = textureInfo.fixBleedSize;\n            glSetTexture(textureInfo.glTexture);\n            glDraw(pos.x, pos.y, mirror ? -size.x : size.x, size.y, angle, x + tileImageFixBleed.x, y + tileImageFixBleed.y, x - tileImageFixBleed.x + w, y - tileImageFixBleed.y + h, color.rgbaInt(), additiveColor.rgbaInt());\n        } else // if no tile info, force untextured\n        glDraw(pos.x, pos.y, size.x, size.y, angle, 0, 0, 0, 0, 0, color.rgbaInt());\n    } else {\n        // normal canvas 2D rendering method (slower)\n        showWatermark && ++drawCount;\n        drawCanvas2D(pos, size, angle, mirror, (context)=>{\n            if (textureInfo) {\n                // calculate uvs and render\n                const x = tileInfo.pos.x + tileFixBleedScale;\n                const y = tileInfo.pos.y + tileFixBleedScale;\n                const w = tileInfo.size.x - 2 * tileFixBleedScale;\n                const h = tileInfo.size.y - 2 * tileFixBleedScale;\n                context.globalAlpha = color.a; // only alpha is supported\n                context.drawImage(textureInfo.image, x, y, w, h, -0.5, -0.5, 1, 1);\n                context.globalAlpha = 1; // set back to full alpha\n            } else {\n                // if no tile info, force untextured\n                context.fillStyle = color;\n                context.fillRect(-0.5, -0.5, 1, 1);\n            }\n        }, screenSpace, context);\n    }\n}\n/** Draw colored rect centered on pos\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=(1,1)]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */ function drawRect(pos, size, color, angle, useWebGL, screenSpace, context) {\n    drawTile(pos, size, undefined, color, angle, false, undefined, useWebGL, screenSpace, context);\n}\n/** Draw colored line between two points\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {Number}  [thickness]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */ function drawLine(posA, posB, thickness = .1, color, useWebGL, screenSpace, context) {\n    const halfDelta = vec2((posB.x - posA.x) / 2, (posB.y - posA.y) / 2);\n    const size = vec2(thickness, halfDelta.length() * 2);\n    drawRect(posA.add(halfDelta), size, color, halfDelta.angle(), useWebGL, screenSpace, context);\n}\n/** Draw directly to a 2d canvas context in world space\r\n *  @param {Vector2}  pos\r\n *  @param {Vector2}  size\r\n *  @param {Number}   angle\r\n *  @param {Boolean}  mirror\r\n *  @param {Function} drawFunction\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */ function drawCanvas2D(pos, size, angle, mirror, drawFunction, screenSpace, context = mainContext) {\n    if (!screenSpace) {\n        // transform from world space to screen space\n        pos = worldToScreen(pos);\n        size = size.scale(cameraScale);\n    }\n    context.save();\n    context.translate(pos.x + .5, pos.y + .5);\n    context.rotate(angle);\n    context.scale(mirror ? -size.x : size.x, -size.y);\n    drawFunction(context);\n    context.restore();\n}\n/** Enable normal or additive blend mode\r\n *  @param {Boolean} [additive]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */ function setBlendMode(additive, useWebGL = glEnable, context) {\n    ASSERT(!context || !useWebGL, \"context only supported in canvas 2D mode\");\n    if (useWebGL) glAdditive = additive;\n    else {\n        if (!context) context = mainContext;\n        context.globalCompositeOperation = additive ? \"lighter\" : \"source-over\";\n    }\n}\n/** Draw text on overlay canvas in world space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign='center']\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */ function drawText(text, pos, size = 1, color, lineWidth = 0, lineColor, textAlign, font, context) {\n    drawTextScreen(text, worldToScreen(pos), size * cameraScale, color, lineWidth * cameraScale, lineColor, textAlign, font, context);\n}\n/** Draw text on overlay canvas in screen space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign]\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */ function drawTextScreen(text, pos, size = 1, color = new Color, lineWidth = 0, lineColor = new Color(0, 0, 0), textAlign = \"center\", font = fontDefault, context = overlayContext) {\n    context.fillStyle = color.toString();\n    context.lineWidth = lineWidth;\n    context.strokeStyle = lineColor.toString();\n    context.textAlign = textAlign;\n    context.font = size + \"px \" + font;\n    context.textBaseline = \"middle\";\n    context.lineJoin = \"round\";\n    pos = pos.copy();\n    (text + \"\").split(\"\\n\").forEach((line)=>{\n        lineWidth && context.strokeText(line, pos.x, pos.y);\n        context.fillText(line, pos.x, pos.y);\n        pos.y += size;\n    });\n}\n///////////////////////////////////////////////////////////////////////////////\nlet engineFontImage;\n/** \r\n * Font Image Object - Draw text on a 2D canvas by using characters in an image\r\n * - 96 characters (from space to tilde) are stored in an image\r\n * - Uses a default 8x8 font if none is supplied\r\n * - You can also use fonts from the main tile sheet\r\n * @example\r\n * // use built in font\r\n * const font = new ImageFont;\r\n * \r\n * // draw text\r\n * font.drawTextScreen(\"LittleJS\\nHello World!\", vec2(200, 50));\r\n */ class FontImage {\n    /** Create an image font\r\n     *  @param {HTMLImageElement} [image]    - Image for the font, if undefined default font is used\r\n     *  @param {Vector2} [tileSize=(8,8)]    - Size of the font source tiles\r\n     *  @param {Vector2} [paddingSize=(0,1)] - How much extra space to add between characters\r\n     *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext] - context to draw to\r\n     */ constructor(image, tileSize = vec2(8), paddingSize = vec2(0, 1), context = overlayContext){\n        // load default font image\n        if (!engineFontImage) (engineFontImage = new Image).src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC\";\n        this.image = image || engineFontImage;\n        this.tileSize = tileSize;\n        this.paddingSize = paddingSize;\n        this.context = context;\n    }\n    /** Draw text in world space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale=.25]\r\n     *  @param {Boolean} [center]\r\n     */ drawText(text, pos, scale = 1, center) {\n        this.drawTextScreen(text, worldToScreen(pos).floor(), scale * cameraScale | 0, center);\n    }\n    /** Draw text in screen space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale]\r\n     *  @param {Boolean} [center]\r\n     */ drawTextScreen(text, pos, scale = 4, center) {\n        const context = this.context;\n        context.save();\n        context.imageSmoothingEnabled = !canvasPixelated;\n        const size = this.tileSize;\n        const drawSize = size.add(this.paddingSize).scale(scale);\n        const cols = this.image.width / this.tileSize.x | 0;\n        (text + \"\").split(\"\\n\").forEach((line, i)=>{\n            const centerOffset = center ? line.length * size.x * scale / 2 | 0 : 0;\n            for(let j = line.length; j--;){\n                // draw each character\n                let charCode = line[j].charCodeAt(0);\n                if (charCode < 32 || charCode > 127) charCode = 127; // unknown character\n                // get the character source location and draw it\n                const tile = charCode - 32;\n                const x = tile % cols;\n                const y = tile / cols | 0;\n                const drawPos = pos.add(vec2(j, i).multiply(drawSize));\n                context.drawImage(this.image, x * size.x, y * size.y, size.x, size.y, drawPos.x - centerOffset, drawPos.y, size.x * scale, size.y * scale);\n            }\n        });\n        context.restore();\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n// Fullscreen mode\n/** Returns true if fullscreen mode is active\r\n *  @return {Boolean}\r\n *  @memberof Draw */ function isFullscreen() {\n    return !!document.fullscreenElement;\n}\n/** Toggle fullsceen mode\r\n *  @memberof Draw */ function toggleFullscreen() {\n    if (isFullscreen()) {\n        if (document.exitFullscreen) document.exitFullscreen();\n    } else if (document.body.requestFullscreen) document.body.requestFullscreen();\n}\n/** \r\n * LittleJS Input System\r\n * - Tracks keyboard down, pressed, and released\r\n * - Tracks mouse buttons, position, and wheel\r\n * - Tracks multiple analog gamepads\r\n * - Touch input is handled as mouse input\r\n * - Virtual gamepad for touch devices\r\n * @namespace Input\r\n */ /** Returns true if device key is down\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function keyIsDown(key, device = 0) {\n    ASSERT(device > 0 || typeof key !== \"number\" || key < 3, \"use code string for keyboard\");\n    return inputData[device] && !!(inputData[device][key] & 1);\n}\n/** Returns true if device key was pressed this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function keyWasPressed(key, device = 0) {\n    ASSERT(device > 0 || typeof key !== \"number\" || key < 3, \"use code string for keyboard\");\n    return inputData[device] && !!(inputData[device][key] & 2);\n}\n/** Returns true if device key was released this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function keyWasReleased(key, device = 0) {\n    ASSERT(device > 0 || typeof key !== \"number\" || key < 3, \"use code string for keyboard\");\n    return inputData[device] && !!(inputData[device][key] & 4);\n}\n/** Clears all input\r\n *  @memberof Input */ function clearInput() {\n    inputData = [\n        []\n    ];\n}\n/** Returns true if mouse button is down\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */ const mouseIsDown = keyIsDown;\n/** Returns true if mouse button was pressed\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */ const mouseWasPressed = keyWasPressed;\n/** Returns true if mouse button was released\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */ const mouseWasReleased = keyWasReleased;\n/** Mouse pos in world space\r\n *  @type {Vector2}\r\n *  @memberof Input */ let mousePos = vec2();\n/** Mouse pos in screen space\r\n *  @type {Vector2}\r\n *  @memberof Input */ let mousePosScreen = vec2();\n/** Mouse wheel delta this frame\r\n *  @type {Number}\r\n *  @memberof Input */ let mouseWheel = 0;\n/** Returns true if user is using gamepad (has more recently pressed a gamepad button)\r\n *  @type {Boolean}\r\n *  @memberof Input */ let isUsingGamepad = false;\n/** Prevents input continuing to the default browser handling (false by default)\r\n *  @type {Boolean}\r\n *  @memberof Input */ let preventDefaultInput = false;\n/** Returns true if gamepad button is down\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function gamepadIsDown(button, gamepad = 0) {\n    return keyIsDown(button, gamepad + 1);\n}\n/** Returns true if gamepad button was pressed\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function gamepadWasPressed(button, gamepad = 0) {\n    return keyWasPressed(button, gamepad + 1);\n}\n/** Returns true if gamepad button was released\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */ function gamepadWasReleased(button, gamepad = 0) {\n    return keyWasReleased(button, gamepad + 1);\n}\n/** Returns gamepad stick value\r\n *  @param {Number} stick\r\n *  @param {Number} [gamepad]\r\n *  @return {Vector2}\r\n *  @memberof Input */ function gamepadStick(stick, gamepad = 0) {\n    return gamepadStickData[gamepad] ? gamepadStickData[gamepad][stick] || vec2() : vec2();\n}\n///////////////////////////////////////////////////////////////////////////////\n// Input update called by engine\n// store input as a bit field for each key: 1 = isDown, 2 = wasPressed, 4 = wasReleased\n// mouse and keyboard are stored together in device 0, gamepads are in devices > 0\nlet inputData = [\n    []\n];\nfunction inputUpdate() {\n    if (headlessMode) return;\n    // clear input when lost focus (prevent stuck keys)\n    if (!(touchInputEnable && isTouchDevice) && !document.hasFocus()) clearInput();\n    // update mouse world space position\n    mousePos = screenToWorld(mousePosScreen);\n    // update gamepads if enabled\n    gamepadsUpdate();\n}\nfunction inputUpdatePost() {\n    if (headlessMode) return;\n    // clear input to prepare for next frame\n    for (const deviceInputData of inputData)for(const i in deviceInputData)deviceInputData[i] &= 1;\n    mouseWheel = 0;\n}\n///////////////////////////////////////////////////////////////////////////////\n// Input event handlers\nfunction inputInit() {\n    if (headlessMode) return;\n    onkeydown = (e)=>{\n        if (debug && e.target != document.body) return;\n        if (!e.repeat) {\n            isUsingGamepad = false;\n            inputData[0][e.code] = 3;\n            if (inputWASDEmulateDirection) inputData[0][remapKey(e.code)] = 3;\n        }\n        preventDefaultInput && e.preventDefault();\n    };\n    onkeyup = (e)=>{\n        if (debug && e.target != document.body) return;\n        inputData[0][e.code] = 4;\n        if (inputWASDEmulateDirection) inputData[0][remapKey(e.code)] = 4;\n    };\n    // handle remapping wasd keys to directions\n    function remapKey(c) {\n        return inputWASDEmulateDirection ? c == \"KeyW\" ? \"ArrowUp\" : c == \"KeyS\" ? \"ArrowDown\" : c == \"KeyA\" ? \"ArrowLeft\" : c == \"KeyD\" ? \"ArrowRight\" : c : c;\n    }\n    // mouse event handlers\n    onmousedown = (e)=>{\n        isUsingGamepad = false;\n        inputData[0][e.button] = 3;\n        mousePosScreen = mouseToScreen(e);\n        e.button && e.preventDefault();\n    };\n    onmouseup = (e)=>inputData[0][e.button] = inputData[0][e.button] & 2 | 4;\n    onmousemove = (e)=>mousePosScreen = mouseToScreen(e);\n    onwheel = (e)=>mouseWheel = e.ctrlKey ? 0 : sign(e.deltaY);\n    oncontextmenu = (e)=>false; // prevent right click menu\n    // init touch input\n    if (isTouchDevice && touchInputEnable && !headlessMode) touchInputInit();\n}\n// convert a mouse or touch event position to screen space\nfunction mouseToScreen(mousePos) {\n    if (!mainCanvas || headlessMode) return vec2(); // fix bug that can occur if user clicks before page loads\n    const rect = mainCanvas.getBoundingClientRect();\n    return vec2(mainCanvas.width, mainCanvas.height).multiply(vec2(percent(mousePos.x, rect.left, rect.right), percent(mousePos.y, rect.top, rect.bottom)));\n}\n///////////////////////////////////////////////////////////////////////////////\n// Gamepad input\n// gamepad internal variables\nconst gamepadStickData = [];\n// gamepads are updated by engine every frame automatically\nfunction gamepadsUpdate() {\n    const applyDeadZones = (v)=>{\n        const min = .3, max = .8;\n        const deadZone = (v)=>v > min ? percent(v, min, max) : v < -min ? -percent(-v, min, max) : 0;\n        return vec2(deadZone(v.x), deadZone(-v.y)).clampLength();\n    };\n    // update touch gamepad if enabled\n    if (touchGamepadEnable && isTouchDevice) {\n        ASSERT(touchGamepadButtons, \"set touchGamepadEnable before calling init!\");\n        if (touchGamepadTimer.isSet()) {\n            // read virtual analog stick\n            const sticks = gamepadStickData[0] || (gamepadStickData[0] = []);\n            sticks[0] = vec2();\n            if (touchGamepadAnalog) sticks[0] = applyDeadZones(touchGamepadStick);\n            else if (touchGamepadStick.lengthSquared() > .3) {\n                // convert to 8 way dpad\n                sticks[0].x = Math.round(touchGamepadStick.x);\n                sticks[0].y = -Math.round(touchGamepadStick.y);\n                sticks[0] = sticks[0].clampLength();\n            }\n            // read virtual gamepad buttons\n            const data = inputData[1] || (inputData[1] = []);\n            for(let i = 10; i--;){\n                const j = i == 3 ? 2 : i == 2 ? 3 : i; // fix button locations\n                const wasDown = gamepadIsDown(j, 0);\n                data[j] = touchGamepadButtons[i] ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\n            }\n        }\n    }\n    // return if gamepads are disabled or not supported\n    if (!gamepadsEnable || !navigator || !navigator.getGamepads) return;\n    // only poll gamepads when focused or in debug mode\n    if (!debug && !document.hasFocus()) return;\n    // poll gamepads\n    const gamepads = navigator.getGamepads();\n    for(let i = gamepads.length; i--;){\n        // get or create gamepad data\n        const gamepad = gamepads[i];\n        const data = inputData[i + 1] || (inputData[i + 1] = []);\n        const sticks = gamepadStickData[i] || (gamepadStickData[i] = []);\n        if (gamepad) {\n            // read analog sticks\n            for(let j = 0; j < gamepad.axes.length - 1; j += 2)sticks[j >> 1] = applyDeadZones(vec2(gamepad.axes[j], gamepad.axes[j + 1]));\n            // read buttons\n            for(let j = gamepad.buttons.length; j--;){\n                const button = gamepad.buttons[j];\n                const wasDown = gamepadIsDown(j, i);\n                data[j] = button.pressed ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\n                isUsingGamepad ||= !i && button.pressed;\n            }\n            if (gamepadDirectionEmulateStick) {\n                // copy dpad to left analog stick when pressed\n                const dpad = vec2((gamepadIsDown(15, i) && 1) - (gamepadIsDown(14, i) && 1), (gamepadIsDown(12, i) && 1) - (gamepadIsDown(13, i) && 1));\n                if (dpad.lengthSquared()) sticks[0] = dpad.clampLength();\n            }\n            // disable touch gamepad if using real gamepad\n            touchGamepadEnable && isUsingGamepad && touchGamepadTimer.unset();\n        }\n    }\n}\n///////////////////////////////////////////////////////////////////////////////\n/** Pulse the vibration hardware if it exists\r\n *  @param {Number|Array} [pattern] - single value in ms or vibration interval array\r\n *  @memberof Input */ function vibrate(pattern = 100) {\n    vibrateEnable && !headlessMode && navigator && navigator.vibrate && navigator.vibrate(pattern);\n}\n/** Cancel any ongoing vibration\r\n *  @memberof Input */ function vibrateStop() {\n    vibrate(0);\n}\n///////////////////////////////////////////////////////////////////////////////\n// Touch input & virtual on screen gamepad\n/** True if a touch device has been detected\r\n *  @memberof Input */ const isTouchDevice = window.ontouchstart !== undefined;\n// touch gamepad internal variables\nlet touchGamepadTimer = new Timer, touchGamepadButtons, touchGamepadStick;\n// enable touch input mouse passthrough\nfunction touchInputInit() {\n    // add non passive touch event listeners\n    let handleTouch = handleTouchDefault;\n    if (touchGamepadEnable) {\n        // touch input internal variables\n        handleTouch = handleTouchGamepad;\n        touchGamepadButtons = [];\n        touchGamepadStick = vec2();\n    }\n    document.addEventListener(\"touchstart\", (e)=>handleTouch(e), {\n        passive: false\n    });\n    document.addEventListener(\"touchmove\", (e)=>handleTouch(e), {\n        passive: false\n    });\n    document.addEventListener(\"touchend\", (e)=>handleTouch(e), {\n        passive: false\n    });\n    // override mouse events\n    onmousedown = onmouseup = ()=>0;\n    // handle all touch events the same way\n    let wasTouching;\n    function handleTouchDefault(e) {\n        // fix stalled audio requiring user interaction\n        if (soundEnable && audioContext && audioContext.state != \"running\") zzfx(0);\n        // check if touching and pass to mouse events\n        const touching = e.touches.length;\n        const button = 0; // all touches are left mouse button\n        if (touching) {\n            // set event pos and pass it along\n            const p = vec2(e.touches[0].clientX, e.touches[0].clientY);\n            mousePosScreen = mouseToScreen(p);\n            wasTouching ? isUsingGamepad = false : inputData[0][button] = 3;\n        } else if (wasTouching) inputData[0][button] = inputData[0][button] & 2 | 4;\n        // set was touching\n        wasTouching = touching;\n        // prevent default handling like copy and magnifier lens\n        if (document.hasFocus()) e.preventDefault();\n        // must return true so the document will get focus\n        return true;\n    }\n    // special handling for virtual gamepad mode\n    function handleTouchGamepad(e) {\n        // clear touch gamepad input\n        touchGamepadStick = vec2();\n        touchGamepadButtons = [];\n        isUsingGamepad = true;\n        const touching = e.touches.length;\n        if (touching) {\n            touchGamepadTimer.set();\n            if (paused) {\n                // touch anywhere to press start when paused\n                touchGamepadButtons[9] = 1;\n                return;\n            }\n        }\n        // get center of left and right sides\n        const stickCenter = vec2(touchGamepadSize, mainCanvasSize.y - touchGamepadSize);\n        const buttonCenter = mainCanvasSize.subtract(vec2(touchGamepadSize, touchGamepadSize));\n        const startCenter = mainCanvasSize.scale(.5);\n        // check each touch point\n        for (const touch of e.touches){\n            const touchPos = mouseToScreen(vec2(touch.clientX, touch.clientY));\n            if (touchPos.distance(stickCenter) < touchGamepadSize) // virtual analog stick\n            touchGamepadStick = touchPos.subtract(stickCenter).scale(2 / touchGamepadSize).clampLength();\n            else if (touchPos.distance(buttonCenter) < touchGamepadSize) {\n                // virtual face buttons\n                const button = touchPos.subtract(buttonCenter).direction();\n                touchGamepadButtons[button] = 1;\n            } else if (touchPos.distance(startCenter) < touchGamepadSize) // virtual start button in center\n            touchGamepadButtons[9] = 1;\n        }\n        // call default touch handler so normal touch events still work\n        handleTouchDefault(e);\n        // must return true so the document will get focus\n        return true;\n    }\n}\n// render the touch gamepad, called automatically by the engine\nfunction touchGamepadRender() {\n    if (!touchInputEnable || !isTouchDevice || headlessMode) return;\n    if (!touchGamepadEnable || !touchGamepadTimer.isSet()) return;\n    // fade off when not touching or paused\n    const alpha = percent(touchGamepadTimer.get(), 4, 3);\n    if (!alpha || paused) return;\n    // setup the canvas\n    const context = overlayContext;\n    context.save();\n    context.globalAlpha = alpha * touchGamepadAlpha;\n    context.strokeStyle = \"#fff\";\n    context.lineWidth = 3;\n    // draw left analog stick\n    context.fillStyle = touchGamepadStick.lengthSquared() > 0 ? \"#fff\" : \"#000\";\n    context.beginPath();\n    const leftCenter = vec2(touchGamepadSize, mainCanvasSize.y - touchGamepadSize);\n    if (touchGamepadAnalog) {\n        context.arc(leftCenter.x, leftCenter.y, touchGamepadSize / 2, 0, 9);\n        context.fill();\n        context.stroke();\n    } else {\n        for(let i = 10; i--;){\n            const angle = i * PI / 4;\n            context.arc(leftCenter.x, leftCenter.y, touchGamepadSize * .6, angle + PI / 8, angle + PI / 8);\n            i % 2 && context.arc(leftCenter.x, leftCenter.y, touchGamepadSize * .33, angle, angle);\n            i == 1 && context.fill();\n        }\n        context.stroke();\n    }\n    // draw right face buttons\n    const rightCenter = vec2(mainCanvasSize.x - touchGamepadSize, mainCanvasSize.y - touchGamepadSize);\n    for(let i = 4; i--;){\n        const pos = rightCenter.add(vec2().setDirection(i, touchGamepadSize / 2));\n        context.fillStyle = touchGamepadButtons[i] ? \"#fff\" : \"#000\";\n        context.beginPath();\n        context.arc(pos.x, pos.y, touchGamepadSize / 4, 0, 9);\n        context.fill();\n        context.stroke();\n    }\n    // set canvas back to normal\n    context.restore();\n}\n/** \r\n * LittleJS Audio System\r\n * - <a href=https://killedbyapixel.github.io/ZzFX/>ZzFX Sound Effects</a> - ZzFX Sound Effect Generator\r\n * - <a href=https://keithclark.github.io/ZzFXM/>ZzFXM Music</a> - ZzFXM Music System\r\n * - Caches sounds and music for fast playback\r\n * - Can attenuate and apply stereo panning to sounds\r\n * - Ability to play mp3, ogg, and wave files\r\n * - Speech synthesis functions\r\n * @namespace Audio\r\n */ /** Audio context used by the engine\r\n *  @type {AudioContext}\r\n *  @memberof Audio */ let audioContext;\n/** Master gain node for all audio to pass through\r\n *  @type {GainNode}\r\n *  @memberof Audio */ let audioGainNode;\nfunction audioInit() {\n    if (!soundEnable || headlessMode) return;\n    // create audio context\n    audioContext = new AudioContext;\n    // create and connect gain node\n    // (createGain is more widely spported then GainNode construtor)\n    audioGainNode = audioContext.createGain();\n    audioGainNode.connect(audioContext.destination);\n    setSoundVolume(soundVolume); // update gain volume\n}\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Sound Object - Stores a sound for later use and can be played positionally\r\n * \r\n * <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n * @example\r\n * // create a sound\r\n * const sound_example = new Sound([.5,.5]);\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */ class Sound {\n    /** Create a sound object and cache the zzfx samples for later use\r\n     *  @param {Array}  zzfxSound - Array of zzfx parameters, ex. [.5,.5]\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering\r\n     */ constructor(zzfxSound, range = soundDefaultRange, taper = soundDefaultTaper){\n        if (!soundEnable || headlessMode) return;\n        /** @property {Number} - World space max range of sound, will not play if camera is farther away */ this.range = range;\n        /** @property {Number} - At what percentage of range should it start tapering off */ this.taper = taper;\n        /** @property {Number} - How much to randomize frequency each time sound plays */ this.randomness = 0;\n        if (zzfxSound) {\n            // generate zzfx sound now for fast playback\n            const defaultRandomness = .05;\n            this.randomness = zzfxSound[1] || defaultRandomness;\n            this.sampleChannels = [\n                zzfxG(...zzfxSound)\n            ];\n            this.sampleRate = zzfxR;\n        }\n    }\n    /** Play the sound\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume] - How much to scale volume by (in addition to range fade)\r\n     *  @param {Number}  [pitch] - How much to scale pitch by (also adjusted by this.randomness)\r\n     *  @param {Number}  [randomnessScale] - How much to scale randomness\r\n     *  @param {Boolean} [loop] - Should the sound loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */ play(pos, volume = 1, pitch = 1, randomnessScale = 1, loop = false) {\n        if (!soundEnable || headlessMode) return;\n        if (!this.sampleChannels) return;\n        let pan;\n        if (pos) {\n            const range = this.range;\n            if (range) {\n                // apply range based fade\n                const lengthSquared = cameraPos.distanceSquared(pos);\n                if (lengthSquared > range * range) return; // out of range\n                // attenuate volume by distance\n                volume *= percent(lengthSquared ** .5, range, range * this.taper);\n            }\n            // get pan from screen space coords\n            pan = worldToScreen(pos).x * 2 / mainCanvas.width - 1;\n        }\n        // play the sound\n        const playbackRate = pitch + pitch * this.randomness * randomnessScale * rand(-1, 1);\n        this.gainNode = audioContext.createGain();\n        return this.source = playSamples(this.sampleChannels, volume, playbackRate, pan, loop, this.sampleRate, this.gainNode);\n    }\n    /** Set the sound volume\r\n     *  @param {Number}  [volume] - How much to scale volume by\r\n     */ setVolume(volume = 1) {\n        if (this.gainNode) this.gainNode.gain.value = volume;\n    }\n    /** Stop the last instance of this sound that was played */ stop() {\n        if (this.source) this.source.stop();\n        this.source = undefined;\n    }\n    /** Get source of most recent instance of this sound that was played\r\n     *  @return {AudioBufferSourceNode}\r\n     */ getSource() {\n        return this.source;\n    }\n    /** Play the sound as a note with a semitone offset\r\n     *  @param {Number}  semitoneOffset - How many semitones to offset pitch\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume=1] - How much to scale volume by (in addition to range fade)\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */ playNote(semitoneOffset, pos, volume) {\n        return this.play(pos, volume, 2 ** (semitoneOffset / 12), 0);\n    }\n    /** Get how long this sound is in seconds\r\n     *  @return {Number} - How long the sound is in seconds (undefined if loading)\r\n     */ getDuration() {\n        return this.sampleChannels && this.sampleChannels[0].length / this.sampleRate;\n    }\n    /** Check if sound is loading, for sounds fetched from a url\r\n     *  @return {Boolean} - True if sound is loading and not ready to play\r\n     */ isLoading() {\n        return !this.sampleChannels;\n    }\n}\n/** \r\n * Sound Wave Object - Stores a wave sound for later use and can be played positionally\r\n * - this can be used to play wave, mp3, and ogg files\r\n * @example\r\n * // create a sound\r\n * const sound_example = new SoundWave('sound.mp3');\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */ class SoundWave extends Sound {\n    /** Create a sound object and cache the wave file for later use\r\n     *  @param {String} filename - Filename of audio file to load\r\n     *  @param {Number} [randomness] - How much to randomize frequency each time sound plays\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering off\r\n     *  @param {Function} [onloadCallback] - callback function to call when sound is loaded\r\n     */ constructor(filename, randomness = 0, range, taper, onloadCallback){\n        super(undefined, range, taper);\n        if (!soundEnable || headlessMode) return;\n        this.randomness = randomness;\n        fetch(filename).then((response)=>response.arrayBuffer()).then((arrayBuffer)=>audioContext.decodeAudioData(arrayBuffer)).then((audioBuffer)=>{\n            this.sampleChannels = [];\n            for(let i = audioBuffer.numberOfChannels; i--;)this.sampleChannels[i] = Array.from(audioBuffer.getChannelData(i));\n            this.sampleRate = audioBuffer.sampleRate;\n        }).then(()=>onloadCallback && onloadCallback(this));\n    }\n}\n/** Play an mp3, ogg, or wav audio from a local file or url\r\n *  @param {String}  filename - Location of sound file to play\r\n *  @param {Number}  [volume] - How much to scale volume by\r\n *  @param {Boolean} [loop] - True if the music should loop\r\n *  @return {SoundWave} - The sound object for this file\r\n *  @memberof Audio */ function playAudioFile(filename, volume = 1, loop = false) {\n    if (!soundEnable || headlessMode) return;\n    return new SoundWave(filename, 0, 0, 0, (s)=>s.play(undefined, volume, 1, 1, loop));\n}\n/**\r\n * Music Object - Stores a zzfx music track for later use\r\n * \r\n * <a href=https://keithclark.github.io/ZzFXM/>Create music with the ZzFXM tracker.</a>\r\n * @example\r\n * // create some music\r\n * const music_example = new Music(\r\n * [\r\n *     [                         // instruments\r\n *       [,0,400]                // simple note\r\n *     ], \r\n *     [                         // patterns\r\n *         [                     // pattern 1\r\n *             [                 // channel 0\r\n *                 0, -1,        // instrument 0, left speaker\r\n *                 1, 0, 9, 1    // channel notes\r\n *             ], \r\n *             [                 // channel 1\r\n *                 0, 1,         // instrument 0, right speaker\r\n *                 0, 12, 17, -1 // channel notes\r\n *             ]\r\n *         ],\r\n *     ],\r\n *     [0, 0, 0, 0], // sequence, play pattern 0 four times\r\n *     90            // BPM\r\n * ]);\r\n * \r\n * // play the music\r\n * music_example.play();\r\n */ class Music extends Sound {\n    /** Create a music object and cache the zzfx music samples for later use\r\n     *  @param {[Array, Array, Array, Number]} zzfxMusic - Array of zzfx music parameters\r\n     */ constructor(zzfxMusic){\n        super(undefined);\n        if (!soundEnable || headlessMode) return;\n        this.randomness = 0;\n        this.sampleChannels = zzfxM(...zzfxMusic);\n        this.sampleRate = zzfxR;\n    }\n    /** Play the music\r\n     *  @param {Number}  [volume=1] - How much to scale volume by\r\n     *  @param {Boolean} [loop] - True if the music should loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */ playMusic(volume, loop = false) {\n        return super.play(undefined, volume, 1, 1, loop);\n    }\n}\n/** Speak text with passed in settings\r\n *  @param {String} text - The text to speak\r\n *  @param {String} [language] - The language/accent to use (examples: en, it, ru, ja, zh)\r\n *  @param {Number} [volume] - How much to scale volume by\r\n *  @param {Number} [rate] - How quickly to speak\r\n *  @param {Number} [pitch] - How much to change the pitch by\r\n *  @return {SpeechSynthesisUtterance} - The utterance that was spoken\r\n *  @memberof Audio */ function speak(text, language = \"\", volume = 1, rate = 1, pitch = 1) {\n    if (!soundEnable || headlessMode) return;\n    if (!speechSynthesis) return;\n    // common languages (not supported by all browsers)\n    // en - english,  it - italian, fr - french,  de - german, es - spanish\n    // ja - japanese, ru - russian, zh - chinese, hi - hindi,  ko - korean\n    // build utterance and speak\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.lang = language;\n    utterance.volume = 2 * volume * soundVolume;\n    utterance.rate = rate;\n    utterance.pitch = pitch;\n    speechSynthesis.speak(utterance);\n    return utterance;\n}\n/** Stop all queued speech\r\n *  @memberof Audio */ function speakStop() {\n    speechSynthesis && speechSynthesis.cancel();\n}\n/** Get frequency of a note on a musical scale\r\n *  @param {Number} semitoneOffset - How many semitones away from the root note\r\n *  @param {Number} [rootFrequency=220] - Frequency at semitone offset 0\r\n *  @return {Number} - The frequency of the note\r\n *  @memberof Audio */ function getNoteFrequency(semitoneOffset, rootFrequency = 220) {\n    return rootFrequency * 2 ** (semitoneOffset / 12);\n}\n///////////////////////////////////////////////////////////////////////////////\n// internal tracking if audio was suspended when last sound was played\n// allows first suspended sound to play when audio is resumed\nlet audioSuspended = false;\n/** Play cached audio samples with given settings\r\n *  @param {Array}    sampleChannels - Array of arrays of samples to play (for stereo playback)\r\n *  @param {Number}   [volume] - How much to scale volume by\r\n *  @param {Number}   [rate] - The playback rate to use\r\n *  @param {Number}   [pan] - How much to apply stereo panning\r\n *  @param {Boolean}  [loop] - True if the sound should loop when it reaches the end\r\n *  @param {Number}   [sampleRate=44100] - Sample rate for the sound\r\n *  @param {GainNode} [gainNode] - Optional gain node for volume control while playing\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */ function playSamples(sampleChannels, volume = 1, rate = 1, pan = 0, loop = false, sampleRate = zzfxR, gainNode) {\n    if (!soundEnable || headlessMode) return;\n    // prevent sounds from building up if they can't be played\n    const audioWasSuspended = audioSuspended;\n    if (audioSuspended = audioContext.state != \"running\") {\n        // fix stalled audio\n        audioContext.resume();\n        // prevent suspended sounds from building up\n        if (audioWasSuspended) return;\n    }\n    // create buffer and source\n    const buffer = audioContext.createBuffer(sampleChannels.length, sampleChannels[0].length, sampleRate), source = audioContext.createBufferSource();\n    // copy samples to buffer and setup source\n    sampleChannels.forEach((c, i)=>buffer.getChannelData(i).set(c));\n    source.buffer = buffer;\n    source.playbackRate.value = rate;\n    source.loop = loop;\n    // create and connect gain node\n    gainNode = gainNode || audioContext.createGain();\n    gainNode.gain.value = volume;\n    gainNode.connect(audioGainNode);\n    // connect source to stereo panner and gain\n    source.connect(new StereoPannerNode(audioContext, {\n        \"pan\": clamp(pan, -1, 1)\n    })).connect(gainNode);\n    // play and return sound\n    source.start();\n    return source;\n}\n///////////////////////////////////////////////////////////////////////////////\n// ZzFXMicro - Zuper Zmall Zound Zynth - v1.3.1 by Frank Force\n/** Generate and play a ZzFX sound\r\n *  \r\n *  <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n *  @param {Array} zzfxSound - Array of ZzFX parameters, ex. [.5,.5]\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */ function zzfx(...zzfxSound) {\n    return new Sound(zzfxSound).play();\n}\n/** Sample rate used for all ZzFX sounds\r\n *  @default 44100\r\n *  @memberof Audio */ const zzfxR = 44100;\n/** Generate samples for a ZzFX sound\r\n *  @param {Number}  [volume] - Volume scale (percent)\r\n *  @param {Number}  [randomness] - Unused in this fuction, handled by Sound class\r\n *  @param {Number}  [frequency] - Frequency of sound (Hz)\r\n *  @param {Number}  [attack] - Attack time, how fast sound starts (seconds)\r\n *  @param {Number}  [sustain] - Sustain time, how long sound holds (seconds)\r\n *  @param {Number}  [release] - Release time, how fast sound fades out (seconds)\r\n *  @param {Number}  [shape] - Shape of the sound wave\r\n *  @param {Number}  [shapeCurve] - Squarenes of wave (0=square, 1=normal, 2=pointy)\r\n *  @param {Number}  [slide] - How much to slide frequency (kHz/s)\r\n *  @param {Number}  [deltaSlide] - How much to change slide (kHz/s/s)\r\n *  @param {Number}  [pitchJump] - Frequency of pitch jump (Hz)\r\n *  @param {Number}  [pitchJumpTime] - Time of pitch jump (seconds)\r\n *  @param {Number}  [repeatTime] - Resets some parameters periodically (seconds)\r\n *  @param {Number}  [noise] - How much random noise to add (percent)\r\n *  @param {Number}  [modulation] - Frequency of modulation wave, negative flips phase (Hz)\r\n *  @param {Number}  [bitCrush] - Resamples at a lower frequency in (samples*100)\r\n *  @param {Number}  [delay] - Overlap sound with itself for reverb and flanger effects (seconds)\r\n *  @param {Number}  [sustainVolume] - Volume level for sustain (percent)\r\n *  @param {Number}  [decay] - Decay time, how long to reach sustain after attack (seconds)\r\n *  @param {Number}  [tremolo] - Trembling effect, rate controlled by repeat time (precent)\r\n *  @param {Number}  [filter] - Filter cutoff frequency, positive for HPF, negative for LPF (Hz)\r\n *  @return {Array} - Array of audio samples\r\n *  @memberof Audio\r\n */ function zzfxG(// parameters\nvolume = 1, randomness = 0, frequency = 220, attack = 0, sustain = 0, release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0, filter = 0) {\n    // LJS Note: ZZFX modded so randomness is handled by Sound class\n    // init parameters\n    let PI2 = PI * 2, sampleRate = zzfxR, startSlide = slide *= 500 * PI2 / sampleRate / sampleRate, startFrequency = frequency *= PI2 / sampleRate, b = [], t = 0, tm = 0, i = 0, j = 1, r = 0, c = 0, s = 0, f, length, // biquad LP/HP filter\n    quality = 2, w = PI2 * abs(filter) * 2 / sampleRate, cos = Math.cos(w), alpha = Math.sin(w) / 2 / quality, a0 = 1 + alpha, a1 = -2 * cos / a0, a2 = (1 - alpha) / a0, b0 = (1 + sign(filter) * cos) / 2 / a0, b1 = -(sign(filter) + cos) / a0, b2 = b0, x2 = 0, x1 = 0, y2 = 0, y1 = 0;\n    // scale by sample rate\n    attack = attack * sampleRate + 9; // minimum attack to prevent pop\n    decay *= sampleRate;\n    sustain *= sampleRate;\n    release *= sampleRate;\n    delay *= sampleRate;\n    deltaSlide *= 500 * PI2 / sampleRate ** 3;\n    modulation *= PI2 / sampleRate;\n    pitchJump *= PI2 / sampleRate;\n    pitchJumpTime *= sampleRate;\n    repeatTime = repeatTime * sampleRate | 0;\n    // generate waveform\n    for(length = attack + decay + sustain + release + delay | 0; i < length; b[i++] = s * volume){\n        if (!(++c % (bitCrush * 100 | 0))) {\n            s = shape ? shape > 1 ? shape > 2 ? shape > 3 ? Math.sin(t ** 3) : clamp(Math.tan(t), 1, -1) : 1 - (2 * t / PI2 % 2 + 2) % 2 : 1 - 4 * abs(Math.round(t / PI2) - t / PI2) : Math.sin(t); // 0 sin\n            s = (repeatTime ? 1 - tremolo + tremolo * Math.sin(PI2 * i / repeatTime) // tremolo\n             : 1) * sign(s) * abs(s) ** shapeCurve * // curve\n            (i < attack ? i / attack : i < attack + decay ? 1 - (i - attack) / decay * (1 - sustainVolume) : i < attack + decay + sustain ? sustainVolume : i < length - delay ? (length - i - delay) / release * // release falloff\n            sustainVolume : 0); // post release\n            s = delay ? s / 2 + (delay > i ? 0 : (i < length - delay ? 1 : (length - i) / delay) * // release delay \n            b[i - delay | 0] / 2 / volume) : s; // sample delay\n            if (filter) s = y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = s) - a2 * y2 - a1 * (y2 = y1);\n        }\n        f = (frequency += slide += deltaSlide) * // frequency\n        Math.cos(modulation * tm++); // modulation\n        t += f + f * noise * Math.sin(i ** 5); // noise\n        if (j && ++j > pitchJumpTime) {\n            frequency += pitchJump; // apply pitch jump\n            startFrequency += pitchJump; // also apply to start\n            j = 0; // stop pitch jump time\n        }\n        if (repeatTime && !(++r % repeatTime)) {\n            frequency = startFrequency; // reset frequency\n            slide = startSlide; // reset slide\n            j = j || 1; // reset pitch jump time\n        }\n    }\n    return b;\n}\n///////////////////////////////////////////////////////////////////////////////\n// ZzFX Music Renderer v2.0.3 by Keith Clark and Frank Force\n/** Generate samples for a ZzFM song with given parameters\r\n *  @param {Array} instruments - Array of ZzFX sound paramaters\r\n *  @param {Array} patterns - Array of pattern data\r\n *  @param {Array} sequence - Array of pattern indexes\r\n *  @param {Number} [BPM] - Playback speed of the song in BPM\r\n *  @return {Array} - Left and right channel sample data\r\n *  @memberof Audio */ function zzfxM(instruments, patterns, sequence, BPM = 125) {\n    let i, j, k;\n    let instrumentParameters;\n    let note;\n    let sample;\n    let patternChannel;\n    let notFirstBeat;\n    let stop;\n    let instrument;\n    let attenuation;\n    let outSampleOffset;\n    let isSequenceEnd;\n    let sampleOffset = 0;\n    let nextSampleOffset;\n    let sampleBuffer = [];\n    let leftChannelBuffer = [];\n    let rightChannelBuffer = [];\n    let channelIndex = 0;\n    let panning = 0;\n    let hasMore = 1;\n    let sampleCache = {};\n    let beatLength = zzfxR / BPM * 60 >> 2;\n    // for each channel in order until there are no more\n    for(; hasMore; channelIndex++){\n        // reset current values\n        sampleBuffer = [\n            hasMore = notFirstBeat = outSampleOffset = 0\n        ];\n        // for each pattern in sequence\n        sequence.forEach((patternIndex, sequenceIndex)=>{\n            // get pattern for current channel, use empty 1 note pattern if none found\n            patternChannel = patterns[patternIndex][channelIndex] || [\n                0,\n                0,\n                0\n            ];\n            // check if there are more channels\n            hasMore |= patterns[patternIndex][channelIndex] && 1;\n            // get next offset, use the length of first channel\n            nextSampleOffset = outSampleOffset + (patterns[patternIndex][0].length - 2 - (notFirstBeat ? 0 : 1)) * beatLength;\n            // for each beat in pattern, plus one extra if end of sequence\n            isSequenceEnd = sequenceIndex == sequence.length - 1;\n            for(i = 2, k = outSampleOffset; i < patternChannel.length + isSequenceEnd; notFirstBeat = ++i){\n                // <channel-note>\n                note = patternChannel[i];\n                // stop if end, different instrument or new note\n                stop = i == patternChannel.length + isSequenceEnd - 1 && isSequenceEnd || instrument != (patternChannel[0] || 0) || note | 0;\n                // fill buffer with samples for previous beat, most cpu intensive part\n                for(j = 0; j < beatLength && notFirstBeat; // fade off attenuation at end of beat if stopping note, prevents clicking\n                j++ > beatLength - 99 && stop && attenuation < 1 && (attenuation += 1 / 99)){\n                    // copy sample to stereo buffers with panning\n                    sample = (1 - attenuation) * sampleBuffer[sampleOffset++] / 2 || 0;\n                    leftChannelBuffer[k] = (leftChannelBuffer[k] || 0) - sample * panning + sample;\n                    rightChannelBuffer[k] = (rightChannelBuffer[k++] || 0) + sample * panning + sample;\n                }\n                // set up for next note\n                if (note) {\n                    // set attenuation\n                    attenuation = note % 1;\n                    panning = patternChannel[1] || 0;\n                    if (note |= 0) // get cached sample\n                    sampleBuffer = sampleCache[[\n                        instrument = patternChannel[sampleOffset = 0] || 0,\n                        note\n                    ]] = sampleCache[[\n                        instrument,\n                        note\n                    ]] || // add sample to cache\n                    (instrumentParameters = [\n                        ...instruments[instrument]\n                    ], instrumentParameters[2] *= 2 ** ((note - 12) / 12), // allow negative values to stop notes\n                    note > 0 ? zzfxG(...instrumentParameters) : []);\n                }\n            }\n            // update the sample offset\n            outSampleOffset = nextSampleOffset;\n        });\n    }\n    return [\n        leftChannelBuffer,\n        rightChannelBuffer\n    ];\n}\n/** \r\n * LittleJS Tile Layer System\r\n * - Caches arrays of tiles to off screen canvas for fast rendering\r\n * - Unlimited numbers of layers, allocates canvases as needed\r\n * - Interfaces with EngineObject for collision\r\n * - Collision layer is separate from visible layers\r\n * - It is recommended to have a visible layer that matches the collision\r\n * - Tile layers can be drawn to using their context with canvas2d\r\n * - Drawn directly to the main canvas without using WebGL\r\n * @namespace TileCollision\r\n */ /** The tile collision layer array, use setTileCollisionData and getTileCollisionData to access\r\n *  @type {Array} \r\n *  @memberof TileCollision */ let tileCollision = [];\n/** Size of the tile collision layer\r\n *  @type {Vector2} \r\n *  @memberof TileCollision */ let tileCollisionSize = vec2();\n/** Clear and initialize tile collision\r\n *  @param {Vector2} size\r\n *  @memberof TileCollision */ function initTileCollision(size) {\n    tileCollisionSize = size;\n    tileCollision = [];\n    for(let i = tileCollision.length = tileCollisionSize.area(); i--;)tileCollision[i] = 0;\n}\n/** Set tile collision data\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [data]\r\n *  @memberof TileCollision */ function setTileCollisionData(pos, data = 0) {\n    pos.arrayCheck(tileCollisionSize) && (tileCollision[(pos.y | 0) * tileCollisionSize.x + pos.x | 0] = data);\n}\n/** Get tile collision data\r\n *  @param {Vector2} pos\r\n *  @return {Number}\r\n *  @memberof TileCollision */ function getTileCollisionData(pos) {\n    return pos.arrayCheck(tileCollisionSize) ? tileCollision[(pos.y | 0) * tileCollisionSize.x + pos.x | 0] : 0;\n}\n/** Check if collision with another object should occur\r\n *  @param {Vector2}      pos\r\n *  @param {Vector2}      [size=(0,0)]\r\n *  @param {EngineObject} [object]\r\n *  @return {Boolean}\r\n *  @memberof TileCollision */ function tileCollisionTest(pos, size = vec2(), object) {\n    const minX = max(pos.x - size.x / 2 | 0, 0);\n    const minY = max(pos.y - size.y / 2 | 0, 0);\n    const maxX = min(pos.x + size.x / 2, tileCollisionSize.x);\n    const maxY = min(pos.y + size.y / 2, tileCollisionSize.y);\n    for(let y = minY; y < maxY; ++y)for(let x = minX; x < maxX; ++x){\n        const tileData = tileCollision[y * tileCollisionSize.x + x];\n        if (tileData && (!object || object.collideWithTile(tileData, vec2(x, y)))) return true;\n    }\n}\n/** Return the center of first tile hit (does not return the exact intersection)\r\n *  @param {Vector2}      posStart\r\n *  @param {Vector2}      posEnd\r\n *  @param {EngineObject} [object]\r\n *  @return {Vector2}\r\n *  @memberof TileCollision */ function tileCollisionRaycast(posStart, posEnd, object) {\n    // test if a ray collides with tiles from start to end\n    // todo: a way to get the exact hit point, it must still be inside the hit tile\n    const delta = posEnd.subtract(posStart);\n    const totalLength = delta.length();\n    const normalizedDelta = delta.normalize();\n    const unit = vec2(abs(1 / normalizedDelta.x), abs(1 / normalizedDelta.y));\n    const flooredPosStart = posStart.floor();\n    // setup iteration variables\n    let pos = flooredPosStart;\n    let xi = unit.x * (delta.x < 0 ? posStart.x - pos.x : pos.x - posStart.x + 1);\n    let yi = unit.y * (delta.y < 0 ? posStart.y - pos.y : pos.y - posStart.y + 1);\n    while(true){\n        // check for tile collision\n        const tileData = getTileCollisionData(pos);\n        if (tileData && (!object || object.collideWithTile(tileData, pos))) {\n            debugRaycast && debugLine(posStart, posEnd, \"#f00\", .02);\n            debugRaycast && debugPoint(pos.add(vec2(.5)), \"#ff0\");\n            return pos.add(vec2(.5));\n        }\n        // check if past the end\n        if (xi > totalLength && yi > totalLength) break;\n        // get coordinates of the next tile to check\n        if (xi > yi) pos.y += sign(delta.y), yi += unit.y;\n        else pos.x += sign(delta.x), xi += unit.x;\n    }\n    debugRaycast && debugLine(posStart, posEnd, \"#00f\", .02);\n}\n///////////////////////////////////////////////////////////////////////////////\n// Tile Layer Rendering System\n/**\r\n * Tile layer data object stores info about how to render a tile\r\n * @example\r\n * // create tile layer data with tile index 0 and random orientation and color\r\n * const tileIndex = 0;\r\n * const direction = randInt(4)\r\n * const mirror = randInt(2);\r\n * const color = randColor();\r\n * const data = new TileLayerData(tileIndex, direction, mirror, color);\r\n */ class TileLayerData {\n    /** Create a tile layer data object, one for each tile in a TileLayer\r\n     *  @param {Number}  [tile]      - The tile to use, untextured if undefined\r\n     *  @param {Number}  [direction] - Integer direction of tile, in 90 degree increments\r\n     *  @param {Boolean} [mirror]    - If the tile should be mirrored along the x axis\r\n     *  @param {Color}   [color]     - Color of the tile */ constructor(tile, direction = 0, mirror = false, color = new Color){\n        /** @property {Number}  - The tile to use, untextured if undefined */ this.tile = tile;\n        /** @property {Number}  - Integer direction of tile, in 90 degree increments */ this.direction = direction;\n        /** @property {Boolean} - If the tile should be mirrored along the x axis */ this.mirror = mirror;\n        /** @property {Color}   - Color of the tile */ this.color = color;\n    }\n    /** Set this tile to clear, it will not be rendered */ clear() {\n        this.tile = this.direction = 0;\n        this.mirror = false;\n        this.color = new Color;\n    }\n}\n/**\r\n * Tile Layer - cached rendering system for tile layers\r\n * - Each Tile layer is rendered to an off screen canvas\r\n * - To allow dynamic modifications, layers are rendered using canvas 2d\r\n * - Some devices like mobile phones are limited to 4k texture resolution\r\n * - So with 16x16 tiles this limits layers to 256x256 on mobile devices\r\n * @extends EngineObject\r\n * @example\r\n * // create tile collision and visible tile layer\r\n * initTileCollision(vec2(200,100));\r\n * const tileLayer = new TileLayer();\r\n */ class TileLayer extends EngineObject {\n    /** Create a tile layer object\r\n    *  @param {Vector2}  [position=(0,0)]     - World space position\r\n    *  @param {Vector2}  [size=tileCollisionSize] - World space size\r\n    *  @param {TileInfo} [tileInfo]    - Tile info for layer\r\n    *  @param {Vector2}  [scale=(1,1)] - How much to scale this layer when rendered\r\n    *  @param {Number}   [renderOrder] - Objects are sorted by renderOrder\r\n    */ constructor(position, size = tileCollisionSize, tileInfo = tile(), scale = vec2(1), renderOrder = 0){\n        super(position, size, tileInfo, 0, undefined, renderOrder);\n        /** @property {HTMLCanvasElement} - The canvas used by this tile layer */ this.canvas = document.createElement(\"canvas\");\n        /** @property {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} - The 2D canvas context used by this tile layer */ this.context = this.canvas.getContext(\"2d\");\n        /** @property {Vector2} - How much to scale this layer when rendered */ this.scale = scale;\n        /** @property {Boolean} - If true this layer will render to overlay canvas and appear above all objects */ this.isOverlay = false;\n        // init tile data\n        this.data = [];\n        for(let j = this.size.area(); j--;)this.data.push(new TileLayerData);\n        if (headlessMode) {\n            // disable rendering\n            this.redraw = ()=>{};\n            this.render = ()=>{};\n            this.redrawStart = ()=>{};\n            this.redrawEnd = ()=>{};\n            this.drawTileData = ()=>{};\n            this.drawCanvas2D = ()=>{};\n        }\n    }\n    /** Set data at a given position in the array \r\n     *  @param {Vector2}       layerPos - Local position in array\r\n     *  @param {TileLayerData} data     - Data to set\r\n     *  @param {Boolean}       [redraw] - Force the tile to redraw if true */ setData(layerPos, data, redraw = false) {\n        if (layerPos.arrayCheck(this.size)) {\n            this.data[(layerPos.y | 0) * this.size.x + layerPos.x | 0] = data;\n            redraw && this.drawTileData(layerPos);\n        }\n    }\n    /** Get data at a given position in the array \r\n     *  @param {Vector2} layerPos - Local position in array\r\n     *  @return {TileLayerData} */ getData(layerPos) {\n        return layerPos.arrayCheck(this.size) && this.data[(layerPos.y | 0) * this.size.x + layerPos.x | 0];\n    }\n    // Tile layers are not updated\n    update() {}\n    // Render the tile layer, called automatically by the engine\n    render() {\n        ASSERT(mainContext != this.context, \"must call redrawEnd() after drawing tiles\");\n        // flush and copy gl canvas because tile canvas does not use webgl\n        !glOverlay && !this.isOverlay && glCopyToContext(mainContext);\n        // draw the entire cached level onto the canvas\n        const pos = worldToScreen(this.pos.add(vec2(0, this.size.y * this.scale.y)));\n        (this.isOverlay ? overlayContext : mainContext).drawImage(this.canvas, pos.x, pos.y, cameraScale * this.size.x * this.scale.x, cameraScale * this.size.y * this.scale.y);\n    }\n    /** Draw all the tile data to an offscreen canvas \r\n     *  - This may be slow in some browsers but only needs to be done once */ redraw() {\n        this.redrawStart(true);\n        for(let x = this.size.x; x--;)for(let y = this.size.y; y--;)this.drawTileData(vec2(x, y), false);\n        this.redrawEnd();\n    }\n    /** Call to start the redraw process\r\n     *  - This can be used to manually update small parts of the level\r\n     *  @param {Boolean} [clear] - Should it clear the canvas before drawing */ redrawStart(clear = false) {\n        // save current render settings\n        /** @type {[HTMLCanvasElement, CanvasRenderingContext2D, Vector2, Vector2, number]} */ this.savedRenderSettings = [\n            mainCanvas,\n            mainContext,\n            mainCanvasSize,\n            cameraPos,\n            cameraScale\n        ];\n        // use webgl rendering system to render the tiles if enabled\n        // this works by temporally taking control of the rendering system\n        mainCanvas = this.canvas;\n        mainContext = this.context;\n        mainCanvasSize = this.size.multiply(this.tileInfo.size);\n        cameraPos = this.size.scale(.5);\n        cameraScale = this.tileInfo.size.x;\n        if (clear) {\n            // clear and set size\n            mainCanvas.width = mainCanvasSize.x;\n            mainCanvas.height = mainCanvasSize.y;\n        }\n        // disable smoothing for pixel art\n        this.context.imageSmoothingEnabled = !canvasPixelated;\n        // setup gl rendering if enabled\n        glPreRender();\n    }\n    /** Call to end the redraw process */ redrawEnd() {\n        ASSERT(mainContext == this.context, \"must call redrawStart() before drawing tiles\");\n        glCopyToContext(mainContext, true);\n        //debugSaveCanvas(this.canvas);\n        // set stuff back to normal\n        [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale] = this.savedRenderSettings;\n    }\n    /** Draw the tile at a given position in the tile grid\r\n     *  This can be used to clear out tiles when they are destroyed\r\n     *  Tiles can also be redrawn if isinde a redrawStart/End block\r\n     *  @param {Vector2} layerPos \r\n     *  @param {Boolean} [clear] - should the old tile be cleared out\r\n     */ drawTileData(layerPos, clear = true) {\n        // clear out where the tile was, for full opaque tiles this can be skipped\n        const s = this.tileInfo.size;\n        if (clear) {\n            const pos = layerPos.multiply(s);\n            this.context.clearRect(pos.x, this.canvas.height - pos.y, s.x, -s.y);\n        }\n        // draw the tile if not undefined\n        const d = this.getData(layerPos);\n        if (d.tile != undefined) {\n            const pos = this.pos.add(layerPos).add(vec2(.5));\n            ASSERT(mainContext == this.context, \"must call redrawStart() before drawing tiles\");\n            const tileInfo = tile(d.tile, s, this.tileInfo.textureIndex);\n            drawTile(pos, vec2(1), tileInfo, d.color, d.direction * PI / 2, d.mirror);\n        }\n    }\n    /** Draw directly to the 2D canvas in world space (bipass webgl)\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  size\r\n     *  @param {Number}   angle\r\n     *  @param {Boolean}  mirror\r\n     *  @param {Function} drawFunction */ drawCanvas2D(pos, size, angle, mirror, drawFunction) {\n        const context = this.context;\n        context.save();\n        pos = pos.subtract(this.pos).multiply(this.tileInfo.size);\n        size = size.multiply(this.tileInfo.size);\n        context.translate(pos.x, this.canvas.height - pos.y);\n        context.rotate(angle);\n        context.scale(mirror ? -size.x : size.x, size.y);\n        drawFunction(context);\n        context.restore();\n    }\n    /** Draw a tile directly onto the layer canvas in world space\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  [size=(1,1)]\r\n     *  @param {TileInfo} [tileInfo]\r\n     *  @param {Color}    [color=(1,1,1,1)]\r\n     *  @param {Number}   [angle=0]\r\n     *  @param {Boolean}  [mirror=0] */ drawTile(pos, size = vec2(1), tileInfo, color = new Color, angle, mirror) {\n        this.drawCanvas2D(pos, size, angle, mirror, (context)=>{\n            const textureInfo = tileInfo && tileInfo.getTextureInfo();\n            if (textureInfo) {\n                context.globalAlpha = color.a; // only alpha is supported\n                context.drawImage(textureInfo.image, tileInfo.pos.x, tileInfo.pos.y, tileInfo.size.x, tileInfo.size.y, -0.5, -0.5, 1, 1);\n                context.globalAlpha = 1;\n            } else {\n                // untextured\n                context.fillStyle = color;\n                context.fillRect(-0.5, -0.5, 1, 1);\n            }\n        });\n    }\n    /** Draw a rectangle directly onto the layer canvas in world space\r\n     *  @param {Vector2} pos\r\n     *  @param {Vector2} [size=(1,1)]\r\n     *  @param {Color}   [color=(1,1,1,1)]\r\n     *  @param {Number}  [angle=0] */ drawRect(pos, size, color, angle) {\n        this.drawTile(pos, size, undefined, color, angle);\n    }\n}\n/** \r\n * LittleJS Particle System\r\n */ /**\r\n * Particle Emitter - Spawns particles with the given settings\r\n * @extends EngineObject\r\n * @example\r\n * // create a particle emitter\r\n * let pos = vec2(2,3);\r\n * let particleEmitter = new ParticleEmitter\r\n * (\r\n *     pos, 0, 1, 0, 500, PI,      // pos, angle, emitSize, emitTime, emitRate, emiteCone\r\n *     tile(0, 16),                // tileInfo\r\n *     rgb(1,1,1),   rgb(0,0,0),   // colorStartA, colorStartB\r\n *     rgb(1,1,1,0), rgb(0,0,0,0), // colorEndA, colorEndB\r\n *     2, .2, .2, .1, .05,  // particleTime, sizeStart, sizeEnd, particleSpeed, particleAngleSpeed\r\n *     .99, 1, 1, PI, .05,  // damping, angleDamping, gravityScale, particleCone, fadeRate, \r\n *     .5, 1                // randomness, collide, additive, randomColorLinear, renderOrder\r\n * );\r\n */ class ParticleEmitter extends EngineObject {\n    /** Create a particle system with the given settings\r\n     *  @param {Vector2} position - World space position of the emitter\r\n     *  @param {Number} [angle] - Angle to emit the particles\r\n     *  @param {Number|Vector2}  [emitSize] - World space size of the emitter (float for circle diameter, vec2 for rect)\r\n     *  @param {Number} [emitTime] - How long to stay alive (0 is forever)\r\n     *  @param {Number} [emitRate] - How many particles per second to spawn, does not emit if 0\r\n     *  @param {Number} [emitConeAngle=PI] - Local angle to apply velocity to particles from emitter\r\n     *  @param {TileInfo} [tileInfo] - Tile info to render particles (undefined is untextured)\r\n     *  @param {Color} [colorStartA=(1,1,1,1)] - Color at start of life 1, randomized between start colors\r\n     *  @param {Color} [colorStartB=(1,1,1,1)] - Color at start of life 2, randomized between start colors\r\n     *  @param {Color} [colorEndA=(1,1,1,0)] - Color at end of life 1, randomized between end colors\r\n     *  @param {Color} [colorEndB=(1,1,1,0)] - Color at end of life 2, randomized between end colors\r\n     *  @param {Number} [particleTime]      - How long particles live\r\n     *  @param {Number} [sizeStart]         - How big are particles at start\r\n     *  @param {Number} [sizeEnd]           - How big are particles at end\r\n     *  @param {Number} [speed]             - How fast are particles when spawned\r\n     *  @param {Number} [angleSpeed]        - How fast are particles rotating\r\n     *  @param {Number} [damping]           - How much to dampen particle speed\r\n     *  @param {Number} [angleDamping]      - How much to dampen particle angular speed\r\n     *  @param {Number} [gravityScale]      - How much gravity effect particles\r\n     *  @param {Number} [particleConeAngle] - Cone for start particle angle\r\n     *  @param {Number} [fadeRate]          - How quick to fade particles at start/end in percent of life\r\n     *  @param {Number} [randomness]    - Apply extra randomness percent\r\n     *  @param {Boolean} [collideTiles] - Do particles collide against tiles\r\n     *  @param {Boolean} [additive]     - Should particles use addtive blend\r\n     *  @param {Boolean} [randomColorLinear] - Should color be randomized linearly or across each component\r\n     *  @param {Number} [renderOrder] - Render order for particles (additive is above other stuff by default)\r\n     *  @param {Boolean}  [localSpace] - Should it be in local space of emitter (world space is default)\r\n     */ constructor(position, angle, emitSize = 0, emitTime = 0, emitRate = 100, emitConeAngle = PI, tileInfo, colorStartA = new Color, colorStartB = new Color, colorEndA = new Color(1, 1, 1, 0), colorEndB = new Color(1, 1, 1, 0), particleTime = .5, sizeStart = .1, sizeEnd = 1, speed = .1, angleSpeed = .05, damping = 1, angleDamping = 1, gravityScale = 0, particleConeAngle = PI, fadeRate = .1, randomness = .2, collideTiles = false, additive = false, randomColorLinear = true, renderOrder = additive ? 1e9 : 0, localSpace = false){\n        super(position, vec2(), tileInfo, angle, undefined, renderOrder);\n        // emitter settings\n        /** @property {Number|Vector2} - World space size of the emitter (float for circle diameter, vec2 for rect) */ this.emitSize = emitSize;\n        /** @property {Number} - How long to stay alive (0 is forever) */ this.emitTime = emitTime;\n        /** @property {Number} - How many particles per second to spawn, does not emit if 0 */ this.emitRate = emitRate;\n        /** @property {Number} - Local angle to apply velocity to particles from emitter */ this.emitConeAngle = emitConeAngle;\n        // color settings\n        /** @property {Color} - Color at start of life 1, randomized between start colors */ this.colorStartA = colorStartA;\n        /** @property {Color} - Color at start of life 2, randomized between start colors */ this.colorStartB = colorStartB;\n        /** @property {Color} - Color at end of life 1, randomized between end colors */ this.colorEndA = colorEndA;\n        /** @property {Color} - Color at end of life 2, randomized between end colors */ this.colorEndB = colorEndB;\n        /** @property {Boolean} - Should color be randomized linearly or across each component */ this.randomColorLinear = randomColorLinear;\n        // particle settings\n        /** @property {Number} - How long particles live */ this.particleTime = particleTime;\n        /** @property {Number} - How big are particles at start */ this.sizeStart = sizeStart;\n        /** @property {Number} - How big are particles at end */ this.sizeEnd = sizeEnd;\n        /** @property {Number} - How fast are particles when spawned */ this.speed = speed;\n        /** @property {Number} - How fast are particles rotating */ this.angleSpeed = angleSpeed;\n        /** @property {Number} - How much to dampen particle speed */ this.damping = damping;\n        /** @property {Number} - How much to dampen particle angular speed */ this.angleDamping = angleDamping;\n        /** @property {Number} - How much does gravity effect particles */ this.gravityScale = gravityScale;\n        /** @property {Number} - Cone for start particle angle */ this.particleConeAngle = particleConeAngle;\n        /** @property {Number} - How quick to fade in particles at start/end in percent of life */ this.fadeRate = fadeRate;\n        /** @property {Number} - Apply extra randomness percent */ this.randomness = randomness;\n        /** @property {Boolean} - Do particles collide against tiles */ this.collideTiles = collideTiles;\n        /** @property {Boolean} - Should particles use addtive blend */ this.additive = additive;\n        /** @property {Boolean} - Should it be in local space of emitter */ this.localSpace = localSpace;\n        /** @property {Number} - If non zero the partile is drawn as a trail, stretched in the drection of velocity */ this.trailScale = 0;\n        /** @property {Function}   - Callback when particle is destroyed */ this.particleDestroyCallback = undefined;\n        /** @property {Function}   - Callback when particle is created */ this.particleCreateCallback = undefined;\n        /** @property {Number} - Track particle emit time */ this.emitTimeBuffer = 0;\n    }\n    /** Update the emitter to spawn particles, called automatically by engine once each frame */ update() {\n        // only do default update to apply parent transforms\n        this.parent && super.update();\n        // update emitter\n        if (!this.emitTime || this.getAliveTime() <= this.emitTime) // emit particles\n        {\n            if (this.emitRate * particleEmitRateScale) {\n                const rate = 1 / this.emitRate / particleEmitRateScale;\n                for(this.emitTimeBuffer += timeDelta; this.emitTimeBuffer > 0; this.emitTimeBuffer -= rate)this.emitParticle();\n            }\n        } else this.destroy();\n        debugParticles && debugRect(this.pos, vec2(this.emitSize), \"#0f0\", 0, this.angle);\n    }\n    /** Spawn one particle\r\n     *  @return {Particle} */ emitParticle() {\n        // spawn a particle\n        let pos = typeof this.emitSize === \"number\" ? randInCircle(this.emitSize / 2) // circle emitter\n         : vec2(rand(-0.5, .5), rand(-0.5, .5)) // box emitter\n        .multiply(this.emitSize).rotate(this.angle);\n        let angle = rand(this.particleConeAngle, -this.particleConeAngle);\n        if (!this.localSpace) {\n            pos = this.pos.add(pos);\n            angle += this.angle;\n        }\n        // randomness scales each paremeter by a percentage\n        const randomness = this.randomness;\n        const randomizeScale = (v)=>v + v * rand(randomness, -randomness);\n        // randomize particle settings\n        const particleTime = randomizeScale(this.particleTime);\n        const sizeStart = randomizeScale(this.sizeStart);\n        const sizeEnd = randomizeScale(this.sizeEnd);\n        const speed = randomizeScale(this.speed);\n        const angleSpeed = randomizeScale(this.angleSpeed) * randSign();\n        const coneAngle = rand(this.emitConeAngle, -this.emitConeAngle);\n        const colorStart = randColor(this.colorStartA, this.colorStartB, this.randomColorLinear);\n        const colorEnd = randColor(this.colorEndA, this.colorEndB, this.randomColorLinear);\n        const velocityAngle = this.localSpace ? coneAngle : this.angle + coneAngle;\n        // build particle\n        const particle = new Particle(pos, this.tileInfo, angle, colorStart, colorEnd, particleTime, sizeStart, sizeEnd, this.fadeRate, this.additive, this.trailScale, this.localSpace && this, this.particleDestroyCallback);\n        particle.velocity = vec2().setAngle(velocityAngle, speed);\n        particle.angleVelocity = angleSpeed;\n        particle.fadeRate = this.fadeRate;\n        particle.damping = this.damping;\n        particle.angleDamping = this.angleDamping;\n        particle.elasticity = this.elasticity;\n        particle.friction = this.friction;\n        particle.gravityScale = this.gravityScale;\n        particle.collideTiles = this.collideTiles;\n        particle.renderOrder = this.renderOrder;\n        particle.mirror = !!randInt(2);\n        // call particle create callaback\n        this.particleCreateCallback && this.particleCreateCallback(particle);\n        // return the newly created particle\n        return particle;\n    }\n    // Particle emitters are not rendered, only the particles are\n    render() {}\n}\n///////////////////////////////////////////////////////////////////////////////\n/**\r\n * Particle Object - Created automatically by Particle Emitters\r\n * @extends EngineObject\r\n */ class Particle extends EngineObject {\n    /**\r\n     * Create a particle with the passed in settings\r\n     * Typically this is created automatically by a ParticleEmitter\r\n     * @param {Vector2}  position   - World space position of the particle\r\n     * @param {TileInfo} tileInfo   - Tile info to render particles\r\n     * @param {Number}   angle      - Angle to rotate the particle\r\n     * @param {Color}    colorStart - Color at start of life\r\n     * @param {Color}    colorEnd   - Color at end of life\r\n     * @param {Number}   lifeTime   - How long to live for\r\n     * @param {Number}   sizeStart  - Size at start of life\r\n     * @param {Number}   sizeEnd    - Size at end of life\r\n     * @param {Number}   fadeRate   - How quick to fade in/out\r\n     * @param {Boolean}  additive   - Does it use additive blend mode\r\n     * @param {Number}   trailScale - If a trail, how long to make it\r\n     * @param {ParticleEmitter} [localSpaceEmitter] - Parent emitter if local space\r\n     * @param {Function} [destroyCallback] - Callback when particle dies\r\n     */ constructor(position, tileInfo, angle, colorStart, colorEnd, lifeTime, sizeStart, sizeEnd, fadeRate, additive, trailScale, localSpaceEmitter, destroyCallback){\n        super(position, vec2(), tileInfo, angle);\n        /** @property {Color} - Color at start of life */ this.colorStart = colorStart;\n        /** @property {Color} - Calculated change in color */ this.colorEndDelta = colorEnd.subtract(colorStart);\n        /** @property {Number} - How long to live for */ this.lifeTime = lifeTime;\n        /** @property {Number} - Size at start of life */ this.sizeStart = sizeStart;\n        /** @property {Number} - Calculated change in size */ this.sizeEndDelta = sizeEnd - sizeStart;\n        /** @property {Number} - How quick to fade in/out */ this.fadeRate = fadeRate;\n        /** @property {Boolean} - Is it additive */ this.additive = additive;\n        /** @property {Number} - If a trail, how long to make it */ this.trailScale = trailScale;\n        /** @property {ParticleEmitter} - Parent emitter if local space */ this.localSpaceEmitter = localSpaceEmitter;\n        /** @property {Function} - Called when particle dies */ this.destroyCallback = destroyCallback;\n        // particles use circular clamped speed\n        this.clampSpeedLinear = false;\n    }\n    /** Render the particle, automatically called each frame, sorted by renderOrder */ render() {\n        // modulate size and color\n        const p = min((time - this.spawnTime) / this.lifeTime, 1);\n        const radius = this.sizeStart + p * this.sizeEndDelta;\n        const size = vec2(radius);\n        const fadeRate = this.fadeRate / 2;\n        const color = new Color(this.colorStart.r + p * this.colorEndDelta.r, this.colorStart.g + p * this.colorEndDelta.g, this.colorStart.b + p * this.colorEndDelta.b, (this.colorStart.a + p * this.colorEndDelta.a) * (p < fadeRate ? p / fadeRate : p > 1 - fadeRate ? (1 - p) / fadeRate : 1)); // fade alpha\n        // draw the particle\n        this.additive && setBlendMode(true);\n        let pos = this.pos, angle = this.angle;\n        if (this.localSpaceEmitter) {\n            // in local space of emitter\n            pos = this.localSpaceEmitter.pos.add(pos.rotate(-this.localSpaceEmitter.angle));\n            angle += this.localSpaceEmitter.angle;\n        }\n        if (this.trailScale) {\n            // trail style particles\n            let velocity = this.velocity;\n            if (this.localSpaceEmitter) velocity = velocity.rotate(-this.localSpaceEmitter.angle);\n            const speed = velocity.length();\n            if (speed) {\n                const direction = velocity.scale(1 / speed);\n                const trailLength = speed * this.trailScale;\n                size.y = max(size.x, trailLength);\n                angle = direction.angle();\n                drawTile(pos.add(direction.multiply(vec2(0, -trailLength / 2))), size, this.tileInfo, color, angle, this.mirror);\n            }\n        } else drawTile(pos, size, this.tileInfo, color, angle, this.mirror);\n        this.additive && setBlendMode();\n        debugParticles && debugRect(pos, size, \"#f005\", 0, angle);\n        if (p == 1) {\n            // destroy particle when it's time runs out\n            this.color = color;\n            this.size = size;\n            this.destroyCallback && this.destroyCallback(this);\n            this.destroyed = 1;\n        }\n    }\n}\n/** \r\n * LittleJS Medal System\r\n * - Tracks and displays medals\r\n * - Saves medals to local storage\r\n * - Newgrounds integration\r\n * @namespace Medals\r\n */ /** List of all medals\r\n *  @type {Object}\r\n *  @memberof Medals */ const medals = {};\n// Engine internal variables not exposed to documentation\nlet medalsDisplayQueue = [], medalsSaveName, medalsDisplayTimeLast;\n///////////////////////////////////////////////////////////////////////////////\n/** Initialize medals with a save name used for storage\r\n *  - Call this after creating all medals\r\n *  - Checks if medals are unlocked\r\n *  @param {String} saveName\r\n *  @memberof Medals */ function medalsInit(saveName) {\n    // check if medals are unlocked\n    medalsSaveName = saveName;\n    if (!debugMedals) medalsForEach((medal)=>medal.unlocked = localStorage[medal.storageKey()] | 0);\n    // engine automatically renders medals\n    engineAddPlugin(undefined, medalsRender);\n    function medalsRender() {\n        if (!medalsDisplayQueue.length) return;\n        // update first medal in queue\n        const medal = medalsDisplayQueue[0];\n        const time = timeReal - medalsDisplayTimeLast;\n        if (!medalsDisplayTimeLast) medalsDisplayTimeLast = timeReal;\n        else if (time > medalDisplayTime) {\n            medalsDisplayTimeLast = 0;\n            medalsDisplayQueue.shift();\n        } else {\n            // slide on/off medals\n            const slideOffTime = medalDisplayTime - medalDisplaySlideTime;\n            const hidePercent = time < medalDisplaySlideTime ? 1 - time / medalDisplaySlideTime : time > slideOffTime ? (time - slideOffTime) / medalDisplaySlideTime : 0;\n            medal.render(hidePercent);\n        }\n    }\n}\n/** Calls a function for each medal\r\n *  @param {Function} callback\r\n *  @memberof Medals */ function medalsForEach(callback) {\n    Object.values(medals).forEach((medal)=>callback(medal));\n}\n///////////////////////////////////////////////////////////////////////////////\n/** \r\n * Medal - Tracks an unlockable medal \r\n * @example\r\n * // create a medal\r\n * const medal_example = new Medal(0, 'Example Medal', 'More info about the medal goes here.', '');\r\n * \r\n * // initialize medals\r\n * medalsInit('Example Game');\r\n * \r\n * // unlock the medal\r\n * medal_example.unlock();\r\n */ class Medal {\n    /** Create a medal object and adds it to the list of medals\r\n     *  @param {Number} id            - The unique identifier of the medal\r\n     *  @param {String} name          - Name of the medal\r\n     *  @param {String} [description] - Description of the medal\r\n     *  @param {String} [icon]        - Icon for the medal\r\n     *  @param {String} [src]         - Image location for the medal\r\n     */ constructor(id, name, description = \"\", icon = \"\\uD83C\\uDFC6\", src){\n        ASSERT(id >= 0 && !medals[id]);\n        // save attributes and add to list of medals\n        medals[this.id = id] = this;\n        this.name = name;\n        this.description = description;\n        this.icon = icon;\n        if (src) (this.image = new Image).src = src;\n    }\n    /** Unlocks a medal if not already unlocked */ unlock() {\n        if (medalsPreventUnlock || this.unlocked) return;\n        // save the medal\n        ASSERT(medalsSaveName, \"save name must be set\");\n        localStorage[this.storageKey()] = this.unlocked = 1;\n        medalsDisplayQueue.push(this);\n    }\n    /** Render a medal\r\n     *  @param {Number} [hidePercent] - How much to slide the medal off screen\r\n     */ render(hidePercent = 0) {\n        const context = overlayContext;\n        const width = min(medalDisplaySize.x, mainCanvas.width);\n        const x = overlayCanvas.width - width;\n        const y = -medalDisplaySize.y * hidePercent;\n        // draw containing rect and clip to that region\n        context.save();\n        context.beginPath();\n        context.fillStyle = new Color(.9, .9, .9).toString();\n        context.strokeStyle = new Color(0, 0, 0).toString();\n        context.lineWidth = 3;\n        context.rect(x, y, width, medalDisplaySize.y);\n        context.fill();\n        context.stroke();\n        context.clip();\n        // draw the icon and text\n        this.renderIcon(vec2(x + 15 + medalDisplayIconSize / 2, y + medalDisplaySize.y / 2));\n        const pos = vec2(x + medalDisplayIconSize + 30, y + 28);\n        drawTextScreen(this.name, pos, 38, new Color(0, 0, 0), 0, undefined, \"left\");\n        pos.y += 32;\n        drawTextScreen(this.description, pos, 24, new Color(0, 0, 0), 0, undefined, \"left\");\n        context.restore();\n    }\n    /** Render the icon for a medal\r\n     *  @param {Vector2} pos - Screen space position\r\n     *  @param {Number} [size=medalDisplayIconSize] - Screen space size\r\n     */ renderIcon(pos, size = medalDisplayIconSize) {\n        // draw the image or icon\n        if (this.image) overlayContext.drawImage(this.image, pos.x - size / 2, pos.y - size / 2, size, size);\n        else drawTextScreen(this.icon, pos, size * .7, new Color(0, 0, 0));\n    }\n    // Get local storage key used by the medal\n    storageKey() {\n        return medalsSaveName + \"_\" + this.id;\n    }\n}\n/**\r\n * LittleJS WebGL Interface\r\n * - All webgl used by the engine is wrapped up here\r\n * - For normal stuff you won't need to see or call anything in this file\r\n * - For advanced stuff there are helper functions to create shaders, textures, etc\r\n * - Can be disabled with glEnable to revert to 2D canvas rendering\r\n * - Batches sprite rendering on GPU for incredibly fast performance\r\n * - Sprite transform math is done in the shader where possible\r\n * - Supports shadertoy style post processing shaders\r\n * @namespace WebGL\r\n */ /** The WebGL canvas which appears above the main canvas and below the overlay canvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof WebGL */ let glCanvas;\n/** 2d context for glCanvas\r\n *  @type {WebGL2RenderingContext}\r\n *  @memberof WebGL */ let glContext;\n// WebGL internal variables not exposed to documentation\nlet glShader, glActiveTexture, glArrayBuffer, glGeometryBuffer, glPositionData, glColorData, glInstanceCount, glAdditive, glBatchAdditive;\n///////////////////////////////////////////////////////////////////////////////\n// Initalize WebGL, called automatically by the engine\nfunction glInit() {\n    if (!glEnable || headlessMode) return;\n    // create the canvas and textures\n    glCanvas = document.createElement(\"canvas\");\n    glContext = glCanvas.getContext(\"webgl2\");\n    // some browsers are much faster without copying the gl buffer so we just overlay it instead\n    glOverlay && document.body.appendChild(glCanvas);\n    // setup vertex and fragment shaders\n    glShader = glCreateProgram(\"#version 300 es\\nprecision highp float;uniform mat4 m;in vec2 g;in vec4 p,u,c,a;in float r;out vec2 v;out vec4 d,e;void main(){vec2 s=(g-.5)*p.zw;gl_Position=m*vec4(p.xy+s*cos(r)-vec2(-s.y,s)*sin(r),1,1);v=mix(u.xw,u.zy,g);d=c;e=a;}\" // end of shader\n    , \"#version 300 es\\nprecision highp float;uniform sampler2D s;in vec2 v;in vec4 d,e;out vec4 c;void main(){c=texture(s,v)*d+e;}\" // end of shader\n    );\n    // init buffers\n    const glInstanceData = new ArrayBuffer(gl_INSTANCE_BUFFER_SIZE);\n    glPositionData = new Float32Array(glInstanceData);\n    glColorData = new Uint32Array(glInstanceData);\n    glArrayBuffer = glContext.createBuffer();\n    glGeometryBuffer = glContext.createBuffer();\n    // create the geometry buffer, triangle strip square\n    const geometry = new Float32Array([\n        glInstanceCount = 0,\n        0,\n        1,\n        0,\n        0,\n        1,\n        1,\n        1\n    ]);\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\n    glContext.bufferData(gl_ARRAY_BUFFER, geometry, gl_STATIC_DRAW);\n}\n// Setup render each frame, called automatically by engine\nfunction glPreRender() {\n    if (!glEnable || headlessMode) return;\n    // clear and set to same size as main canvas\n    glContext.viewport(0, 0, glCanvas.width = mainCanvas.width, glCanvas.height = mainCanvas.height);\n    glContext.clear(gl_COLOR_BUFFER_BIT);\n    // set up the shader\n    glContext.useProgram(glShader);\n    glContext.activeTexture(gl_TEXTURE0);\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = textureInfos[0].glTexture);\n    // set vertex attributes\n    let offset = glAdditive = glBatchAdditive = 0;\n    let initVertexAttribArray = (name, type, typeSize, size)=>{\n        const location = glContext.getAttribLocation(glShader, name);\n        const stride = typeSize && gl_INSTANCE_BYTE_STRIDE; // only if not geometry\n        const divisor = typeSize && 1; // only if not geometry\n        const normalize = typeSize == 1; // only if color\n        glContext.enableVertexAttribArray(location);\n        glContext.vertexAttribPointer(location, size, type, normalize, stride, offset);\n        glContext.vertexAttribDivisor(location, divisor);\n        offset += size * typeSize;\n    };\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\n    initVertexAttribArray(\"g\", gl_FLOAT, 0, 2); // geometry\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glArrayBuffer);\n    glContext.bufferData(gl_ARRAY_BUFFER, gl_INSTANCE_BUFFER_SIZE, gl_DYNAMIC_DRAW);\n    initVertexAttribArray(\"p\", gl_FLOAT, 4, 4); // position & size\n    initVertexAttribArray(\"u\", gl_FLOAT, 4, 4); // texture coords\n    initVertexAttribArray(\"c\", gl_UNSIGNED_BYTE, 1, 4); // color\n    initVertexAttribArray(\"a\", gl_UNSIGNED_BYTE, 1, 4); // additiveColor\n    initVertexAttribArray(\"r\", gl_FLOAT, 4, 1); // rotation\n    // build the transform matrix\n    const s = vec2(2 * cameraScale).divide(mainCanvasSize);\n    const p = vec2(-1).subtract(cameraPos.multiply(s));\n    glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader, \"m\"), false, [\n        s.x,\n        0,\n        0,\n        0,\n        0,\n        s.y,\n        0,\n        0,\n        1,\n        1,\n        1,\n        1,\n        p.x,\n        p.y,\n        0,\n        0\n    ]);\n}\n/** Set the WebGl texture, called automatically if using multiple textures\r\n *  - This may also flush the gl buffer resulting in more draw calls and worse performance\r\n *  @param {WebGLTexture} texture\r\n *  @memberof WebGL */ function glSetTexture(texture) {\n    // must flush cache with the old texture to set a new one\n    if (headlessMode || texture == glActiveTexture) return;\n    glFlush();\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = texture);\n}\n/** Compile WebGL shader of the given type, will throw errors if in debug mode\r\n *  @param {String} source\r\n *  @param {Number} type\r\n *  @return {WebGLShader}\r\n *  @memberof WebGL */ function glCompileShader(source, type) {\n    // build the shader\n    const shader = glContext.createShader(type);\n    glContext.shaderSource(shader, source);\n    glContext.compileShader(shader);\n    // check for errors\n    if (debug && !glContext.getShaderParameter(shader, gl_COMPILE_STATUS)) throw glContext.getShaderInfoLog(shader);\n    return shader;\n}\n/** Create WebGL program with given shaders\r\n *  @param {String} vsSource\r\n *  @param {String} fsSource\r\n *  @return {WebGLProgram}\r\n *  @memberof WebGL */ function glCreateProgram(vsSource, fsSource) {\n    // build the program\n    const program = glContext.createProgram();\n    glContext.attachShader(program, glCompileShader(vsSource, gl_VERTEX_SHADER));\n    glContext.attachShader(program, glCompileShader(fsSource, gl_FRAGMENT_SHADER));\n    glContext.linkProgram(program);\n    // check for errors\n    if (debug && !glContext.getProgramParameter(program, gl_LINK_STATUS)) throw glContext.getProgramInfoLog(program);\n    return program;\n}\n/** Create WebGL texture from an image and init the texture settings\r\n *  @param {HTMLImageElement} image\r\n *  @return {WebGLTexture}\r\n *  @memberof WebGL */ function glCreateTexture(image) {\n    // build the texture\n    const texture = glContext.createTexture();\n    glContext.bindTexture(gl_TEXTURE_2D, texture);\n    if (image) glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, image);\n    // use point filtering for pixelated rendering\n    const filter = canvasPixelated ? gl_NEAREST : gl_LINEAR;\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MIN_FILTER, filter);\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MAG_FILTER, filter);\n    return texture;\n}\n/** Draw all sprites and clear out the buffer, called automatically by the system whenever necessary\r\n *  @memberof WebGL */ function glFlush() {\n    if (!glInstanceCount) return;\n    const destBlend = glBatchAdditive ? gl_ONE : gl_ONE_MINUS_SRC_ALPHA;\n    glContext.blendFuncSeparate(gl_SRC_ALPHA, destBlend, gl_ONE, destBlend);\n    glContext.enable(gl_BLEND);\n    // draw all the sprites in the batch and reset the buffer\n    glContext.bufferSubData(gl_ARRAY_BUFFER, 0, glPositionData);\n    glContext.drawArraysInstanced(gl_TRIANGLE_STRIP, 0, 4, glInstanceCount);\n    if (showWatermark) drawCount += glInstanceCount;\n    glInstanceCount = 0;\n    glBatchAdditive = glAdditive;\n}\n/** Draw any sprites still in the buffer, copy to main canvas and clear\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context\r\n *  @param {Boolean} [forceDraw]\r\n *  @memberof WebGL */ function glCopyToContext(context, forceDraw = false) {\n    if (!glEnable || !glInstanceCount && !forceDraw) return;\n    glFlush();\n    // do not draw in overlay mode because the canvas is visible\n    if (!glOverlay || forceDraw) context.drawImage(glCanvas, 0, 0);\n}\n/** Add a sprite to the gl draw list, used by all gl draw functions\r\n *  @param {Number} x\r\n *  @param {Number} y\r\n *  @param {Number} sizeX\r\n *  @param {Number} sizeY\r\n *  @param {Number} angle\r\n *  @param {Number} uv0X\r\n *  @param {Number} uv0Y\r\n *  @param {Number} uv1X\r\n *  @param {Number} uv1Y\r\n *  @param {Number} rgba\r\n *  @param {Number} [rgbaAdditive=0]\r\n *  @memberof WebGL */ function glDraw(x, y, sizeX, sizeY, angle, uv0X, uv0Y, uv1X, uv1Y, rgba, rgbaAdditive = 0) {\n    ASSERT(typeof rgba == \"number\" && typeof rgbaAdditive == \"number\", \"invalid color\");\n    // flush if there is not enough room or if different blend mode\n    if (glInstanceCount >= gl_MAX_INSTANCES || glBatchAdditive != glAdditive) glFlush();\n    let offset = glInstanceCount * gl_INDICIES_PER_INSTANCE;\n    glPositionData[offset++] = x;\n    glPositionData[offset++] = y;\n    glPositionData[offset++] = sizeX;\n    glPositionData[offset++] = sizeY;\n    glPositionData[offset++] = uv0X;\n    glPositionData[offset++] = uv0Y;\n    glPositionData[offset++] = uv1X;\n    glPositionData[offset++] = uv1Y;\n    glColorData[offset++] = rgba;\n    glColorData[offset++] = rgbaAdditive;\n    glPositionData[offset++] = angle;\n    glInstanceCount++;\n}\n///////////////////////////////////////////////////////////////////////////////\n// store gl constants as integers so their name doesn't use space in minifed\nconst gl_ONE = 1, gl_TRIANGLE_STRIP = 5, gl_SRC_ALPHA = 770, gl_ONE_MINUS_SRC_ALPHA = 771, gl_BLEND = 3042, gl_TEXTURE_2D = 3553, gl_UNSIGNED_BYTE = 5121, gl_FLOAT = 5126, gl_RGBA = 6408, gl_NEAREST = 9728, gl_LINEAR = 9729, gl_TEXTURE_MAG_FILTER = 10240, gl_TEXTURE_MIN_FILTER = 10241, gl_COLOR_BUFFER_BIT = 16384, gl_TEXTURE0 = 33984, gl_ARRAY_BUFFER = 34962, gl_STATIC_DRAW = 35044, gl_DYNAMIC_DRAW = 35048, gl_FRAGMENT_SHADER = 35632, gl_VERTEX_SHADER = 35633, gl_COMPILE_STATUS = 35713, gl_LINK_STATUS = 35714, gl_UNPACK_FLIP_Y_WEBGL = 37440, // constants for batch rendering\ngl_INDICIES_PER_INSTANCE = 11, gl_MAX_INSTANCES = 1e4, gl_INSTANCE_BYTE_STRIDE = gl_INDICIES_PER_INSTANCE * 4, gl_INSTANCE_BUFFER_SIZE = gl_MAX_INSTANCES * gl_INSTANCE_BYTE_STRIDE;\n/** \r\n * LittleJS - The Tiny Fast JavaScript Game Engine\r\n * MIT License - Copyright 2021 Frank Force\r\n * \r\n * Engine Features\r\n * - Object oriented system with base class engine object\r\n * - Base class object handles update, physics, collision, rendering, etc\r\n * - Engine helper classes and functions like Vector2, Color, and Timer\r\n * - Super fast rendering system for tile sheets\r\n * - Sound effects audio with zzfx and music with zzfxm\r\n * - Input processing system with gamepad and touchscreen support\r\n * - Tile layer rendering and collision system\r\n * - Particle effect system\r\n * - Medal system tracks and displays achievements\r\n * - Debug tools and debug rendering system\r\n * - Post processing effects\r\n * - Call engineInit() to start it up!\r\n * @namespace Engine\r\n */ /** Name of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */ const engineName = \"LittleJS\";\n/** Version of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */ const engineVersion = \"1.9.9\";\n/** Frames per second to update\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Engine */ const frameRate = 60;\n/** How many seconds each frame lasts, engine uses a fixed time step\r\n *  @type {Number}\r\n *  @default 1/60\r\n *  @memberof Engine */ const timeDelta = 1 / frameRate;\n/** Array containing all engine objects\r\n *  @type {Array}\r\n *  @memberof Engine */ let engineObjects = [];\n/** Array with only objects set to collide with other objects this frame (for optimization)\r\n *  @type {Array}\r\n *  @memberof Engine */ let engineObjectsCollide = [];\n/** Current update frame, used to calculate time\r\n *  @type {Number}\r\n *  @memberof Engine */ let frame = 0;\n/** Current engine time since start in seconds\r\n *  @type {Number}\r\n *  @memberof Engine */ let time = 0;\n/** Actual clock time since start in seconds (not affected by pause or frame rate clamping)\r\n *  @type {Number}\r\n *  @memberof Engine */ let timeReal = 0;\n/** Is the game paused? Causes time and objects to not be updated\r\n *  @type {Boolean}\r\n *  @default false\r\n *  @memberof Engine */ let paused = false;\n/** Set if game is paused\r\n *  @param {Boolean} isPaused\r\n *  @memberof Engine */ function setPaused(isPaused) {\n    paused = isPaused;\n}\n// Frame time tracking\nlet frameTimeLastMS = 0, frameTimeBufferMS = 0, averageFPS = 0;\n///////////////////////////////////////////////////////////////////////////////\n// plugin hooks\nconst pluginUpdateList = [], pluginRenderList = [];\n/** Add a new update function for a plugin\r\n *  @param {Function} [updateFunction]\r\n *  @param {Function} [renderFunction]\r\n *  @memberof Engine */ function engineAddPlugin(updateFunction, renderFunction) {\n    updateFunction && pluginUpdateList.push(updateFunction);\n    renderFunction && pluginRenderList.push(renderFunction);\n}\n///////////////////////////////////////////////////////////////////////////////\n// Main engine functions\n/** Startup LittleJS engine with your callback functions\r\n *  @param {Function} gameInit       - Called once after the engine starts up, setup the game\r\n *  @param {Function} gameUpdate     - Called every frame at 60 frames per second, handle input and update the game state\r\n *  @param {Function} gameUpdatePost - Called after physics and objects are updated, setup camera and prepare for render\r\n *  @param {Function} gameRender     - Called before objects are rendered, draw any background effects that appear behind objects\r\n *  @param {Function} gameRenderPost - Called after objects are rendered, draw effects or hud that appear above all objects\r\n *  @param {Array} [imageSources=['tiles.png']] - Image to load\r\n *  @memberof Engine */ function engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, imageSources = [\n    \"tiles.png\"\n]) {\n    ASSERT(Array.isArray(imageSources), \"pass in images as array\");\n    // Called automatically by engine to setup render system\n    function enginePreRender() {\n        // save canvas size\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\n        // disable smoothing for pixel art\n        mainContext.imageSmoothingEnabled = !canvasPixelated;\n        // setup gl rendering if enabled\n        glPreRender();\n    }\n    // internal update loop for engine\n    function engineUpdate(frameTimeMS = 0) {\n        // update time keeping\n        let frameTimeDeltaMS = frameTimeMS - frameTimeLastMS;\n        frameTimeLastMS = frameTimeMS;\n        if (debug || showWatermark) averageFPS = lerp(.05, averageFPS, 1e3 / (frameTimeDeltaMS || 1));\n        const debugSpeedUp = debug && keyIsDown(\"Equal\"); // +\n        const debugSpeedDown = debug && keyIsDown(\"Minus\"); // -\n        if (debug) frameTimeDeltaMS *= debugSpeedUp ? 5 : debugSpeedDown ? .2 : 1;\n        timeReal += frameTimeDeltaMS / 1e3;\n        frameTimeBufferMS += paused ? 0 : frameTimeDeltaMS;\n        if (!debugSpeedUp) frameTimeBufferMS = min(frameTimeBufferMS, 50); // clamp in case of slow framerate\n        updateCanvas();\n        if (paused) {\n            // update object transforms even when paused\n            for (const o of engineObjects)o.parent || o.updateTransforms();\n            inputUpdate();\n            debugUpdate();\n            gameUpdatePost();\n            inputUpdatePost();\n        } else {\n            // apply time delta smoothing, improves smoothness of framerate in some browsers\n            let deltaSmooth = 0;\n            if (frameTimeBufferMS < 0 && frameTimeBufferMS > -9) {\n                // force at least one update each frame since it is waiting for refresh\n                deltaSmooth = frameTimeBufferMS;\n                frameTimeBufferMS = 0;\n            }\n            // update multiple frames if necessary in case of slow framerate\n            for(; frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / frameRate){\n                // increment frame and update time\n                time = frame++ / frameRate;\n                // update game and objects\n                inputUpdate();\n                gameUpdate();\n                pluginUpdateList.forEach((f)=>f());\n                engineObjectsUpdate();\n                // do post update\n                debugUpdate();\n                gameUpdatePost();\n                inputUpdatePost();\n            }\n            // add the time smoothing back in\n            frameTimeBufferMS += deltaSmooth;\n        }\n        if (!headlessMode) {\n            // render sort then render while removing destroyed objects\n            enginePreRender();\n            gameRender();\n            engineObjects.sort((a, b)=>a.renderOrder - b.renderOrder);\n            for (const o of engineObjects)o.destroyed || o.render();\n            gameRenderPost();\n            pluginRenderList.forEach((f)=>f());\n            touchGamepadRender();\n            debugRender();\n            glCopyToContext(mainContext);\n            if (showWatermark) {\n                // update fps\n                overlayContext.textAlign = \"right\";\n                overlayContext.textBaseline = \"top\";\n                overlayContext.font = \"1em monospace\";\n                overlayContext.fillStyle = \"#000\";\n                const text = engineName + \" \" + \"v\" + engineVersion + \" / \" + drawCount + \" / \" + engineObjects.length + \" / \" + averageFPS.toFixed(1) + (glEnable ? \" GL\" : \" 2D\");\n                overlayContext.fillText(text, mainCanvas.width - 3, 3);\n                overlayContext.fillStyle = \"#fff\";\n                overlayContext.fillText(text, mainCanvas.width - 2, 2);\n                drawCount = 0;\n            }\n        }\n        requestAnimationFrame(engineUpdate);\n    }\n    function updateCanvas() {\n        if (headlessMode) return;\n        if (canvasFixedSize.x) {\n            // clear canvas and set fixed size\n            mainCanvas.width = canvasFixedSize.x;\n            mainCanvas.height = canvasFixedSize.y;\n            // fit to window by adding space on top or bottom if necessary\n            const aspect = innerWidth / innerHeight;\n            const fixedAspect = mainCanvas.width / mainCanvas.height;\n            (glCanvas || mainCanvas).style.width = mainCanvas.style.width = overlayCanvas.style.width = aspect < fixedAspect ? \"100%\" : \"\";\n            (glCanvas || mainCanvas).style.height = mainCanvas.style.height = overlayCanvas.style.height = aspect < fixedAspect ? \"\" : \"100%\";\n        } else {\n            // clear canvas and set size to same as window\n            mainCanvas.width = min(innerWidth, canvasMaxSize.x);\n            mainCanvas.height = min(innerHeight, canvasMaxSize.y);\n        }\n        // clear overlay canvas and set size\n        overlayCanvas.width = mainCanvas.width;\n        overlayCanvas.height = mainCanvas.height;\n        // save canvas size\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\n    }\n    function startEngine() {\n        gameInit();\n        engineUpdate();\n    }\n    if (headlessMode) {\n        startEngine();\n        return;\n    }\n    // setup html\n    const styleBody = \"margin:0;overflow:hidden;background:#000;user-select:none;-webkit-user-select:none;\" + // compatibility for ios\n    (!touchInputEnable ? \"\" : \"touch-action:none;-webkit-touch-callout:none\"); // compatibility for ios\n    document.body.style.cssText = styleBody;\n    document.body.appendChild(mainCanvas = document.createElement(\"canvas\"));\n    mainContext = mainCanvas.getContext(\"2d\");\n    // init stuff and start engine\n    inputInit();\n    audioInit();\n    debugInit();\n    glInit();\n    // create overlay canvas for hud to appear above gl canvas\n    document.body.appendChild(overlayCanvas = document.createElement(\"canvas\"));\n    overlayContext = overlayCanvas.getContext(\"2d\");\n    // set canvas style\n    const styleCanvas = \"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)\"; // center\n    (glCanvas || mainCanvas).style.cssText = mainCanvas.style.cssText = overlayCanvas.style.cssText = styleCanvas;\n    updateCanvas();\n    // create promises for loading images\n    const promises = imageSources.map((src, textureIndex)=>new Promise((resolve)=>{\n            const image = new Image;\n            image.onerror = image.onload = ()=>{\n                textureInfos[textureIndex] = new TextureInfo(image);\n                resolve();\n            };\n            image.src = src;\n        }));\n    // draw splash screen\n    showSplashScreen && promises.push(new Promise((resolve)=>{\n        let t = 0;\n        console.log(`${engineName} Engine v${engineVersion}`);\n        updateSplash();\n        function updateSplash() {\n            clearInput();\n            drawEngineSplashScreen(t += .01);\n            t > 1 ? resolve() : setTimeout(updateSplash, 16);\n        }\n    }));\n    // load all of the images\n    Promise.all(promises).then(startEngine);\n}\n/** Update each engine object, remove destroyed objects, and update time\r\n *  @memberof Engine */ function engineObjectsUpdate() {\n    // get list of solid objects for physics optimzation\n    engineObjectsCollide = engineObjects.filter((o)=>o.collideSolidObjects);\n    // recursive object update\n    function updateObject(o) {\n        if (!o.destroyed) {\n            o.update();\n            for (const child of o.children)updateObject(child);\n        }\n    }\n    for (const o of engineObjects)// update top level objects\n    if (!o.parent) {\n        updateObject(o);\n        o.updateTransforms();\n    }\n    // remove destroyed objects\n    engineObjects = engineObjects.filter((o)=>!o.destroyed);\n}\n/** Destroy and remove all objects\r\n *  @memberof Engine */ function engineObjectsDestroy() {\n    for (const o of engineObjects)o.parent || o.destroy();\n    engineObjects = engineObjects.filter((o)=>!o.destroyed);\n}\n/** Collects all object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array}                        - List of collected objects\r\n *  @memberof Engine */ function engineObjectsCollect(pos, size, objects = engineObjects) {\n    const collectedObjects = [];\n    if (!pos) for (const o of objects)collectedObjects.push(o);\n    else if (size instanceof Vector2) for (const o of objects)isOverlapping(pos, size, o.pos, o.size) && collectedObjects.push(o);\n    else {\n        const sizeSquared = size * size;\n        for (const o of objects)pos.distanceSquared(o.pos) < sizeSquared && collectedObjects.push(o);\n    }\n    return collectedObjects;\n}\n/** Triggers a callback for each object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Function} [callbackFunction]   - Calls this function on every object that passes the test\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @memberof Engine */ function engineObjectsCallback(pos, size, callbackFunction, objects = engineObjects) {\n    engineObjectsCollect(pos, size, objects).forEach((o)=>callbackFunction(o));\n}\n/** Return a list of objects intersecting a ray\r\n *  @param {Vector2} start\r\n *  @param {Vector2} end\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array} - List of objects hit\r\n *  @memberof Engine */ function engineObjectsRaycast(start, end, objects = engineObjects) {\n    const hitObjects = [];\n    for (const o of objects)if (o.collideRaycast && isIntersecting(start, end, o.pos, o.size)) {\n        debugRaycast && debugRect(o.pos, o.size, \"#f00\");\n        hitObjects.push(o);\n    }\n    debugRaycast && debugLine(start, end, hitObjects.length ? \"#f00\" : \"#00f\", .02);\n    return hitObjects;\n}\n///////////////////////////////////////////////////////////////////////////////\n// LittleJS splash screen and logo\nfunction drawEngineSplashScreen(t) {\n    const x = overlayContext;\n    const w = overlayCanvas.width = innerWidth;\n    const h = overlayCanvas.height = innerHeight;\n    {\n        // background\n        const p3 = percent(t, 1, .8);\n        const p4 = percent(t, 0, .5);\n        const g = x.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.hypot(w, h) * .7);\n        g.addColorStop(0, hsl(0, 0, lerp(p4, 0, p3 / 2), p3).toString());\n        g.addColorStop(1, hsl(0, 0, 0, p3).toString());\n        x.save();\n        x.fillStyle = g;\n        x.fillRect(0, 0, w, h);\n    }\n    // draw LittleJS logo...\n    const rect = (X, Y, W, H, C)=>{\n        x.beginPath();\n        x.rect(X, Y, W, C ? H * p : H);\n        x.fillStyle = C;\n        C ? x.fill() : x.stroke();\n    };\n    const line = (X, Y, Z, W)=>{\n        x.beginPath();\n        x.lineTo(X, Y);\n        x.lineTo(Z, W);\n        x.stroke();\n    };\n    const circle = (X, Y, R, A = 0, B = 2 * PI, C, F)=>{\n        const D = (A + B) / 2, E = p * (B - A) / 2;\n        x.beginPath();\n        F && x.lineTo(X, Y);\n        x.arc(X, Y, R, D - E, D + E);\n        x.fillStyle = C;\n        C ? x.fill() : x.stroke();\n    };\n    const color = (c = 0, l = 0)=>hsl([\n            .98,\n            .3,\n            .57,\n            .14\n        ][c % 4] - 10, .8, [\n            0,\n            .3,\n            .5,\n            .8,\n            .9\n        ][l]).toString();\n    const alpha = wave(1, 1, t);\n    const p = percent(alpha, .1, .5);\n    // setup\n    x.translate(w / 2, h / 2);\n    const size = min(6, min(w, h) / 99); // fit to screen\n    x.scale(size, size);\n    x.translate(-40, -35);\n    x.lineJoin = x.lineCap = \"round\";\n    x.lineWidth = .1 + p * 1.9;\n    // drawing effect\n    const p2 = percent(alpha, .1, 1);\n    x.setLineDash([\n        99 * p2,\n        99\n    ]);\n    // cab top\n    rect(7, 16, 18, -8, color(2, 2));\n    rect(7, 8, 18, 4, color(2, 3));\n    rect(25, 8, 8, 8, color(2, 1));\n    rect(25, 8, -18, 8);\n    rect(25, 8, 8, 8);\n    // cab\n    rect(25, 16, 7, 23, color());\n    rect(11, 39, 14, -23, color(1, 1));\n    rect(11, 16, 14, 18, color(1, 2));\n    rect(11, 16, 14, 8, color(1, 3));\n    rect(25, 16, -14, 24);\n    // cab window\n    rect(15, 29, 6, -9, color(2, 2));\n    circle(15, 21, 5, 0, PI / 2, color(2, 4), 1);\n    rect(21, 21, -6, 9);\n    // little stack\n    rect(37, 14, 9, 6, color(3, 2));\n    rect(37, 14, 4.5, 6, color(3, 3));\n    rect(37, 14, 9, 6);\n    // big stack\n    rect(50, 20, 10, -8, color(0, 1));\n    rect(50, 20, 6.5, -8, color(0, 2));\n    rect(50, 20, 3.5, -8, color(0, 3));\n    rect(50, 20, 10, -8);\n    circle(55, 2, 11.4, .5, PI - .5, color(3, 3));\n    circle(55, 2, 11.4, .5, PI / 2, color(3, 2), 1);\n    circle(55, 2, 11.4, .5, PI - .5);\n    rect(45, 7, 20, -7, color(0, 2));\n    rect(45, -1, 20, 4, color(0, 3));\n    rect(45, -1, 20, 8);\n    // engine\n    for(let i = 5; i--;){\n        // stagger radius to fix slight seam\n        circle(60 - i * 6, 30, 9.9, 0, 2 * PI, color(i + 2, 3));\n        circle(60 - i * 6, 30, 10.0, -0.5, PI + .5, color(i + 2, 2));\n        circle(60 - i * 6, 30, 10.1, .5, PI - .5, color(i + 2, 1));\n    }\n    // engine outline\n    circle(36, 30, 10, PI / 2, PI * 3 / 2);\n    circle(48, 30, 10, PI / 2, PI * 3 / 2);\n    circle(60, 30, 10);\n    line(36, 20, 60, 20);\n    // engine front light\n    circle(60, 30, 4, PI, 3 * PI, color(3, 2));\n    circle(60, 30, 4, PI, 2 * PI, color(3, 3));\n    circle(60, 30, 4, PI, 3 * PI);\n    // front brush\n    for(let i = 6; i--;){\n        x.beginPath();\n        x.lineTo(53, 54);\n        x.lineTo(53, 40);\n        x.lineTo(53 + (1 + i * 2.9) * p, 40);\n        x.lineTo(53 + (4 + i * 3.5) * p, 54);\n        x.fillStyle = color(0, i % 2 + 2);\n        x.fill();\n        i % 2 && x.stroke();\n    }\n    // wheels\n    rect(6, 40, 5, 5);\n    rect(6, 40, 5, 5, color());\n    rect(15, 54, 38, -14, color());\n    for(let i = 3; i--;)for(let j = 2; j--;){\n        circle(15 * i + 15, 47, j ? 7 : 1, PI, 3 * PI, color(i, 3));\n        x.stroke();\n        circle(15 * i + 15, 47, j ? 7 : 1, 0, PI, color(i, 2));\n        x.stroke();\n    }\n    line(6, 40, 68, 40); // center\n    line(77, 54, 4, 54); // bottom\n    // draw engine name\n    const s = engineName;\n    x.font = \"900 16px arial\";\n    x.textAlign = \"center\";\n    x.textBaseline = \"top\";\n    x.lineWidth = .1 + p * 3.9;\n    let w2 = 0;\n    for(let i = 0; i < s.length; ++i)w2 += x.measureText(s[i]).width;\n    for(let j = 2; j--;)for(let i = 0, X = 41 - w2 / 2; i < s.length; ++i){\n        x.fillStyle = color(i, 2);\n        const w = x.measureText(s[i]).width;\n        x[j ? \"strokeText\" : \"fillText\"](s[i], X + w / 2, 55.5, 17 * p);\n        X += w;\n    }\n    x.restore();\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}],\"k3151\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"8HL3d\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"randomAddNumber\", ()=>randomAddNumber);\nparcelHelpers.export(exports, \"randomSubstractNumber\", ()=>randomSubstractNumber);\nparcelHelpers.export(exports, \"randomMultiplyNumber\", ()=>randomMultiplyNumber);\nparcelHelpers.export(exports, \"randomDivideNumber\", ()=>randomDivideNumber);\nparcelHelpers.export(exports, \"startGameRound\", ()=>startGameRound);\nvar _constants = require(\"./constants\");\nvar _types = require(\"./types\");\nconst randomAddNumber = (currentNumber)=>{\n    return Math.floor(Math.random()) * ((0, _constants.MAX_NUMBER) - currentNumber) + 1;\n};\nconst randomSubstractNumber = (currentNumber)=>{\n    return Math.floor(Math.random() * currentNumber) + 1;\n};\nconst randomMultiplyNumber = (currentNumber)=>{\n    const multiplicands = [];\n    for(let i = 2; i <= (0, _constants.MAX_NUMBER); i++)if (currentNumber * i <= (0, _constants.MAX_NUMBER)) multiplicands.push(i);\n    return multiplicands[Math.floor(Math.random() * multiplicands.length)];\n};\nconst randomDivideNumber = (currentNumber)=>{\n    if (currentNumber === 1) return 1;\n    let n = currentNumber - 1;\n    let divisors = [];\n    while(n--)if (currentNumber % n === 0) divisors.push(n);\n    return divisors[Math.floor(Math.random() * divisors.length)];\n};\nconst startGameRound = (difficulty = (0, _constants.DIFFICULTY).easy)=>{\n    let current = 13;\n    const ops = (0, _constants.OPERATION_SEQUENCES)[difficulty][Math.floor(Math.random() * 6)];\n    const sequence = ops.map((op)=>{\n        // for adding and substraction just use any value 1-99 that gives a positive value\n        // for multiplication and division only some values are posible\n        if (op === (0, _types.OPERATION_TYPE).ADD) {\n            const value = randomSubstractNumber(current);\n            current -= value;\n            return {\n                type: op,\n                value\n            };\n        } else if (op === (0, _types.OPERATION_TYPE).SUB) {\n            const value = randomAddNumber(current);\n            current += value;\n            return {\n                type: op,\n                value\n            };\n        } else if (op === (0, _types.OPERATION_TYPE).MUL) {\n            const value = randomDivideNumber(current);\n            if (value === 1) return null;\n            current /= value;\n            return {\n                type: op,\n                value\n            };\n        } else if (op === (0, _types.OPERATION_TYPE).DIV) {\n            const value = randomMultiplyNumber(current);\n            current *= value;\n            return {\n                type: op,\n                value\n            };\n        }\n    });\n    return {\n        initialNumber: current,\n        sequence: sequence.filter((s)=>s)\n    };\n};\n\n},{\"./constants\":\"7NbOs\",\"./types\":\"dHDQY\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}],\"7NbOs\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"MAX_NUMBER\", ()=>MAX_NUMBER);\nparcelHelpers.export(exports, \"DIFFICULTY\", ()=>DIFFICULTY);\nparcelHelpers.export(exports, \"GAME_STATE\", ()=>GAME_STATE);\nparcelHelpers.export(exports, \"OPERATION_SEQUENCES\", ()=>OPERATION_SEQUENCES);\nparcelHelpers.export(exports, \"COLOR_PALETTE\", ()=>COLOR_PALETTE);\nvar _littlejsengine = require(\"littlejsengine\");\nvar _types = require(\"./types\");\nconst MAX_NUMBER = 99;\nvar DIFFICULTY;\n(function(DIFFICULTY) {\n    DIFFICULTY[\"easy\"] = \"easy\";\n    DIFFICULTY[\"medium\"] = \"medium\";\n    DIFFICULTY[\"hard\"] = \"hard\";\n})(DIFFICULTY || (DIFFICULTY = {}));\nvar GAME_STATE;\n(function(GAME_STATE) {\n    GAME_STATE[GAME_STATE[\"PLAYING\"] = 0] = \"PLAYING\";\n    GAME_STATE[GAME_STATE[\"LOSE\"] = 1] = \"LOSE\";\n    GAME_STATE[GAME_STATE[\"WIN\"] = 2] = \"WIN\";\n})(GAME_STATE || (GAME_STATE = {}));\nconst OPERATION_SEQUENCES = {\n    easy: [\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).MUL\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).ADD\n        ],\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).MUL\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).SUB\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV\n        ]\n    ],\n    medium: [\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).SUB\n        ],\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).SUB\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).ADD\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).ADD\n        ]\n    ],\n    hard: [\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV\n        ],\n        [\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).MUL\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).SUB\n        ],\n        [\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).ADD\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).MUL,\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).DIV\n        ],\n        [\n            (0, _types.OPERATION_TYPE).SUB,\n            (0, _types.OPERATION_TYPE).DIV,\n            (0, _types.OPERATION_TYPE).ADD,\n            (0, _types.OPERATION_TYPE).MUL\n        ]\n    ]\n};\nconst COLOR_PALETTE = {\n    RED: new (0, _littlejsengine.Color)(231 / 255, 111 / 255, 81 / 255, 1),\n    ORANGE: new (0, _littlejsengine.Color)(244 / 255, 162 / 255, 97 / 255, 1),\n    YELLOW: new (0, _littlejsengine.Color)(233 / 255, 196 / 255, 106 / 255, 1),\n    GREEN: new (0, _littlejsengine.Color)(42 / 255, 157 / 255, 143 / 255, 1),\n    BLUE: new (0, _littlejsengine.Color)(38 / 255, 70 / 255, 83 / 255, 1),\n    WHITE: new (0, _littlejsengine.Color)(238 / 255, 238 / 255, 238 / 255, 1),\n    TRANSPARENT: new (0, _littlejsengine.Color)(0, 0, 0, 0)\n};\n\n},{\"littlejsengine\":\"gSdBJ\",\"./types\":\"dHDQY\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}],\"dHDQY\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"OPERATION_TYPE\", ()=>OPERATION_TYPE);\nvar OPERATION_TYPE;\n(function(OPERATION_TYPE) {\n    OPERATION_TYPE[\"ADD\"] = \"ADD\";\n    OPERATION_TYPE[\"SUB\"] = \"SUB\";\n    OPERATION_TYPE[\"MUL\"] = \"MUL\";\n    OPERATION_TYPE[\"DIV\"] = \"DIV\";\n})(OPERATION_TYPE || (OPERATION_TYPE = {}));\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}],\"fQxwN\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"renderBackground\", ()=>renderBackground);\nparcelHelpers.export(exports, \"renderLevel\", ()=>renderLevel);\nparcelHelpers.export(exports, \"renderInstructions\", ()=>renderInstructions);\nparcelHelpers.export(exports, \"renderMaxLevel\", ()=>renderMaxLevel);\nvar _littlejsengine = require(\"littlejsengine\");\nvar _constants = require(\"./constants\");\nconst renderBackground = ()=>{\n    (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(0, 0), (0, _littlejsengine.vec2)((0, _littlejsengine.mainCanvas).width, (0, _littlejsengine.mainCanvas).height), (0, _constants.COLOR_PALETTE).YELLOW);\n// drawRect(vec2(-10, 0), vec2(mainCanvas.width, 1), COLOR_PALETTE.ORANGE);\n// drawRect(vec2(0, -10), vec2(1, mainCanvas.height), COLOR_PALETTE.ORANGE);\n};\nconst renderLevel = (level)=>{\n    (0, _littlejsengine.drawText)(`Level ${level}`, (0, _littlejsengine.vec2)(0, 12), 1, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n};\nconst renderInstructions = ()=>{\n    (0, _littlejsengine.drawRect)((0, _littlejsengine.vec2)(-20, -9), (0, _littlejsengine.vec2)(100, 4), (0, _constants.COLOR_PALETTE).BLUE);\n    (0, _littlejsengine.drawText)(\"Welcome to 10 + 3! This game will help you with your phobia to... that number.\", (0, _littlejsengine.vec2)(0, -9), 0.5, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n    (0, _littlejsengine.drawText)(\"Use the arrow keys to perform the operations in the correct order to get... that number.\", (0, _littlejsengine.vec2)(-0.85, -9.5), 0.5, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n};\nconst renderMaxLevel = (maxLevel)=>{\n    (0, _littlejsengine.drawText)(`Your max. level: ${maxLevel}`, (0, _littlejsengine.vec2)(12, 12), 0.5, (0, _constants.COLOR_PALETTE).WHITE, 2, (0, _constants.COLOR_PALETTE).TRANSPARENT);\n};\n\n},{\"littlejsengine\":\"gSdBJ\",\"./constants\":\"7NbOs\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"k3151\"}]},[\"8RSWf\"], \"8RSWf\", \"parcelRequiref445\")\n\n//# sourceMappingURL=index.01cb6101.js.map\n","/*\n    10 + 3 Math puzzle game\n    \n    In the middle there is a random number.\n    Using the up, down, left and right operations in the correct order\n    try to get 13 as a result.\n\n    Controls: Use arrow keys to select the operations!\n*/\n\n\nimport { setCanvasPixelated, vec2, Sound, drawText, engineInit, keyWasPressed, setShowWatermark, drawRect } from \"littlejsengine\";\nimport { startGameRound } from \"./helpers\";\nimport { GameRound, Operation, OPERATION_TYPE } from \"./types\";\nimport { COLOR_PALETTE, DIFFICULTY, GAME_STATE } from \"./constants\";\nimport { renderBackground, renderInstructions, renderLevel, renderMaxLevel } from \"./render-functions\";\n\n// do not use pixelated rendering\nsetCanvasPixelated(false);\n// remove watermark\nsetShowWatermark(false);\n\n\n// sound effects\nconst sound_goodMove = new Sound([,0,349.2282]);\nconst sound_badMove = new Sound([,0,146.8324,,,.5,,.3,,,,,,,,,,,.2]);\n\n// ***********game variables************\n  let gameRound: GameRound;\n  let addOperand: number;\n  let subOperand: number;\n  let divOperand: number;\n  let mulOperand: number;\n  let gameState = GAME_STATE.PLAYING;\n  let level = 1;\n  let maxLevel = localStorage.getItem(\"maxLevel\");\n// *************************************\n\nconst createOperands = (gameRound: GameRound) => {\n  gameRound.sequence.forEach(op => {\n    if (op.type === OPERATION_TYPE.ADD) {\n      addOperand = op.value;\n    } else if (op.type === OPERATION_TYPE.SUB) {\n      subOperand = op.value;\n    } else if (op.type === OPERATION_TYPE.MUL) {\n      mulOperand = op.value;\n    } else if (op.type === OPERATION_TYPE.DIV) {\n      divOperand = op.value;\n    }\n  });\n};\n\nconst resetOperands = () => {\n  addOperand = undefined;\n  subOperand = undefined;\n  divOperand = undefined;\n  mulOperand = undefined;\n};\n\nconst resetGame = () => {\n  maxLevel = localStorage.getItem(\"maxLevel\");\n  let currentDifficulty = DIFFICULTY.easy;\n  if (level > 10) {\n    currentDifficulty = DIFFICULTY.hard;\n  } else if (level > 5) {\n    currentDifficulty = DIFFICULTY.medium;\n  }\n  gameRound = startGameRound(currentDifficulty);\n  resetOperands();\n  createOperands(gameRound);\n  gameState = GAME_STATE.PLAYING;\n};\n\nconst nextLevel = () => {\n  if (level !== 12) {\n    level += 1;\n  } else {\n    level = level + 2;\n  }\n  resetGame();\n}\n\nconst updateCurrentResult = (op: Operation) => {\n  if (op.type === OPERATION_TYPE.ADD) {\n    gameRound.initialNumber += op.value;\n  } else if (op.type === OPERATION_TYPE.SUB) {\n    gameRound.initialNumber -= op.value;\n  } else if (op.type === OPERATION_TYPE.MUL) {\n    gameRound.initialNumber *= op.value;\n  } else if (op.type === OPERATION_TYPE.DIV) {\n    gameRound.initialNumber /= op.value;\n  }\n};\n\nfunction gameInit()\n{\n  gameRound = startGameRound();\n  createOperands(gameRound);\n}\n\n\nfunction gameUpdate()\n{\n  const sendAnswer = (answerOperation: OPERATION_TYPE) => {\n    const op = gameRound.sequence.pop();\n    if (op.type === answerOperation) {\n      resetOperands();\n      createOperands(gameRound);\n      updateCurrentResult(op);\n      sound_goodMove.play();\n      if (gameRound.sequence.length === 0) {\n        gameState = GAME_STATE.WIN;\n      }\n    } else {\n      gameState = GAME_STATE.LOSE;\n      sound_badMove.play();\n      if (level > Number(maxLevel)) {\n        localStorage.setItem(\"maxLevel\", String(level));\n      }\n    }\n  }\n\n  if (gameState === GAME_STATE.PLAYING && keyWasPressed(\"ArrowUp\") && addOperand) {\n    sendAnswer(OPERATION_TYPE.ADD);\n  } else if (gameState === GAME_STATE.PLAYING && keyWasPressed(\"ArrowRight\") && mulOperand) {\n    sendAnswer(OPERATION_TYPE.MUL);\n  } else if (gameState === GAME_STATE.PLAYING && keyWasPressed(\"ArrowDown\") && subOperand) {\n    sendAnswer(OPERATION_TYPE.SUB);\n  } else if (gameState === GAME_STATE.PLAYING && keyWasPressed(\"ArrowLeft\") && divOperand) {\n    sendAnswer(OPERATION_TYPE.DIV);\n  } else if (gameState === GAME_STATE.WIN && keyWasPressed(\"Enter\")) {\n    nextLevel();\n  } else if (gameState === GAME_STATE.LOSE && keyWasPressed(\"Enter\")) {{\n    level = 1;\n    resetGame();\n  }}\n}\n\nfunction gameUpdatePost(){}\n\nfunction gameRender()\n{\n  renderBackground();\n\n  renderLevel(level);\n\n  if (maxLevel) {\n    renderMaxLevel(maxLevel);\n  }\n\n  if (gameState === GAME_STATE.WIN) {\n    drawRect(vec2(-0.05, 0), vec2(1.7, 1.7), COLOR_PALETTE.GREEN);\n  } else {\n    drawRect(vec2(-0.05, 0), vec2(1.7, 1.7), COLOR_PALETTE.BLUE);\n  }\n  drawText(gameRound.initialNumber.toString(), vec2(0, 0), 1, COLOR_PALETTE.WHITE, 4, COLOR_PALETTE.TRANSPARENT);\n\n  if (addOperand) {\n    drawText(\"+\", vec2(0, 2), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawText(String(addOperand), vec2(0, 4), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawRect(vec2(0, 4), vec2(1.7, 1.7), COLOR_PALETTE.ORANGE);\n  }\n  \n  if (subOperand) {\n    drawText(\"-\", vec2(0, -2), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawText(String(subOperand), vec2(0, -4), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawRect(vec2(0, -4), vec2(1.7, 1.7), COLOR_PALETTE.ORANGE);\n  }\n  \n  if (mulOperand) {\n    drawText(\"x\", vec2(2, 0), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawText(String(mulOperand), vec2(4, 0), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawRect(vec2(4, 0), vec2(1.7, 1.7), COLOR_PALETTE.ORANGE);\n  }\n  \n  if (divOperand) {\n    drawText(\"/\", vec2(-2, 0), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawText(String(divOperand), vec2(-4, 0), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawRect(vec2(-4, 0), vec2(1.7, 1.7), COLOR_PALETTE.ORANGE);\n  }\n\n  if (level <= 3) {\n    renderInstructions();\n  }\n\n  switch (gameState) {\n    case GAME_STATE.WIN:\n        drawText(\"Correct! Press enter to continue...\", vec2(0, 6), 1, COLOR_PALETTE.GREEN, 2, COLOR_PALETTE.TRANSPARENT);\n      break;\n      case GAME_STATE.LOSE:\n        drawText(\"Wrong! Press enter to continue...\", vec2(0, 6), 1, COLOR_PALETTE.RED, 2, COLOR_PALETTE.TRANSPARENT);\n    break;\n  }\n}\n\nfunction gameRenderPost(){}\n\n///////////////////////////////////////////////////////////////////////////////\n// Startup LittleJS Engine\nengineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);\n\n","// LittleJS - MIT License - Copyright 2021 Frank Force\n\n'use strict';\n\n/** \r\n * LittleJS Debug System\r\n * - Press Esc to show debug overlay with mouse pick\r\n * - Number keys toggle debug functions\r\n * - +/- apply time scale\r\n * - Debug primitive rendering\r\n * - Save a 2d canvas as a png image\r\n * @namespace Debug\r\n */\r\n\r\n\r\n\r\n/** True if debug is enabled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nconst debug = true;\r\n\r\n/** True if asserts are enaled\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nconst enableAsserts = true;\r\n\r\n/** Size to render debug points by default\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Debug */\r\nconst debugPointSize = .5;\r\n\r\n/** True if watermark with FPS should be shown, false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nlet showWatermark = true;\r\n\r\n/** Key code used to toggle debug mode, Esc by default\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Debug */\r\nlet debugKey = 'Escape';\r\n\r\n/** True if the debug overlay is active, always false in release builds\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Debug */\r\nlet debugOverlay = false;\r\n\r\n// Engine internal variables not exposed to documentation\r\nlet debugPrimitives = [], debugPhysics = false, debugRaycast = false, debugParticles = false, debugGamepads = false, debugMedals = false, debugTakeScreenshot, downloadLink;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Debug helper functions\r\n\r\n/** Asserts if the expression is false, does not do anything in release builds\r\n *  @param {Boolean} assert\r\n *  @param {Object} [output]\r\n *  @memberof Debug */\r\nfunction ASSERT(assert, output) \r\n{\r\n    if (enableAsserts)\r\n        output ? console.assert(assert, output) : console.assert(assert);\r\n}\r\n\r\n/** Draw a debug rectangle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=Vector2()]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugRect(pos, size=vec2(), color='#fff', time=0, angle=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, size:vec2(size), color, time:new Timer(time), angle, fill});\r\n}\r\n\r\n/** Draw a debug poly in world space\r\n *  @param {Vector2} pos\r\n *  @param {Array}   points\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugPoly(pos, points, color='#fff', time=0, angle=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, points, color, time:new Timer(time), angle, fill});\r\n}\r\n\r\n/** Draw a debug circle in world space\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [radius]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Boolean} [fill]\r\n *  @memberof Debug */\r\nfunction debugCircle(pos, radius=0, color='#fff', time=0, fill=false)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({pos, size:radius, color, time:new Timer(time), angle:0, fill});\r\n}\r\n\r\n/** Draw a debug point in world space\r\n *  @param {Vector2} pos\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @memberof Debug */\r\nfunction debugPoint(pos, color, time, angle)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugRect(pos, undefined, color, time, angle);\r\n}\r\n\r\n/** Draw a debug line in world space\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {String}  [color]\r\n *  @param {Number}  [thickness]\r\n *  @param {Number}  [time]\r\n *  @memberof Debug */\r\nfunction debugLine(posA, posB, color, thickness=.1, time)\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);\r\n    const size = vec2(thickness, halfDelta.length()*2);\r\n    debugRect(posA.add(halfDelta), size, color, time, halfDelta.angle(), true);\r\n}\r\n\r\n/** Draw a debug combined axis aligned bounding box in world space\r\n *  @param {Vector2} pA - position A\r\n *  @param {Vector2} sA - size A\r\n *  @param {Vector2} pB - position B\r\n *  @param {Vector2} sB - size B\r\n *  @param {String}  [color]\r\n *  @memberof Debug */\r\nfunction debugOverlap(pA, sA, pB, sB, color)\r\n{\r\n    const minPos = vec2(min(pA.x - sA.x/2, pB.x - sB.x/2), min(pA.y - sA.y/2, pB.y - sB.y/2));\r\n    const maxPos = vec2(max(pA.x + sA.x/2, pB.x + sB.x/2), max(pA.y + sA.y/2, pB.y + sB.y/2));\r\n    debugRect(minPos.lerp(maxPos,.5), maxPos.subtract(minPos), color);\r\n}\r\n\r\n/** Draw a debug axis aligned bounding box in world space\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {String}  [color]\r\n *  @param {Number}  [time]\r\n *  @param {Number}  [angle]\r\n *  @param {String}  [font]\r\n *  @memberof Debug */\r\nfunction debugText(text, pos, size=1, color='#fff', time=0, angle=0, font='monospace')\r\n{\r\n    ASSERT(typeof color == 'string', 'pass in css color strings'); \r\n    debugPrimitives.push({text, pos, size, color, time:new Timer(time), angle, font});\r\n}\r\n\r\n/** Clear all debug primitives in the list\r\n *  @memberof Debug */\r\nfunction debugClear() { debugPrimitives = []; }\r\n\r\n/** Save a canvas to disk \r\n *  @param {HTMLCanvasElement} canvas\r\n *  @param {String}            [filename]\r\n *  @param {String}            [type]\r\n *  @memberof Debug */\r\nfunction debugSaveCanvas(canvas, filename='screenshot', type='image/png')\r\n{ debugSaveDataURL(canvas.toDataURL(type), filename); }\r\n\r\n/** Save a text file to disk \r\n *  @param {String}     text\r\n *  @param {String}     [filename]\r\n *  @param {String}     [type]\r\n *  @memberof Debug */\r\nfunction debugSaveText(text, filename='text', type='text/plain')\r\n{ debugSaveDataURL(URL.createObjectURL(new Blob([text], {'type':type})), filename); }\r\n\r\n/** Save a data url to disk \r\n *  @param {String}     dataURL\r\n *  @param {String}     filename\r\n *  @memberof Debug */\r\nfunction debugSaveDataURL(dataURL, filename)\r\n{\r\n    downloadLink.download = filename;\r\n    downloadLink.href = dataURL;\r\n    downloadLink.click();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Engine debug function (called automatically)\r\n\r\nfunction debugInit()\r\n{\r\n    // create link for saving screenshots\r\n    downloadLink = document.createElement('a');\r\n}\r\n\r\nfunction debugUpdate()\r\n{\r\n    if (!debug)\r\n        return;\r\n\r\n    if (keyWasPressed(debugKey)) // Esc\r\n        debugOverlay = !debugOverlay;\r\n    if (debugOverlay)\r\n    {\r\n        if (keyWasPressed('Digit0'))\r\n            showWatermark = !showWatermark;\r\n        if (keyWasPressed('Digit1'))\r\n            debugPhysics = !debugPhysics, debugParticles = false;\r\n        if (keyWasPressed('Digit2'))\r\n            debugParticles = !debugParticles, debugPhysics = false;\r\n        if (keyWasPressed('Digit3'))\r\n            debugGamepads = !debugGamepads;\r\n        if (keyWasPressed('Digit4'))\r\n            debugRaycast = !debugRaycast;\r\n        if (keyWasPressed('Digit5'))\r\n            debugTakeScreenshot = 1;\r\n    }\r\n}\r\n\r\nfunction debugRender()\r\n{\r\n    glCopyToContext(mainContext);\r\n\r\n    if (debugTakeScreenshot)\r\n    {\r\n        // composite canvas\r\n        glCopyToContext(mainContext, true);\r\n        mainContext.drawImage(overlayCanvas, 0, 0);\r\n        overlayCanvas.width |= 0;\r\n\r\n        // remove alpha and save\r\n        const w = mainCanvas.width, h = mainCanvas.height;\r\n        overlayContext.fillRect(0,0,w,h);\r\n        overlayContext.drawImage(mainCanvas, 0, 0);\r\n        debugSaveCanvas(overlayCanvas);\r\n        debugTakeScreenshot = 0;\r\n    }\r\n\r\n    if (debugGamepads && gamepadsEnable && navigator.getGamepads)\r\n    {\r\n        // gamepad debug display\r\n        const gamepads = navigator.getGamepads();\r\n        for (let i = gamepads.length; i--;)\r\n        {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad)\r\n            {\r\n                const stickScale = 1;\r\n                const buttonScale = .2;\r\n                const centerPos = cameraPos;\r\n                const sticks = gamepadStickData[i];\r\n                for (let j = sticks.length; j--;)\r\n                {\r\n                    const drawPos = centerPos.add(vec2(j*stickScale*2, i*stickScale*3));\r\n                    const stickPos = drawPos.add(sticks[j].scale(stickScale));\r\n                    debugCircle(drawPos, stickScale, '#fff7',0,true);\r\n                    debugLine(drawPos, stickPos, '#f00');\r\n                    debugPoint(stickPos, '#f00');\r\n                }\r\n                for (let j = gamepad.buttons.length; j--;)\r\n                {\r\n                    const drawPos = centerPos.add(vec2(j*buttonScale*2, i*stickScale*3-stickScale-buttonScale));\r\n                    const pressed = gamepad.buttons[j].pressed;\r\n                    debugCircle(drawPos, buttonScale, pressed ? '#f00' : '#fff7', 0, true);\r\n                    debugText(''+j, drawPos, .2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    let debugObject;\r\n    if (debugOverlay)\r\n    {\r\n        const saveContext = mainContext;\r\n        mainContext = overlayContext;\r\n        \r\n        // draw red rectangle around screen\r\n        const cameraSize = getCameraSize();\r\n        debugRect(cameraPos, cameraSize.subtract(vec2(.1)), '#f008');\r\n\r\n        // mouse pick\r\n        let bestDistance = Infinity;\r\n        for (const o of engineObjects)\r\n        {\r\n            if (o.canvas || o.destroyed)\r\n                continue;\r\n\r\n            o.renderDebugInfo();\r\n            if (!o.size.x || !o.size.y)\r\n                continue;\r\n\r\n            const distance = mousePos.distanceSquared(o.pos);\r\n            if (distance < bestDistance)\r\n            {\r\n                bestDistance = distance;\r\n                debugObject = o;\r\n            }\r\n        }\r\n\r\n        if (tileCollisionSize.x > 0 && tileCollisionSize.y > 0)\r\n            drawRect(mousePos.floor().add(vec2(.5)), vec2(1), rgb(0,0,1,.5), 0, false);\r\n        mainContext = saveContext;\r\n\r\n        //glCopyToContext(mainContext = saveContext);\r\n    }\r\n\r\n    {\r\n        // draw debug primitives\r\n        overlayContext.lineWidth = 2;\r\n        const pointSize = debugPointSize * cameraScale;\r\n        debugPrimitives.forEach(p=>\r\n        {\r\n            overlayContext.save();\r\n\r\n            // create canvas transform from world space to screen space\r\n            const pos = worldToScreen(p.pos);\r\n            overlayContext.translate(pos.x|0, pos.y|0);\r\n            overlayContext.rotate(p.angle);\r\n            overlayContext.scale(1, -1);\r\n            overlayContext.fillStyle = overlayContext.strokeStyle = p.color;\r\n\r\n            if (p.text != undefined)\r\n            {\r\n                overlayContext.font = p.size*cameraScale + 'px '+ p.font;\r\n                overlayContext.textAlign = 'center';\r\n                overlayContext.textBaseline = 'middle';\r\n                overlayContext.fillText(p.text, 0, 0);\r\n            }\r\n            else if (p.points != undefined)\r\n            {\r\n                // poly\r\n                overlayContext.beginPath();\r\n                for (const point of p.points)\r\n                {\r\n                    const p2 = point.scale(cameraScale).floor();\r\n                    overlayContext.lineTo(p2.x, p2.y);\r\n                }\r\n                overlayContext.closePath();\r\n                p.fill && overlayContext.fill();\r\n                overlayContext.stroke();\r\n            }\r\n            else if (p.size == 0 || p.size.x === 0 && p.size.y === 0)\r\n            {\r\n                // point\r\n                overlayContext.fillRect(-pointSize/2, -1, pointSize, 3);\r\n                overlayContext.fillRect(-1, -pointSize/2, 3, pointSize);\r\n            }\r\n            else if (p.size.x != undefined)\r\n            {\r\n                // rect\r\n                const s = p.size.scale(cameraScale).floor();\r\n                const w = s.x, h = s.y;\r\n                p.fill && overlayContext.fillRect(-w/2|0, -h/2|0, w, h);\r\n                overlayContext.strokeRect(-w/2|0, -h/2|0, w, h);\r\n            }\r\n            else\r\n            {\r\n                // circle\r\n                overlayContext.beginPath();\r\n                overlayContext.arc(0, 0, p.size*cameraScale, 0, 9);\r\n                p.fill && overlayContext.fill();\r\n                overlayContext.stroke();\r\n            }\r\n            \r\n            overlayContext.restore();\r\n        });\r\n\r\n        // remove expired primitives\r\n        debugPrimitives = debugPrimitives.filter(r=>r.time<0);\r\n    }\r\n    \r\n    if (debugObject)\r\n    {\r\n        const saveContext = mainContext;\r\n        mainContext = overlayContext;\r\n        const raycastHitPos = tileCollisionRaycast(debugObject.pos, mousePos);\r\n        raycastHitPos && drawRect(raycastHitPos.floor().add(vec2(.5)), vec2(1), rgb(0,1,1,.3));\r\n        drawLine(mousePos, debugObject.pos, .1, raycastHitPos ? rgb(1,0,0,.5) : rgb(0,1,0,.5), false);\r\n\r\n        const debugText = 'mouse pos = ' + mousePos + \r\n            '\\nmouse collision = ' + getTileCollisionData(mousePos) + \r\n            '\\n\\n--- object info ---\\n' +\r\n            debugObject.toString();\r\n        drawTextScreen(debugText, mousePosScreen, 24, rgb(), .05, undefined, 'center', 'monospace');\r\n        mainContext = saveContext;\r\n    }\r\n\r\n    {\r\n        // draw debug overlay\r\n        overlayContext.save();\r\n        overlayContext.fillStyle = '#fff';\r\n        overlayContext.textAlign = 'left';\r\n        overlayContext.textBaseline = 'top';\r\n        overlayContext.font = '28px monospace';\r\n        overlayContext.shadowColor = '#000';\r\n        overlayContext.shadowBlur = 9;\r\n\r\n        let x = 9, y = -20, h = 30;\r\n        if (debugOverlay)\r\n        {\r\n            overlayContext.fillText(engineName, x, y += h);\r\n            overlayContext.fillText('Objects: ' + engineObjects.length, x, y += h);\r\n            overlayContext.fillText('Time: ' + formatTime(time), x, y += h);\r\n            overlayContext.fillText('---------', x, y += h);\r\n            overlayContext.fillStyle = '#f00';\r\n            overlayContext.fillText('ESC: Debug Overlay', x, y += h);\r\n            overlayContext.fillStyle = debugPhysics ? '#f00' : '#fff';\r\n            overlayContext.fillText('1: Debug Physics', x, y += h);\r\n            overlayContext.fillStyle = debugParticles ? '#f00' : '#fff';\r\n            overlayContext.fillText('2: Debug Particles', x, y += h);\r\n            overlayContext.fillStyle = debugGamepads ? '#f00' : '#fff';\r\n            overlayContext.fillText('3: Debug Gamepads', x, y += h);\r\n            overlayContext.fillStyle = debugRaycast ? '#f00' : '#fff';\r\n            overlayContext.fillText('4: Debug Raycasts', x, y += h);\r\n            overlayContext.fillStyle = '#fff';\r\n            overlayContext.fillText('5: Save Screenshot', x, y += h);\r\n\r\n            let keysPressed = '';\r\n            for(const i in inputData[0])\r\n            {\r\n                if (keyIsDown(i, 0))\r\n                    keysPressed += i + ' ' ;\r\n            }\r\n            keysPressed && overlayContext.fillText('Keys Down: ' + keysPressed, x, y += h);\r\n\r\n            let buttonsPressed = '';\r\n            if (inputData[1])\r\n            for(const i in inputData[1])\r\n            {\r\n                if (keyIsDown(i, 1))\r\n                    buttonsPressed += i + ' ' ;\r\n            }\r\n            buttonsPressed && overlayContext.fillText('Gamepad: ' + buttonsPressed, x, y += h);\r\n        }\r\n        else\r\n        {\r\n            overlayContext.fillText(debugPhysics ? 'Debug Physics' : '', x, y += h);\r\n            overlayContext.fillText(debugParticles ? 'Debug Particles' : '', x, y += h);\r\n            overlayContext.fillText(debugRaycast ? 'Debug Raycasts' : '', x, y += h);\r\n            overlayContext.fillText(debugGamepads ? 'Debug Gamepads' : '', x, y += h);\r\n        }\r\n    \r\n        overlayContext.restore();\r\n    }\r\n}\n/**\r\n * LittleJS Utility Classes and Functions\r\n * - General purpose math library\r\n * - Vector2 - fast, simple, easy 2D vector class\r\n * - Color - holds a rgba color with some math functions\r\n * - Timer - tracks time automatically\r\n * - RandomGenerator - seeded random number generator\r\n * @namespace Utilities\r\n */\r\n\r\n\r\n\r\n/** A shortcut to get Math.PI\r\n *  @type {Number}\r\n *  @default Math.PI\r\n *  @memberof Utilities */\r\nconst PI = Math.PI;\r\n\r\n/** Returns absoulte value of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction abs(value) { return Math.abs(value); }\r\n\r\n/** Returns lowest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction min(valueA, valueB) { return Math.min(valueA, valueB); }\r\n\r\n/** Returns highest of two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction max(valueA, valueB) { return Math.max(valueA, valueB); }\r\n\r\n/** Returns the sign of value passed in\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction sign(value) { return Math.sign(value); }\r\n\r\n/** Returns first parm modulo the second param, but adjusted so negative numbers work as expected\r\n *  @param {Number} dividend\r\n *  @param {Number} [divisor]\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction mod(dividend, divisor=1) { return ((dividend % divisor) + divisor) % divisor; }\r\n\r\n/** Clamps the value beween max and min\r\n *  @param {Number} value\r\n *  @param {Number} [min]\r\n *  @param {Number} [max]\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction clamp(value, min=0, max=1) { return value < min ? min : value > max ? max : value; }\r\n\r\n/** Returns what percentage the value is between valueA and valueB\r\n *  @param {Number} value\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction percent(value, valueA, valueB)\r\n{ return (valueB-=valueA) ? clamp((value-valueA)/valueB) : 0; }\r\n\r\n/** Linearly interpolates between values passed in using percent\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction lerp(percent, valueA, valueB) { return valueA + clamp(percent) * (valueB-valueA); }\r\n\r\n/** Returns signed wrapped distance between the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction distanceWrap(valueA, valueB, wrapSize=1)\r\n{ const d = (valueA - valueB) % wrapSize; return d*2 % wrapSize - d; }\r\n\r\n/** Linearly interpolates between values passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} valueA\r\n *  @param {Number} valueB\r\n *  @param {Number} [wrapSize]\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction lerpWrap(percent, valueA, valueB, wrapSize=1)\r\n{ return valueB + clamp(percent) * distanceWrap(valueA, valueB, wrapSize); }\r\n\r\n/** Returns signed wrapped distance between the two angles passed in\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction distanceAngle(angleA, angleB) { return distanceWrap(angleA, angleB, 2*PI); }\r\n\r\n/** Linearly interpolates between the angles passed in with wrapping\r\n *  @param {Number} percent\r\n *  @param {Number} angleA\r\n *  @param {Number} angleB\r\n *  @returns {Number}\r\n *  @memberof Utilities */\r\nfunction lerpAngle(percent, angleA, angleB) { return lerpWrap(percent, angleA, angleB, 2*PI); }\r\n\r\n/** Applies smoothstep function to the percentage value\r\n *  @param {Number} percent\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction smoothStep(percent) { return percent * percent * (3 - 2 * percent); }\r\n\r\n/** Returns the nearest power of two not less then the value\r\n *  @param {Number} value\r\n *  @return {Number}\r\n *  @memberof Utilities */\r\nfunction nearestPowerOfTwo(value) { return 2**Math.ceil(Math.log2(value)); }\r\n\r\n/** Returns true if two axis aligned bounding boxes are overlapping \r\n *  @param {Vector2} posA          - Center of box A\r\n *  @param {Vector2} sizeA         - Size of box A\r\n *  @param {Vector2} posB          - Center of box B\r\n *  @param {Vector2} [sizeB=(0,0)] - Size of box B, a point if undefined\r\n *  @return {Boolean}              - True if overlapping\r\n *  @memberof Utilities */\r\nfunction isOverlapping(posA, sizeA, posB, sizeB=vec2())\r\n{ \r\n    return abs(posA.x - posB.x)*2 < sizeA.x + sizeB.x \r\n        && abs(posA.y - posB.y)*2 < sizeA.y + sizeB.y;\r\n}\r\n\r\n/** Returns true if a line segment is intersecting an axis aligned box\r\n *  @param {Vector2} start - Start of raycast\r\n *  @param {Vector2} end   - End of raycast\r\n *  @param {Vector2} pos   - Center of box\r\n *  @param {Vector2} size  - Size of box\r\n *  @return {Boolean}      - True if intersecting\r\n *  @memberof Utilities */\r\nfunction isIntersecting(start, end, pos, size)\r\n{\r\n    // Liang-Barsky algorithm\r\n    const boxMin = pos.subtract(size.scale(.5));\r\n    const boxMax = boxMin.add(size);\r\n    const delta = end.subtract(start);\r\n    const a = start.subtract(boxMin);\r\n    const b = start.subtract(boxMax);\r\n    const p = [-delta.x, delta.x, -delta.y, delta.y];\r\n    const q = [a.x, -b.x, a.y, -b.y];\r\n    let tMin = 0, tMax = 1;\r\n    for (let i = 4; i--;)\r\n    {\r\n        if (p[i])\r\n        {\r\n            const t = q[i] / p[i];\r\n            if (p[i] < 0)\r\n            {\r\n                if (t > tMax) return false;\r\n                tMin = max(t, tMin);\r\n            }\r\n            else\r\n            {\r\n                if (t < tMin) return false;\r\n                tMax = min(t, tMax);\r\n            }\r\n        }\r\n        else if (q[i] < 0)\r\n            return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/** Returns an oscillating wave between 0 and amplitude with frequency of 1 Hz by default\r\n *  @param {Number} [frequency] - Frequency of the wave in Hz\r\n *  @param {Number} [amplitude] - Amplitude (max height) of the wave\r\n *  @param {Number} [t=time]    - Value to use for time of the wave\r\n *  @return {Number}            - Value waving between 0 and amplitude\r\n *  @memberof Utilities */\r\nfunction wave(frequency=1, amplitude=1, t=time)\r\n{ return amplitude/2 * (1 - Math.cos(t*frequency*2*PI)); }\r\n\r\n/** Formats seconds to mm:ss style for display purposes \r\n *  @param {Number} t - time in seconds\r\n *  @return {String}\r\n *  @memberof Utilities */\r\nfunction formatTime(t) { return (t/60|0) + ':' + (t%60<10?'0':'') + (t%60|0); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Random global functions\r\n *  @namespace Random */\r\n\r\n/** Returns a random value between the two values passed in\r\n *  @param {Number} [valueA]\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction rand(valueA=1, valueB=0) { return valueB + Math.random() * (valueA-valueB); }\r\n\r\n/** Returns a floored random value the two values passed in\r\n *  @param {Number} valueA\r\n *  @param {Number} [valueB]\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction randInt(valueA, valueB=0) { return Math.floor(rand(valueA,valueB)); }\r\n\r\n/** Randomly returns either -1 or 1\r\n *  @return {Number}\r\n *  @memberof Random */\r\nfunction randSign() { return randInt(2) * 2 - 1; }\r\n\r\n/** Returns a random Vector2 with the passed in length\r\n *  @param {Number} [length]\r\n *  @return {Vector2}\r\n *  @memberof Random */\r\nfunction randVector(length=1) { return new Vector2().setAngle(rand(2*PI), length); }\r\n\r\n/** Returns a random Vector2 within a circular shape\r\n *  @param {Number} [radius]\r\n *  @param {Number} [minRadius]\r\n *  @return {Vector2}\r\n *  @memberof Random */\r\nfunction randInCircle(radius=1, minRadius=0)\r\n{ return radius > 0 ? randVector(radius * rand(minRadius / radius, 1)**.5) : new Vector2; }\r\n\r\n/** Returns a random color between the two passed in colors, combine components if linear\r\n *  @param {Color}   [colorA=(1,1,1,1)]\r\n *  @param {Color}   [colorB=(0,0,0,1)]\r\n *  @param {Boolean} [linear]\r\n *  @return {Color}\r\n *  @memberof Random */\r\nfunction randColor(colorA=new Color, colorB=new Color(0,0,0,1), linear=false)\r\n{\r\n    return linear ? colorA.lerp(colorB, rand()) : \r\n        new Color(rand(colorA.r,colorB.r), rand(colorA.g,colorB.g), rand(colorA.b,colorB.b), rand(colorA.a,colorB.a));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Seeded random number generator\r\n * - Can be used to create a deterministic random number sequence\r\n * @example\r\n * let r = new RandomGenerator(123); // random number generator with seed 123\r\n * let a = r.float();                // random value between 0 and 1\r\n * let b = r.int(10);                // random integer between 0 and 9\r\n * r.seed = 123;                     // reset the seed\r\n * let c = r.float();                // the same value as a\r\n */\r\nclass RandomGenerator\r\n{\r\n    /** Create a random number generator with the seed passed in\r\n     *  @param {Number} seed - Starting seed */\r\n    constructor(seed)\r\n    {\r\n        /** @property {Number} - random seed */\r\n        this.seed = seed;\r\n    }\r\n\r\n    /** Returns a seeded random value between the two values passed in\r\n    *  @param {Number} [valueA]\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */\r\n    float(valueA=1, valueB=0)\r\n    {\r\n        // xorshift algorithm\r\n        this.seed ^= this.seed << 13; \r\n        this.seed ^= this.seed >>> 17; \r\n        this.seed ^= this.seed << 5;\r\n        return valueB + (valueA - valueB) * abs(this.seed % 1e8) / 1e8;\r\n    }\r\n\r\n    /** Returns a floored seeded random value the two values passed in\r\n    *  @param {Number} valueA\r\n    *  @param {Number} [valueB]\r\n    *  @return {Number} */\r\n    int(valueA, valueB=0) { return Math.floor(this.float(valueA, valueB)); }\r\n\r\n    /** Randomly returns either -1 or 1 deterministically\r\n    *  @return {Number} */\r\n    sign() { return this.float() > .5 ? 1 : -1; }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a 2d vector, can take another Vector2 to copy, 2 scalars, or 1 scalar\r\n * @param {(Number|Vector2)} [x]\r\n * @param {Number} [y]\r\n * @return {Vector2}\r\n * @example\r\n * let a = vec2(0, 1); // vector with coordinates (0, 1)\r\n * let b = vec2(a);    // copy a into b\r\n * a = vec2(5);        // set a to (5, 5)\r\n * b = vec2();         // set b to (0, 0)\r\n * @memberof Utilities\r\n */\r\nfunction vec2(x=0, y)\r\n{\r\n    return typeof x == 'number' ? \r\n        new Vector2(x, y == undefined? x : y) : \r\n        new Vector2(x.x, x.y);\r\n}\r\n\r\n/** \r\n * Check if object is a valid Vector2\r\n * @param {any} v\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */\r\nfunction isVector2(v) { return v instanceof Vector2; }\r\n\r\n/** \r\n * 2D Vector object with vector math library\r\n * - Functions do not change this so they can be chained together\r\n * @example\r\n * let a = new Vector2(2, 3); // vector with coordinates (2, 3)\r\n * let b = new Vector2;       // vector with coordinates (0, 0)\r\n * let c = vec2(4, 2);        // use the vec2 function to make a Vector2\r\n * let d = a.add(b).scale(5); // operators can be chained\r\n */\r\nclass Vector2\r\n{\r\n    /** Create a 2D vector with the x and y passed in, can also be created with vec2()\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location */\r\n    constructor(x=0, y=0)\r\n    {\r\n        ASSERT(typeof x == 'number' && typeof y == 'number');\r\n        /** @property {Number} - X axis location */\r\n        this.x = x;\r\n        /** @property {Number} - Y axis location */\r\n        this.y = y;\r\n    }\r\n\r\n    /** Sets values of this vector and returns self\r\n     *  @param {Number} [x] - X axis location\r\n     *  @param {Number} [y] - Y axis location\r\n     *  @return {Vector2} */\r\n    set(x=0, y=0) { this.x=x; this.y=y; return this; }\r\n\r\n    /** Returns a new vector that is a copy of this\r\n     *  @return {Vector2} */\r\n    copy() { return new Vector2(this.x, this.y); }\r\n\r\n    /** Returns a copy of this vector plus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    add(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x + v.x, this.y + v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector minus the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    subtract(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x - v.x, this.y - v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector times the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    multiply(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x * v.x, this.y * v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector divided by the vector passed in\r\n     *  @param {Vector2} v - other vector\r\n     *  @return {Vector2} */\r\n    divide(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return new Vector2(this.x / v.x, this.y / v.y);\r\n    }\r\n\r\n    /** Returns a copy of this vector scaled by the vector passed in\r\n     *  @param {Number} s - scale\r\n     *  @return {Vector2} */\r\n    scale(s)\r\n    {\r\n        ASSERT(!isVector2(s));\r\n        return new Vector2(this.x * s, this.y * s);\r\n    }\r\n\r\n    /** Returns the length of this vector\r\n     * @return {Number} */\r\n    length() { return this.lengthSquared()**.5; }\r\n\r\n    /** Returns the length of this vector squared\r\n     * @return {Number} */\r\n    lengthSquared() { return this.x**2 + this.y**2; }\r\n\r\n    /** Returns the distance from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    distance(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.distanceSquared(v)**.5;\r\n    }\r\n\r\n    /** Returns the distance squared from this vector to vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    distanceSquared(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return (this.x - v.x)**2 + (this.y - v.y)**2;\r\n    }\r\n\r\n    /** Returns a new vector in same direction as this one with the length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    normalize(length=1)\r\n    {\r\n        const l = this.length();\r\n        return l ? this.scale(length/l) : new Vector2(0, length);\r\n    }\r\n\r\n    /** Returns a new vector clamped to length passed in\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    clampLength(length=1)\r\n    {\r\n        const l = this.length();\r\n        return l > length ? this.scale(length/l) : this;\r\n    }\r\n\r\n    /** Returns the dot product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    dot(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.x*v.x + this.y*v.y;\r\n    }\r\n\r\n    /** Returns the cross product of this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @return {Number} */\r\n    cross(v)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.x*v.y - this.y*v.x;\r\n    }\r\n\r\n    /** Returns the angle of this vector, up is angle 0\r\n     * @return {Number} */\r\n    angle() { return Math.atan2(this.x, this.y); }\r\n\r\n    /** Sets this vector with angle and length passed in\r\n     * @param {Number} [angle]\r\n     * @param {Number} [length]\r\n     * @return {Vector2} */\r\n    setAngle(angle=0, length=1) \r\n    {\r\n        this.x = length*Math.sin(angle);\r\n        this.y = length*Math.cos(angle);\r\n        return this;\r\n    }\r\n\r\n    /** Returns copy of this vector rotated by the angle passed in\r\n     * @param {Number} angle\r\n     * @return {Vector2} */\r\n    rotate(angle)\r\n    { \r\n        const c = Math.cos(angle), s = Math.sin(angle); \r\n        return new Vector2(this.x*c - this.y*s, this.x*s + this.y*c);\r\n    }\r\n\r\n    /** Set the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @param {Number} [direction]\r\n     * @param {Number} [length] */\r\n    setDirection(direction, length=1)\r\n    {\r\n        ASSERT(direction==0 || direction==1 || direction==2 || direction==3);\r\n        return vec2(direction%2 ? direction-1 ? -length : length : 0, \r\n            direction%2 ? 0 : direction ? -length : length);\r\n    }\r\n\r\n    /** Returns the integer direction of this vector, corrosponding to multiples of 90 degree rotation (0-3)\r\n     * @return {Number} */\r\n    direction()\r\n    { return abs(this.x) > abs(this.y) ? this.x < 0 ? 3 : 1 : this.y < 0 ? 2 : 0; }\r\n\r\n    /** Returns a copy of this vector that has been inverted\r\n     * @return {Vector2} */\r\n    invert() { return new Vector2(this.y, -this.x); }\r\n\r\n    /** Returns a copy of this vector with each axis floored\r\n     * @return {Vector2} */\r\n    floor() { return new Vector2(Math.floor(this.x), Math.floor(this.y)); }\r\n\r\n    /** Returns the area this vector covers as a rectangle\r\n     * @return {Number} */\r\n    area() { return abs(this.x * this.y); }\r\n\r\n    /** Returns a new vector that is p percent between this and the vector passed in\r\n     * @param {Vector2} v - other vector\r\n     * @param {Number}  percent\r\n     * @return {Vector2} */\r\n    lerp(v, percent)\r\n    {\r\n        ASSERT(isVector2(v));\r\n        return this.add(v.subtract(this).scale(clamp(percent)));\r\n    }\r\n\r\n    /** Returns true if this vector is within the bounds of an array size passed in\r\n     * @param {Vector2} arraySize\r\n     * @return {Boolean} */\r\n    arrayCheck(arraySize)\r\n    {\r\n        ASSERT(isVector2(arraySize));\r\n        return this.x >= 0 && this.y >= 0 && this.x < arraySize.x && this.y < arraySize.y;\r\n    }\r\n\r\n    /** Returns this vector expressed as a string\r\n     * @param {Number} digits - precision to display\r\n     * @return {String} */\r\n    toString(digits=3) \r\n    {\r\n        if (debug)\r\n            return `(${(this.x<0?'':' ') + this.x.toFixed(digits)},${(this.y<0?'':' ') + this.y.toFixed(digits)} )`;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a color object with RGBA values, white by default\r\n * @param {Number} [r=1] - red\r\n * @param {Number} [g=1] - green\r\n * @param {Number} [b=1] - blue\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */\r\nfunction rgb(r, g, b, a) { return new Color(r, g, b, a); }\r\n\r\n/** \r\n * Create a color object with HSLA values, white by default\r\n * @param {Number} [h=0] - hue\r\n * @param {Number} [s=0] - saturation\r\n * @param {Number} [l=1] - lightness\r\n * @param {Number} [a=1] - alpha\r\n * @return {Color}\r\n * @memberof Utilities\r\n */\r\nfunction hsl(h, s, l, a) { return new Color().setHSLA(h, s, l, a); }\r\n\r\n/** \r\n * Check if object is a valid Color\r\n * @param {any} c\r\n * @return {Boolean}\r\n * @memberof Utilities\r\n */\r\nfunction isColor(c) { return c instanceof Color; }\r\n\r\n/** \r\n * Color object (red, green, blue, alpha) with some helpful functions\r\n * @example\r\n * let a = new Color;              // white\r\n * let b = new Color(1, 0, 0);     // red\r\n * let c = new Color(0, 0, 0, 0);  // transparent black\r\n * let d = rgb(0, 0, 1);           // blue using rgb color\r\n * let e = hsl(.3, 1, .5);         // green using hsl color\r\n */\r\nclass Color\r\n{\r\n    /** Create a color with the rgba components passed in, white by default\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha*/\r\n    constructor(r=1, g=1, b=1, a=1)\r\n    {\r\n        /** @property {Number} - Red */\r\n        this.r = r;\r\n        /** @property {Number} - Green */\r\n        this.g = g;\r\n        /** @property {Number} - Blue */\r\n        this.b = b;\r\n        /** @property {Number} - Alpha */\r\n        this.a = a;\r\n    }\r\n\r\n    /** Sets values of this color and returns self\r\n     *  @param {Number} [r] - red\r\n     *  @param {Number} [g] - green\r\n     *  @param {Number} [b] - blue\r\n     *  @param {Number} [a] - alpha\r\n     *  @return {Color} */\r\n    set(r=1, g=1, b=1, a=1)\r\n    { this.r=r; this.g=g; this.b=b; this.a=a; return this; }\r\n\r\n    /** Returns a new color that is a copy of this\r\n     * @return {Color} */\r\n    copy() { return new Color(this.r, this.g, this.b, this.a); }\r\n\r\n    /** Returns a copy of this color plus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    add(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r+c.r, this.g+c.g, this.b+c.b, this.a+c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color minus the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    subtract(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r-c.r, this.g-c.g, this.b-c.b, this.a-c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color times the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    multiply(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r*c.r, this.g*c.g, this.b*c.b, this.a*c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color divided by the color passed in\r\n     * @param {Color} c - other color\r\n     * @return {Color} */\r\n    divide(c)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return new Color(this.r/c.r, this.g/c.g, this.b/c.b, this.a/c.a);\r\n    }\r\n\r\n    /** Returns a copy of this color scaled by the value passed in, alpha can be scaled separately\r\n     * @param {Number} scale\r\n     * @param {Number} [alphaScale=scale]\r\n     * @return {Color} */\r\n    scale(scale, alphaScale=scale) \r\n    { return new Color(this.r*scale, this.g*scale, this.b*scale, this.a*alphaScale); }\r\n\r\n    /** Returns a copy of this color clamped to the valid range between 0 and 1\r\n     * @return {Color} */\r\n    clamp() { return new Color(clamp(this.r), clamp(this.g), clamp(this.b), clamp(this.a)); }\r\n\r\n    /** Returns a new color that is p percent between this and the color passed in\r\n     * @param {Color}  c - other color\r\n     * @param {Number} percent\r\n     * @return {Color} */\r\n    lerp(c, percent)\r\n    {\r\n        ASSERT(isColor(c));\r\n        return this.add(c.subtract(this).scale(clamp(percent)));\r\n    }\r\n\r\n    /** Sets this color given a hue, saturation, lightness, and alpha\r\n     * @param {Number} [h] - hue\r\n     * @param {Number} [s] - saturation\r\n     * @param {Number} [l] - lightness\r\n     * @param {Number} [a] - alpha\r\n     * @return {Color} */\r\n    setHSLA(h=0, s=0, l=1, a=1)\r\n    {\r\n        h = mod(h,1);\r\n        s = clamp(s);\r\n        l = clamp(l);\r\n        const q = l < .5 ? l*(1+s) : l+s-l*s, p = 2*l-q,\r\n            f = (p, q, t)=>\r\n                (t = mod(t,1))*6 < 1 ? p+(q-p)*6*t :\r\n                t*2 < 1 ? q :\r\n                t*3 < 2 ? p+(q-p)*(4-t*6) : p;\r\n        this.r = f(p, q, h + 1/3);\r\n        this.g = f(p, q, h);\r\n        this.b = f(p, q, h - 1/3);\r\n        this.a = a;\r\n        return this;\r\n    }\r\n\r\n    /** Returns this color expressed in hsla format\r\n     * @return {Array} */\r\n    HSLA()\r\n    {\r\n        const r = clamp(this.r);\r\n        const g = clamp(this.g);\r\n        const b = clamp(this.b);\r\n        const a = clamp(this.a);\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        const l = (max + min) / 2;\r\n        \r\n        let h = 0, s = 0;\r\n        if (max != min)\r\n        {\r\n            let d = max - min;\r\n            s = l > .5 ? d / (2 - max - min) : d / (max + min);\r\n            if (r == max)\r\n                h = (g - b) / d + (g < b ? 6 : 0);\r\n            else if (g == max)\r\n                h = (b - r) / d + 2;\r\n            else if (b == max)\r\n                h =  (r - g) / d + 4;\r\n        }\r\n\r\n        return [h / 6, s, l, a];\r\n    }\r\n\r\n    /** Returns a new color that has each component randomly adjusted\r\n     * @param {Number} [amount]\r\n     * @param {Number} [alphaAmount]\r\n     * @return {Color} */\r\n    mutate(amount=.05, alphaAmount=0) \r\n    {\r\n        return new Color\r\n        (\r\n            this.r + rand(amount, -amount),\r\n            this.g + rand(amount, -amount),\r\n            this.b + rand(amount, -amount),\r\n            this.a + rand(alphaAmount, -alphaAmount)\r\n        ).clamp();\r\n    }\r\n\r\n    /** Returns this color expressed as a hex color code\r\n     * @param {Boolean} [useAlpha] - if alpha should be included in result\r\n     * @return {String} */\r\n    toString(useAlpha = true)      \r\n    { \r\n        const toHex = (c)=> ((c=c*255|0)<16 ? '0' : '') + c.toString(16);\r\n        return '#' + toHex(this.r) + toHex(this.g) + toHex(this.b) + (useAlpha ? toHex(this.a) : '');\r\n    }\r\n    \r\n    /** Set this color from a hex code\r\n     * @param {String} hex - html hex code\r\n     * @return {Color} */\r\n    setHex(hex)\r\n    {\r\n        const fromHex = (c)=> clamp(parseInt(hex.slice(c,c+2),16)/255);\r\n        this.r = fromHex(1);\r\n        this.g = fromHex(3),\r\n        this.b = fromHex(5);\r\n        this.a = hex.length > 7 ? fromHex(7) : 1;\r\n        return this;\r\n    }\r\n    \r\n    /** Returns this color expressed as 32 bit RGBA value\r\n     * @return {Number} */\r\n    rgbaInt()  \r\n    {\r\n        const r = clamp(this.r)*255|0;\r\n        const g = clamp(this.g)*255<<8;\r\n        const b = clamp(this.b)*255<<16;\r\n        const a = clamp(this.a)*255<<24;\r\n        return r + g + b + a;\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// default colors\r\n\r\n/** Color - White\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst WHITE = rgb();\r\n\r\n/** Color - Black\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst BLACK = rgb(0,0,0);\r\n\r\n/** Color - Gray\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst GRAY = rgb(.5,.5,.5);\r\n\r\n/** Color - Red\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst RED = rgb(1,0,0);\r\n\r\n/** Color - Orange\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst ORANGE = rgb(1,.5,0);\r\n\r\n/** Color - Yellow\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst YELLOW = rgb(1,1,0);\r\n\r\n/** Color - Green\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst GREEN = rgb(0,1,0);\r\n\r\n/** Color - Cyan\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst CYAN = rgb(0,1,1);\r\n\r\n/** Color - Blue\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst BLUE = rgb(0,0,1);\r\n\r\n/** Color - Purple\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst PURPLE = rgb(.5,0,1);\r\n\r\n/** Color - Magenta\r\n *  @type {Color}\r\n *  @memberof Utilities */\r\nconst MAGENTA = rgb(1,0,1);\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Timer object tracks how long has passed since it was set\r\n * @example\r\n * let a = new Timer;    // creates a timer that is not set\r\n * a.set(3);             // sets the timer to 3 seconds\r\n *\r\n * let b = new Timer(1); // creates a timer with 1 second left\r\n * b.unset();            // unsets the timer\r\n */\r\nclass Timer\r\n{\r\n    /** Create a timer object set time passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer elapses in seconds */\r\n    constructor(timeLeft) { this.time = timeLeft == undefined ? undefined : time + timeLeft; this.setTime = timeLeft; }\r\n\r\n    /** Set the timer with seconds passed in\r\n     *  @param {Number} [timeLeft] - How much time left before the timer is elapsed in seconds */\r\n    set(timeLeft=0) { this.time = time + timeLeft; this.setTime = timeLeft; }\r\n\r\n    /** Unset the timer */\r\n    unset() { this.time = undefined; }\r\n\r\n    /** Returns true if set\r\n     * @return {Boolean} */\r\n    isSet() { return this.time != undefined; }\r\n\r\n    /** Returns true if set and has not elapsed\r\n     * @return {Boolean} */\r\n    active() { return time < this.time; }\r\n\r\n    /** Returns true if set and elapsed\r\n     * @return {Boolean} */\r\n    elapsed() { return time >= this.time; }\r\n\r\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */\r\n    get() { return this.isSet()? time - this.time : 0; }\r\n\r\n    /** Get percentage elapsed based on time it was set to, returns 0 if not set\r\n     * @return {Number} */\r\n    getPercent() { return this.isSet()? percent(this.time - time, this.setTime, 0) : 0; }\r\n    \r\n    /** Returns this timer expressed as a string\r\n     * @return {String} */\r\n    toString() { if (debug) { return this.isSet() ? Math.abs(this.get()) + ' seconds ' + (this.get()<0 ? 'before' : 'after' ) : 'unset'; }}\r\n    \r\n    /** Get how long since elapsed, returns 0 if not set (returns negative if currently active)\r\n     * @return {Number} */\r\n    valueOf()               { return this.get(); }\r\n}\n/**\r\n * LittleJS Engine Settings\r\n * - All settings for the engine are here\r\n * @namespace Settings\r\n */\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Camera settings\r\n\r\n/** Position of camera in world space\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */\r\nlet cameraPos = vec2();\r\n\r\n/** Scale of camera in world space\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet cameraScale = 32;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Display settings\r\n\r\n/** The max size of the canvas, centered if window is larger\r\n *  @type {Vector2}\r\n *  @default Vector2(1920,1080)\r\n *  @memberof Settings */\r\nlet canvasMaxSize = vec2(1920, 1080);\r\n\r\n/** Fixed size of the canvas, if enabled canvas size never changes\r\n * - you may also need to set mainCanvasSize if using screen space coords in startup\r\n *  @type {Vector2}\r\n *  @default Vector2()\r\n *  @memberof Settings */\r\nlet canvasFixedSize = vec2();\r\n\r\n/** Disables filtering for crisper pixel art if true\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet canvasPixelated = true;\r\n\r\n/** Default font used for text rendering\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Settings */\r\nlet fontDefault = 'arial';\r\n\r\n/** Enable to show the LittleJS splash screen be shown on startup\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet showSplashScreen = false;\r\n\r\n/** Disables all rendering, audio, and input for servers\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet headlessMode = false;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// WebGL settings\r\n\r\n/** Enable webgl rendering, webgl can be disabled and removed from build (with some features disabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet glEnable = true;\r\n\r\n/** Fixes slow rendering in some browsers by not compositing the WebGL canvas\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet glOverlay = true;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Tile sheet settings\r\n\r\n/** Default size of tiles in pixels\r\n *  @type {Vector2}\r\n *  @default Vector2(16,16)\r\n *  @memberof Settings */\r\nlet tileSizeDefault = vec2(16);\r\n\r\n/** How many pixels smaller to draw tiles to prevent bleeding from neighbors\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet tileFixBleedScale = .5;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Object settings\r\n\r\n/** Enable physics solver for collisions between objects\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet enablePhysicsSolver = true;\r\n\r\n/** Default object mass for collision calcuations (how heavy objects are)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultMass = 1;\r\n\r\n/** How much to slow velocity by each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultDamping = 1;\r\n\r\n/** How much to slow angular velocity each frame (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultAngleDamping = 1;\r\n\r\n/** How much to bounce when a collision occurs (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultElasticity = 0;\r\n\r\n/** How much to slow when touching (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectDefaultFriction = .8;\r\n\r\n/** Clamp max speed to avoid fast objects missing collisions\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet objectMaxSpeed = 1;\r\n\r\n/** How much gravity to apply to objects along the Y axis, negative is down\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gravity = 0;\r\n\r\n/** Scales emit rate of particles, useful for low graphics mode (0 disables particle emitters)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet particleEmitRateScale = 1;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input settings\r\n\r\n/** Should gamepads be allowed\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gamepadsEnable = true;\r\n\r\n/** If true, the dpad input is also routed to the left analog stick (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet gamepadDirectionEmulateStick = true;\r\n\r\n/** If true the WASD keys are also routed to the direction keys (for better accessability)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet inputWASDEmulateDirection = true;\r\n\r\n/** True if touch input is enabled for mobile devices\r\n *  - Touch events will be routed to mouse events\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchInputEnable = true;\r\n\r\n/** True if touch gamepad should appear on mobile devices\r\n *  - Supports left analog stick, 4 face buttons and start button (button 9)\r\n *  - Must be set by end of gameInit to be activated\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadEnable = false;\r\n\r\n/** True if touch gamepad should be analog stick or false to use if 8 way dpad\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadAnalog = true;\r\n\r\n/** Size of virtual gamepad for touch devices in pixels\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadSize = 99;\r\n\r\n/** Transparency of touch gamepad overlay\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet touchGamepadAlpha = .3;\r\n\r\n/** Allow vibration hardware if it exists\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet vibrateEnable = true;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Audio settings\r\n\r\n/** All audio code can be disabled and removed from build\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundEnable = true;\r\n\r\n/** Volume scale to apply to all sound, music and speech\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundVolume = .3;\r\n\r\n/** Default range where sound no longer plays\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundDefaultRange = 40;\r\n\r\n/** Default range percent to start tapering off sound (0-1)\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet soundDefaultTaper = .7;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Medals settings\r\n\r\n/** How long to show medals for in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplayTime = 5;\r\n\r\n/** How quickly to slide on/off medals in seconds\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplaySlideTime = .5;\r\n\r\n/** Size of medal display\r\n *  @type {Vector2}\r\n *  @default Vector2(640,80)\r\n *  @memberof Settings */\r\nlet medalDisplaySize = vec2(640, 80);\r\n\r\n/** Size of icon in medal display\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalDisplayIconSize = 50;\r\n\r\n/** Set to stop medals from being unlockable (like if cheats are enabled)\r\n *  @type {Boolean}\r\n *  @default\r\n *  @memberof Settings */\r\nlet medalsPreventUnlock = false;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Setters for global variables\r\n\r\n/** Set position of camera in world space\r\n *  @param {Vector2} pos\r\n *  @memberof Settings */\r\nfunction setCameraPos(pos) { cameraPos = pos; }\r\n\r\n/** Set scale of camera in world space\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setCameraScale(scale) { cameraScale = scale; }\r\n\r\n/** Set max size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setCanvasMaxSize(size) { canvasMaxSize = size; }\r\n\r\n/** Set fixed size of the canvas\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setCanvasFixedSize(size) { canvasFixedSize = size; }\r\n\r\n/** Disables anti aliasing for pixel art if true\r\n *  @param {Boolean} pixelated\r\n *  @memberof Settings */\r\nfunction setCanvasPixelated(pixelated) { canvasPixelated = pixelated; }\r\n\r\n/** Set default font used for text rendering\r\n *  @param {String} font\r\n *  @memberof Settings */\r\nfunction setFontDefault(font) { fontDefault = font; }\r\n\r\n/** Set if the LittleJS splash screen be shown on startup\r\n *  @param {Boolean} show\r\n *  @memberof Settings */\r\nfunction setShowSplashScreen(show) { showSplashScreen = show; }\r\n\r\n/** Set to disalbe rendering, audio, and input for servers\r\n *  @param {Boolean} headless\r\n *  @memberof Settings */\r\nfunction setHeadlessMode(headless) { headlessMode = headless; }\r\n\r\n/** Set if webgl rendering is enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGlEnable(enable) { glEnable = enable; }\r\n\r\n/** Set to not composite the WebGL canvas\r\n *  @param {Boolean} overlay\r\n *  @memberof Settings */\r\nfunction setGlOverlay(overlay) { glOverlay = overlay; }\r\n\r\n/** Set default size of tiles in pixels\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setTileSizeDefault(size) { tileSizeDefault = size; }\r\n\r\n/** Set to prevent tile bleeding from neighbors in pixels\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setTileFixBleedScale(scale) { tileFixBleedScale = scale; }\r\n\r\n/** Set if collisions between objects are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setEnablePhysicsSolver(enable) { enablePhysicsSolver = enable; }\r\n\r\n/** Set default object mass for collison calcuations\r\n *  @param {Number} mass\r\n *  @memberof Settings */\r\nfunction setObjectDefaultMass(mass) { objectDefaultMass = mass; }\r\n\r\n/** Set how much to slow velocity by each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */\r\nfunction setObjectDefaultDamping(damp) { objectDefaultDamping = damp; }\r\n\r\n/** Set how much to slow angular velocity each frame\r\n *  @param {Number} damp\r\n *  @memberof Settings */\r\nfunction setObjectDefaultAngleDamping(damp) { objectDefaultAngleDamping = damp; }\r\n\r\n/** Set how much to bounce when a collision occur\r\n *  @param {Number} elasticity\r\n *  @memberof Settings */\r\nfunction setObjectDefaultElasticity(elasticity) { objectDefaultElasticity = elasticity; }\r\n\r\n/** Set how much to slow when touching\r\n *  @param {Number} friction\r\n *  @memberof Settings */\r\nfunction setObjectDefaultFriction(friction) { objectDefaultFriction = friction; }\r\n\r\n/** Set max speed to avoid fast objects missing collisions\r\n *  @param {Number} speed\r\n *  @memberof Settings */\r\nfunction setObjectMaxSpeed(speed) { objectMaxSpeed = speed; }\r\n\r\n/** Set how much gravity to apply to objects along the Y axis\r\n *  @param {Number} newGravity\r\n *  @memberof Settings */\r\nfunction setGravity(newGravity) { gravity = newGravity; }\r\n\r\n/** Set to scales emit rate of particles\r\n *  @param {Number} scale\r\n *  @memberof Settings */\r\nfunction setParticleEmitRateScale(scale) { particleEmitRateScale = scale; }\r\n\r\n/** Set if gamepads are enabled\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGamepadsEnable(enable) { gamepadsEnable = enable; }\r\n\r\n/** Set if the dpad input is also routed to the left analog stick\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setGamepadDirectionEmulateStick(enable) { gamepadDirectionEmulateStick = enable; }\r\n\r\n/** Set if true the WASD keys are also routed to the direction keys\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setInputWASDEmulateDirection(enable) { inputWASDEmulateDirection = enable; }\r\n\r\n/** Set if touch input is allowed\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setTouchInputEnable(enable) { touchInputEnable = enable; }\r\n\r\n/** Set if touch gamepad should appear on mobile devices\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setTouchGamepadEnable(enable) { touchGamepadEnable = enable; }\r\n\r\n/** Set if touch gamepad should be analog stick or 8 way dpad\r\n *  @param {Boolean} analog\r\n *  @memberof Settings */\r\nfunction setTouchGamepadAnalog(analog) { touchGamepadAnalog = analog; }\r\n\r\n/** Set size of virutal gamepad for touch devices in pixels\r\n *  @param {Number} size\r\n *  @memberof Settings */\r\nfunction setTouchGamepadSize(size) { touchGamepadSize = size; }\r\n\r\n/** Set transparency of touch gamepad overlay\r\n *  @param {Number} alpha\r\n *  @memberof Settings */\r\nfunction setTouchGamepadAlpha(alpha) { touchGamepadAlpha = alpha; }\r\n\r\n/** Set to allow vibration hardware if it exists\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setVibrateEnable(enable) { vibrateEnable = enable; }\r\n\r\n/** Set to disable all audio code\r\n *  @param {Boolean} enable\r\n *  @memberof Settings */\r\nfunction setSoundEnable(enable) { soundEnable = enable; }\r\n\r\n/** Set volume scale to apply to all sound, music and speech\r\n *  @param {Number} volume\r\n *  @memberof Settings */\r\nfunction setSoundVolume(volume)\r\n{\r\n    soundVolume = volume;\r\n    if (soundEnable && !headlessMode && audioGainNode)\r\n        audioGainNode.gain.value = volume; // update gain immediatly\r\n}\r\n\r\n/** Set default range where sound no longer plays\r\n *  @param {Number} range\r\n *  @memberof Settings */\r\nfunction setSoundDefaultRange(range) { soundDefaultRange = range; }\r\n\r\n/** Set default range percent to start tapering off sound\r\n *  @param {Number} taper\r\n *  @memberof Settings */\r\nfunction setSoundDefaultTaper(taper) { soundDefaultTaper = taper; }\r\n\r\n/** Set how long to show medals for in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */\r\nfunction setMedalDisplayTime(time) { medalDisplayTime = time; }\r\n\r\n/** Set how quickly to slide on/off medals in seconds\r\n *  @param {Number} time\r\n *  @memberof Settings */\r\nfunction setMedalDisplaySlideTime(time) { medalDisplaySlideTime = time; }\r\n\r\n/** Set size of medal display\r\n *  @param {Vector2} size\r\n *  @memberof Settings */\r\nfunction setMedalDisplaySize(size) { medalDisplaySize = size; }\r\n\r\n/** Set size of icon in medal display\r\n *  @param {Number} size\r\n *  @memberof Settings */\r\nfunction setMedalDisplayIconSize(size) { medalDisplayIconSize = size; }\r\n\r\n/** Set to stop medals from being unlockable\r\n *  @param {Boolean} preventUnlock\r\n *  @memberof Settings */\r\nfunction setMedalsPreventUnlock(preventUnlock) { medalsPreventUnlock = preventUnlock; }\r\n\r\n/** Set if watermark with FPS should be shown\r\n *  @param {Boolean} show\r\n *  @memberof Debug */\r\nfunction setShowWatermark(show) { showWatermark = show; }\r\n\r\n/** Set key code used to toggle debug mode, Esc by default\r\n *  @param {String} key\r\n *  @memberof Debug */\r\nfunction setDebugKey(key) { debugKey = key; }\n/** \r\n * LittleJS Object System\r\n */\r\n\r\n\r\n\r\n/** \r\n * LittleJS Object Base Object Class\r\n * - Top level object class used by the engine\r\n * - Automatically adds self to object list\r\n * - Will be updated and rendered each frame\r\n * - Renders as a sprite from a tilesheet by default\r\n * - Can have color and additive color applied\r\n * - 2D Physics and collision system\r\n * - Sorted by renderOrder\r\n * - Objects can have children attached\r\n * - Parents are updated before children, and set child transform\r\n * - Call destroy() to get rid of objects\r\n *\r\n * The physics system used by objects is simple and fast with some caveats...\r\n * - Collision uses the axis aligned size, the object's rotation angle is only for rendering\r\n * - Objects are guaranteed to not intersect tile collision from physics\r\n * - If an object starts or is moved inside tile collision, it will not collide with that tile\r\n * - Collision for objects can be set to be solid to block other objects\r\n * - Objects may get pushed into overlapping other solid objects, if so they will push away\r\n * - Solid objects are more performance intensive and should be used sparingly\r\n * @example\r\n * // create an engine object, normally you would first extend the class with your own\r\n * const pos = vec2(2,3);\r\n * const object = new EngineObject(pos); \r\n */\r\nclass EngineObject\r\n{\r\n    /** Create an engine object and adds it to the list of objects\r\n     *  @param {Vector2}  [pos=(0,0)]       - World space position of the object\r\n     *  @param {Vector2}  [size=(1,1)]      - World space size of the object\r\n     *  @param {TileInfo} [tileInfo]        - Tile info to render object (undefined is untextured)\r\n     *  @param {Number}   [angle]           - Angle the object is rotated by\r\n     *  @param {Color}    [color=(1,1,1,1)] - Color to apply to tile when rendered\r\n     *  @param {Number}   [renderOrder]     - Objects sorted by renderOrder before being rendered\r\n     */\r\n    constructor(pos=vec2(), size=vec2(1), tileInfo, angle=0, color, renderOrder=0)\r\n    {\r\n        // set passed in params\r\n        ASSERT(isVector2(pos) && isVector2(size), 'ensure pos and size are vec2s');\r\n        ASSERT(typeof tileInfo !== 'number' || !tileInfo, 'old style tile setup');\r\n\r\n        /** @property {Vector2} - World space position of the object */\r\n        this.pos = pos.copy();\r\n        /** @property {Vector2} - World space width and height of the object */\r\n        this.size = size;\r\n        /** @property {Vector2} - Size of object used for drawing, uses size if not set */\r\n        this.drawSize = undefined;\r\n        /** @property {TileInfo} - Tile info to render object (undefined is untextured) */\r\n        this.tileInfo = tileInfo;\r\n        /** @property {Number}  - Angle to rotate the object */\r\n        this.angle = angle;\r\n        /** @property {Color}   - Color to apply when rendered */\r\n        this.color = color;\r\n        /** @property {Color}   - Additive color to apply when rendered */\r\n        this.additiveColor = undefined;\r\n        /** @property {Boolean} - Should it flip along y axis when rendered */\r\n        this.mirror = false;\r\n\r\n        // physical properties\r\n        /** @property {Number} [mass=objectDefaultMass]                 - How heavy the object is, static if 0 */\r\n        this.mass         = objectDefaultMass;\r\n        /** @property {Number} [damping=objectDefaultDamping]           - How much to slow down velocity each frame (0-1) */\r\n        this.damping      = objectDefaultDamping;\r\n        /** @property {Number} [angleDamping=objectDefaultAngleDamping] - How much to slow down rotation each frame (0-1) */\r\n        this.angleDamping = objectDefaultAngleDamping;\r\n        /** @property {Number} [elasticity=objectDefaultElasticity]     - How bouncy the object is when colliding (0-1) */\r\n        this.elasticity   = objectDefaultElasticity;\r\n        /** @property {Number} [friction=objectDefaultFriction]         - How much friction to apply when sliding (0-1) */\r\n        this.friction     = objectDefaultFriction;\r\n        /** @property {Number}  - How much to scale gravity by for this object */\r\n        this.gravityScale = 1;\r\n        /** @property {Number}  - Objects are sorted by render order */\r\n        this.renderOrder = renderOrder;\r\n        /** @property {Vector2} - Velocity of the object */\r\n        this.velocity = vec2();\r\n        /** @property {Number}  - Angular velocity of the object */\r\n        this.angleVelocity = 0;\r\n        /** @property {Number}  - Track when object was created  */\r\n        this.spawnTime = time;\r\n        /** @property {Array}   - List of children of this object */\r\n        this.children = [];\r\n        /** @property {Boolean}  - Limit object speed using linear or circular math */\r\n        this.clampSpeedLinear = true;\r\n\r\n        // parent child system\r\n        /** @property {EngineObject} - Parent of object if in local space  */\r\n        this.parent = undefined;\r\n        /** @property {Vector2}      - Local position if child */\r\n        this.localPos = vec2();\r\n        /** @property {Number}       - Local angle if child  */\r\n        this.localAngle = 0;\r\n\r\n        // collision flags\r\n        /** @property {Boolean} - Object collides with the tile collision */\r\n        this.collideTiles = false;\r\n        /** @property {Boolean} - Object collides with solid objects */\r\n        this.collideSolidObjects = false;\r\n        /** @property {Boolean} - Object collides with and blocks other objects */\r\n        this.isSolid = false;\r\n        /** @property {Boolean} - Object collides with raycasts */\r\n        this.collideRaycast = false;\r\n\r\n        // add to list of objects\r\n        engineObjects.push(this);\r\n    }\r\n    \r\n    /** Update the object transform, called automatically by engine even when paused */\r\n    updateTransforms()\r\n    {\r\n        const parent = this.parent;\r\n        if (parent)\r\n        {\r\n            // copy parent pos/angle\r\n            const mirror = parent.getMirrorSign();\r\n            this.pos = this.localPos.multiply(vec2(mirror,1)).rotate(-parent.angle).add(parent.pos);\r\n            this.angle = mirror*this.localAngle + parent.angle;\r\n        }\r\n\r\n        // update children\r\n        for (const child of this.children)\r\n            child.updateTransforms();\r\n    }\r\n\r\n    /** Update the object physics, called automatically by engine once each frame */\r\n    update()\r\n    {\r\n        // child objects do not have physics\r\n        if (this.parent)\r\n            return;\r\n\r\n        // limit max speed to prevent missing collisions\r\n        if (this.clampSpeedLinear)\r\n        {\r\n            this.velocity.x = clamp(this.velocity.x, -objectMaxSpeed, objectMaxSpeed);\r\n            this.velocity.y = clamp(this.velocity.y, -objectMaxSpeed, objectMaxSpeed);\r\n        }\r\n        else\r\n        {\r\n            const length2 = this.velocity.lengthSquared();\r\n            if (length2 > objectMaxSpeed*objectMaxSpeed)\r\n            {\r\n                const s = objectMaxSpeed / length2**.5;\r\n                this.velocity.x *= s;\r\n                this.velocity.y *= s;\r\n            }\r\n        }\r\n\r\n        // apply physics\r\n        const oldPos = this.pos.copy();\r\n        this.velocity.y += gravity * this.gravityScale;\r\n        this.pos.x += this.velocity.x *= this.damping;\r\n        this.pos.y += this.velocity.y *= this.damping;\r\n        this.angle += this.angleVelocity *= this.angleDamping;\r\n\r\n        // physics sanity checks\r\n        ASSERT(this.angleDamping >= 0 && this.angleDamping <= 1);\r\n        ASSERT(this.damping >= 0 && this.damping <= 1);\r\n        if (!enablePhysicsSolver || !this.mass) // dont do collision for fixed objects\r\n            return;\r\n\r\n        const wasMovingDown = this.velocity.y < 0;\r\n        if (this.groundObject)\r\n        {\r\n            // apply friction in local space of ground object\r\n            const groundSpeed = this.groundObject.velocity ? this.groundObject.velocity.x : 0;\r\n            this.velocity.x = groundSpeed + (this.velocity.x - groundSpeed) * this.friction;\r\n            this.groundObject = 0;\r\n            //debugOverlay && debugPhysics && debugPoint(this.pos.subtract(vec2(0,this.size.y/2)), '#0f0');\r\n        }\r\n\r\n        if (this.collideSolidObjects)\r\n        {\r\n            // check collisions against solid objects\r\n            const epsilon = .001; // necessary to push slightly outside of the collision\r\n            for (const o of engineObjectsCollide)\r\n            {\r\n                // non solid objects don't collide with eachother\r\n                if (!this.isSolid && !o.isSolid || o.destroyed || o.parent || o == this)\r\n                    continue;\r\n\r\n                // check collision\r\n                if (!isOverlapping(this.pos, this.size, o.pos, o.size))\r\n                    continue;\r\n\r\n                // notify objects of collision and check if should be resolved\r\n                const collide1 = this.collideWithObject(o);\r\n                const collide2 = o.collideWithObject(this);\r\n                if (!collide1 || !collide2)\r\n                    continue;\r\n\r\n                if (isOverlapping(oldPos, this.size, o.pos, o.size))\r\n                {\r\n                    // if already was touching, try to push away\r\n                    const deltaPos = oldPos.subtract(o.pos);\r\n                    const length = deltaPos.length();\r\n                    const pushAwayAccel = .001; // push away if already overlapping\r\n                    const velocity = length < .01 ? randVector(pushAwayAccel) : deltaPos.scale(pushAwayAccel/length);\r\n                    this.velocity = this.velocity.add(velocity);\r\n                    if (o.mass) // push away if not fixed\r\n                        o.velocity = o.velocity.subtract(velocity);\r\n                        \r\n                    debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, '#f00');\r\n                    continue;\r\n                }\r\n\r\n                // check for collision\r\n                const sizeBoth = this.size.add(o.size);\r\n                const smallStepUp = (oldPos.y - o.pos.y)*2 > sizeBoth.y + gravity; // prefer to push up if small delta\r\n                const isBlockedX = abs(oldPos.y - o.pos.y)*2 < sizeBoth.y;\r\n                const isBlockedY = abs(oldPos.x - o.pos.x)*2 < sizeBoth.x;\r\n                const elasticity = max(this.elasticity, o.elasticity);\r\n                \r\n                if (smallStepUp || isBlockedY || !isBlockedX) // resolve y collision\r\n                {\r\n                    // push outside object collision\r\n                    this.pos.y = o.pos.y + (sizeBoth.y/2 + epsilon) * sign(oldPos.y - o.pos.y);\r\n                    if (o.groundObject && wasMovingDown || !o.mass)\r\n                    {\r\n                        // set ground object if landed on something\r\n                        if (wasMovingDown)\r\n                            this.groundObject = o;\r\n\r\n                        // bounce if other object is fixed or grounded\r\n                        this.velocity.y *= -elasticity;\r\n                    }\r\n                    else if (o.mass)\r\n                    {\r\n                        // inelastic collision\r\n                        const inelastic = (this.mass * this.velocity.y + o.mass * o.velocity.y) / (this.mass + o.mass);\r\n\r\n                        // elastic collision\r\n                        const elastic0 = this.velocity.y * (this.mass - o.mass) / (this.mass + o.mass)\r\n                            + o.velocity.y * 2 * o.mass / (this.mass + o.mass);\r\n                        const elastic1 = o.velocity.y * (o.mass - this.mass) / (this.mass + o.mass)\r\n                            + this.velocity.y * 2 * this.mass / (this.mass + o.mass);\r\n\r\n                        // lerp betwen elastic or inelastic based on elasticity\r\n                        this.velocity.y = lerp(elasticity, inelastic, elastic0);\r\n                        o.velocity.y = lerp(elasticity, inelastic, elastic1);\r\n                    }\r\n                }\r\n                if (!smallStepUp && isBlockedX) // resolve x collision\r\n                {\r\n                    // push outside collision\r\n                    this.pos.x = o.pos.x + (sizeBoth.x/2 + epsilon) * sign(oldPos.x - o.pos.x);\r\n                    if (o.mass)\r\n                    {\r\n                        // inelastic collision\r\n                        const inelastic = (this.mass * this.velocity.x + o.mass * o.velocity.x) / (this.mass + o.mass);\r\n\r\n                        // elastic collision\r\n                        const elastic0 = this.velocity.x * (this.mass - o.mass) / (this.mass + o.mass)\r\n                            + o.velocity.x * 2 * o.mass / (this.mass + o.mass);\r\n                        const elastic1 = o.velocity.x * (o.mass - this.mass) / (this.mass + o.mass)\r\n                            + this.velocity.x * 2 * this.mass / (this.mass + o.mass);\r\n\r\n                        // lerp betwen elastic or inelastic based on elasticity\r\n                        this.velocity.x = lerp(elasticity, inelastic, elastic0);\r\n                        o.velocity.x = lerp(elasticity, inelastic, elastic1);\r\n                    }\r\n                    else // bounce if other object is fixed\r\n                        this.velocity.x *= -elasticity;\r\n                }\r\n                debugOverlay && debugPhysics && debugOverlap(this.pos, this.size, o.pos, o.size, '#f0f');\r\n            }\r\n        }\r\n        if (this.collideTiles)\r\n        {\r\n            // check collision against tiles\r\n            if (tileCollisionTest(this.pos, this.size, this))\r\n            {\r\n                // if already was stuck in collision, don't do anything\r\n                // this should not happen unless something starts in collision\r\n                if (!tileCollisionTest(oldPos, this.size, this))\r\n                {\r\n                    // test which side we bounced off (or both if a corner)\r\n                    const isBlockedY = tileCollisionTest(vec2(oldPos.x, this.pos.y), this.size, this);\r\n                    const isBlockedX = tileCollisionTest(vec2(this.pos.x, oldPos.y), this.size, this);\r\n                    if (isBlockedY || !isBlockedX)\r\n                    {\r\n                        // set if landed on ground\r\n                        this.groundObject = wasMovingDown;\r\n\r\n                        // bounce velocity\r\n                        this.velocity.y *= -this.elasticity;\r\n\r\n                        // adjust next velocity to settle on ground\r\n                        const o = (oldPos.y - this.size.y/2|0) - (oldPos.y - this.size.y/2);\r\n                        if (o < 0 && o > this.damping * this.velocity.y + gravity * this.gravityScale) \r\n                            this.velocity.y = this.damping ? (o - gravity * this.gravityScale) / this.damping : 0;\r\n\r\n                        // move to previous position\r\n                        this.pos.y = oldPos.y;\r\n                    }\r\n                    if (isBlockedX)\r\n                    {\r\n                        // move to previous position and bounce\r\n                        this.pos.x = oldPos.x;\r\n                        this.velocity.x *= -this.elasticity;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n       \r\n    /** Render the object, draws a tile by default, automatically called each frame, sorted by renderOrder */\r\n    render()\r\n    {\r\n        // default object render\r\n        drawTile(this.pos, this.drawSize || this.size, this.tileInfo, this.color, this.angle, this.mirror, this.additiveColor);\r\n    }\r\n    \r\n    /** Destroy this object, destroy it's children, detach it's parent, and mark it for removal */\r\n    destroy()\r\n    { \r\n        if (this.destroyed)\r\n            return;\r\n        \r\n        // disconnect from parent and destroy chidren\r\n        this.destroyed = 1;\r\n        this.parent && this.parent.removeChild(this);\r\n        for (const child of this.children)\r\n            child.destroy(child.parent = 0);\r\n    }\r\n\r\n    /** Convert from local space to world space\r\n     *  @param {Vector2} pos - local space point */\r\n    localToWorld(pos) { return this.pos.add(pos.rotate(-this.angle)); }\r\n\r\n    /** Convert from world space to local space\r\n     *  @param {Vector2} pos - world space point */\r\n    worldToLocal(pos) { return pos.subtract(this.pos).rotate(this.angle); }\r\n\r\n    /** Convert from local space to world space for a vector (rotation only)\r\n     *  @param {Vector2} vec - local space vector */\r\n    localToWorldVector(vec) { return vec.rotate(this.angle); }\r\n\r\n    /** Convert from world space to local space for a vector (rotation only)\r\n     *  @param {Vector2} vec - world space vector */\r\n    worldToLocalVector(vec) { return vec.rotate(-this.angle); }\r\n    \r\n    /** Called to check if a tile collision should be resolved\r\n     *  @param {Number}  tileData - the value of the tile at the position\r\n     *  @param {Vector2} pos      - tile where the collision occured\r\n     *  @return {Boolean}         - true if the collision should be resolved */\r\n    collideWithTile(tileData, pos)    { return tileData > 0; }\r\n\r\n    /** Called to check if a object collision should be resolved\r\n     *  @param {EngineObject} object - the object to test against\r\n     *  @return {Boolean}            - true if the collision should be resolved\r\n     */\r\n    collideWithObject(object)         { return true; }\r\n\r\n    /** How long since the object was created\r\n     *  @return {Number} */\r\n    getAliveTime()                    { return time - this.spawnTime; }\r\n\r\n    /** Apply acceleration to this object (adjust velocity, not affected by mass)\r\n     *  @param {Vector2} acceleration */\r\n    applyAcceleration(acceleration)   { if (this.mass) this.velocity = this.velocity.add(acceleration); }\r\n\r\n    /** Apply force to this object (adjust velocity, affected by mass)\r\n     *  @param {Vector2} force */\r\n    applyForce(force)\t              { this.applyAcceleration(force.scale(1/this.mass)); }\r\n    \r\n    /** Get the direction of the mirror\r\n     *  @return {Number} -1 if this.mirror is true, or 1 if not mirrored */\r\n    getMirrorSign() { return this.mirror ? -1 : 1; }\r\n\r\n    /** Attaches a child to this with a given local transform\r\n     *  @param {EngineObject} child\r\n     *  @param {Vector2}      [localPos=(0,0)]\r\n     *  @param {Number}       [localAngle] */\r\n    addChild(child, localPos=vec2(), localAngle=0)\r\n    {\r\n        ASSERT(!child.parent && !this.children.includes(child));\r\n        this.children.push(child);\r\n        child.parent = this;\r\n        child.localPos = localPos.copy();\r\n        child.localAngle = localAngle;\r\n    }\r\n\r\n    /** Removes a child from this one\r\n     *  @param {EngineObject} child */\r\n    removeChild(child)\r\n    {\r\n        ASSERT(child.parent == this && this.children.includes(child));\r\n        this.children.splice(this.children.indexOf(child), 1);\r\n        child.parent = 0;\r\n    }\r\n\r\n    /** Set how this object collides\r\n     *  @param {Boolean} [collideSolidObjects] - Does it collide with solid objects?\r\n     *  @param {Boolean} [isSolid]             - Does it collide with and block other objects? (expensive in large numbers)\r\n     *  @param {Boolean} [collideTiles]        - Does it collide with the tile collision?\r\n     *  @param {Boolean} [collideRaycast]      - Does it collide with raycasts? */\r\n    setCollision(collideSolidObjects=true, isSolid=true, collideTiles=true, collideRaycast=true)\r\n    {\r\n        ASSERT(collideSolidObjects || !isSolid, 'solid objects must be set to collide');\r\n\r\n        this.collideSolidObjects = collideSolidObjects;\r\n        this.isSolid = isSolid;\r\n        this.collideTiles = collideTiles;\r\n        this.collideRaycast = collideRaycast;\r\n    }\r\n\r\n    /** Returns string containg info about this object for debugging\r\n     *  @return {String} */\r\n    toString()\r\n    {\r\n        if (debug)\r\n        {\r\n            let text = 'type = ' + this.constructor.name;\r\n            if (this.pos.x || this.pos.y)\r\n                text += '\\npos = ' + this.pos;\r\n            if (this.velocity.x || this.velocity.y)\r\n                text += '\\nvelocity = ' + this.velocity;\r\n            if (this.size.x || this.size.y)\r\n                text += '\\nsize = ' + this.size;\r\n            if (this.angle)\r\n                text += '\\nangle = ' + this.angle.toFixed(3);\r\n            if (this.color)\r\n                text += '\\ncolor = ' + this.color;\r\n            return text;\r\n        }\r\n    }\r\n\r\n    /** Render debug info for this object  */\r\n    renderDebugInfo()\r\n    {\r\n        if (debug)\r\n        {\r\n            // show object info for debugging\r\n            const size = vec2(max(this.size.x, .2), max(this.size.y, .2));\r\n            const color1 = rgb(this.collideTiles?1:0, this.collideSolidObjects?1:0, this.isSolid?1:0, this.parent?.2:.5);\r\n            const color2 = this.parent ? rgb(1,1,1,.5) : rgb(0,0,0,.8);\r\n            drawRect(this.pos, size, color1, this.angle, false);\r\n            drawRect(this.pos, size.scale(.8), color2, this.angle, false);\r\n            this.parent && drawLine(this.pos, this.parent.pos, .1, rgb(0,0,1,.5), false);\r\n        }\r\n    }\r\n}\n/** \r\n * LittleJS Drawing System\r\n * - Hybrid system with both Canvas2D and WebGL available\r\n * - Super fast tile sheet rendering with WebGL\r\n * - Can apply rotation, mirror, color and additive color\r\n * - Font rendering system with built in engine font\r\n * - Many useful utility functions\r\n * \r\n * LittleJS uses a hybrid rendering solution with the best of both Canvas2D and WebGL.\r\n * There are 3 canvas/contexts available to draw to...\r\n * mainCanvas - 2D background canvas, non WebGL stuff like tile layers are drawn here.\r\n * glCanvas - Used by the accelerated WebGL batch rendering system.\r\n * overlayCanvas - Another 2D canvas that appears on top of the other 2 canvases.\r\n * \r\n * The WebGL rendering system is very fast with some caveats...\r\n * - Switching blend modes (additive) or textures causes another draw call which is expensive in excess\r\n * - Group additive rendering together using renderOrder to mitigate this issue\r\n * \r\n * The LittleJS rendering solution is intentionally simple, feel free to adjust it for your needs!\r\n * @namespace Draw\r\n */\r\n\r\n\r\n\r\n/** The primary 2D canvas visible to the user\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */\r\nlet mainCanvas;\r\n\r\n/** 2d context for mainCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */\r\nlet mainContext;\r\n\r\n/** A canvas that appears on top of everything the same size as mainCanvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof Draw */\r\nlet overlayCanvas;\r\n\r\n/** 2d context for overlayCanvas\r\n *  @type {CanvasRenderingContext2D}\r\n *  @memberof Draw */\r\nlet overlayContext;\r\n\r\n/** The size of the main canvas (and other secondary canvases) \r\n *  @type {Vector2}\r\n *  @memberof Draw */\r\nlet mainCanvasSize = vec2();\r\n\r\n/** Array containing texture info for batch rendering system\r\n *  @type {Array}\r\n *  @memberof Draw */\r\nlet textureInfos = [];\r\n\r\n// Keep track of how many draw calls there were each frame for debugging\r\nlet drawCount;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Create a tile info object\r\n * - This can take vecs or floats for easier use and conversion\r\n * - If an index is passed in, the tile size and index will determine the position\r\n * @param {(Number|Vector2)} [pos=(0,0)]            - Top left corner of tile in pixels or index\r\n * @param {(Number|Vector2)} [size=tileSizeDefault] - Size of tile in pixels\r\n * @param {Number} [textureIndex]                   - Texture index to use\r\n * @return {TileInfo}\r\n * @example\r\n * tile(2)                       // a tile at index 2 using the default tile size of 16\r\n * tile(5, 8)                    // a tile at index 5 using a tile size of 8\r\n * tile(1, 16, 3)                // a tile at index 1 of size 16 on texture 3\r\n * tile(vec2(4,8), vec2(30,10))  // a tile at pixel location (4,8) with a size of (30,10)\r\n * @memberof Draw\r\n */\r\nfunction tile(pos=vec2(), size=tileSizeDefault, textureIndex=0)\r\n{\r\n    if (headlessMode)\r\n        return new TileInfo;\r\n\r\n    // if size is a number, make it a vector\r\n    if (typeof size === 'number')\r\n    {\r\n        ASSERT(size > 0);\r\n        size = vec2(size);\r\n    }\r\n\r\n    // if pos is a number, use it as a tile index\r\n    if (typeof pos === 'number')\r\n    {\r\n        const textureInfo = textureInfos[textureIndex];\r\n        ASSERT(textureInfo, 'Texture not loaded');\r\n        const cols = textureInfo.size.x / size.x |0;\r\n        pos = vec2((pos%cols)*size.x, (pos/cols|0)*size.y);\r\n    }\r\n\r\n    // return a tile info object\r\n    return new TileInfo(pos, size, textureIndex); \r\n}\r\n\r\n/** \r\n * Tile Info - Stores info about how to draw a tile\r\n */\r\nclass TileInfo\r\n{\r\n    /** Create a tile info object\r\n     *  @param {Vector2} [pos=(0,0)]            - Top left corner of tile in pixels\r\n     *  @param {Vector2} [size=tileSizeDefault] - Size of tile in pixels\r\n     *  @param {Number}  [textureIndex]         - Texture index to use\r\n     */\r\n    constructor(pos=vec2(), size=tileSizeDefault, textureIndex=0)\r\n    {\r\n        /** @property {Vector2} - Top left corner of tile in pixels */\r\n        this.pos = pos.copy();\r\n        /** @property {Vector2} - Size of tile in pixels */\r\n        this.size = size.copy();\r\n        /** @property {Number} - Texture index to use */\r\n        this.textureIndex = textureIndex;\r\n    }\r\n\r\n    /** Returns a copy of this tile offset by a vector\r\n    *  @param {Vector2} offset - Offset to apply in pixels\r\n    *  @return {TileInfo}\r\n    */\r\n    offset(offset)\r\n    { return new TileInfo(this.pos.add(offset), this.size, this.textureIndex); }\r\n\r\n    /** Returns a copy of this tile offset by a number of animation frames\r\n    *  @param {Number} frame - Offset to apply in animation frames\r\n    *  @return {TileInfo}\r\n    */\r\n    frame(frame)\r\n    {\r\n        ASSERT(typeof frame == 'number');\r\n        return this.offset(vec2(frame*this.size.x, 0));\r\n    }\r\n\r\n    /** Returns the texture info for this tile\r\n    *  @return {TextureInfo}\r\n    */\r\n    getTextureInfo()\r\n    { return textureInfos[this.textureIndex]; }\r\n}\r\n\r\n/** Texture Info - Stores info about each texture */\r\nclass TextureInfo\r\n{\r\n    /**\r\n     * Create a TextureInfo, called automatically by the engine\r\n     * @param {HTMLImageElement} image\r\n     */\r\n    constructor(image)\r\n    {\r\n        /** @property {HTMLImageElement} - image source */\r\n        this.image = image;\r\n        /** @property {Vector2} - size of the image */\r\n        this.size = vec2(image.width, image.height);\r\n        /** @property {WebGLTexture} - webgl texture */\r\n        this.glTexture = glEnable && glCreateTexture(image);\r\n        /** @property {Vector2} - size to adjust tile to fix bleeding */\r\n        this.fixBleedSize = vec2(tileFixBleedScale).divide(this.size);\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Convert from screen to world space coordinates\r\n *  @param {Vector2} screenPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction screenToWorld(screenPos)\r\n{\r\n    return new Vector2\r\n    (\r\n        (screenPos.x - mainCanvasSize.x/2 + .5) /  cameraScale + cameraPos.x,\r\n        (screenPos.y - mainCanvasSize.y/2 + .5) / -cameraScale + cameraPos.y\r\n    );\r\n}\r\n\r\n/** Convert from world to screen space coordinates\r\n *  @param {Vector2} worldPos\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction worldToScreen(worldPos)\r\n{\r\n    return new Vector2\r\n    (\r\n        (worldPos.x - cameraPos.x) *  cameraScale + mainCanvasSize.x/2 - .5,\r\n        (worldPos.y - cameraPos.y) * -cameraScale + mainCanvasSize.y/2 - .5\r\n    );\r\n}\r\n\r\n/** Get the camera's visible area in world space\r\n *  @return {Vector2}\r\n *  @memberof Draw */\r\nfunction getCameraSize() { return mainCanvasSize.scale(1/cameraScale); }\r\n\r\n/** Draw textured tile centered in world space, with color applied if using WebGL\r\n *  @param {Vector2} pos                        - Center of the tile in world space\r\n *  @param {Vector2} [size=(1,1)]               - Size of the tile in world space\r\n *  @param {TileInfo}[tileInfo]                 - Tile info to use, untextured if undefined\r\n *  @param {Color}   [color=(1,1,1,1)]          - Color to modulate with\r\n *  @param {Number}  [angle]                    - Angle to rotate by\r\n *  @param {Boolean} [mirror]                   - If true image is flipped along the Y axis\r\n *  @param {Color}   [additiveColor=(0,0,0,0)]  - Additive color to be applied\r\n *  @param {Boolean} [useWebGL=glEnable]        - Use accelerated WebGL rendering\r\n *  @param {Boolean} [screenSpace=false]        - If true the pos and size are in screen space\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context] - Canvas 2D context to draw to\r\n *  @memberof Draw */\r\nfunction drawTile(pos, size=vec2(1), tileInfo, color=new Color,\r\n    angle=0, mirror, additiveColor=new Color(0,0,0,0), useWebGL=glEnable, screenSpace, context)\r\n{\r\n    ASSERT(!context || !useWebGL, 'context only supported in canvas 2D mode'); \r\n    ASSERT(typeof tileInfo !== 'number' || !tileInfo, \r\n        'this is an old style calls, to fix replace it with tile(tileIndex, tileSize)');\r\n\r\n    const textureInfo = tileInfo && tileInfo.getTextureInfo();\r\n    if (useWebGL)\r\n    {\r\n        if (screenSpace)\r\n        {\r\n            // convert to world space\r\n            pos = screenToWorld(pos);\r\n            size = size.scale(1/cameraScale);\r\n        }\r\n        \r\n        if (textureInfo)\r\n        {\r\n            // calculate uvs and render\r\n            const x = tileInfo.pos.x / textureInfo.size.x;\r\n            const y = tileInfo.pos.y / textureInfo.size.y;\r\n            const w = tileInfo.size.x / textureInfo.size.x;\r\n            const h = tileInfo.size.y / textureInfo.size.y;\r\n            const tileImageFixBleed = textureInfo.fixBleedSize;\r\n            glSetTexture(textureInfo.glTexture);\r\n            glDraw(pos.x, pos.y, mirror ? -size.x : size.x, size.y, angle, \r\n                x + tileImageFixBleed.x,     y + tileImageFixBleed.y, \r\n                x - tileImageFixBleed.x + w, y - tileImageFixBleed.y + h, \r\n                color.rgbaInt(), additiveColor.rgbaInt()); \r\n        }\r\n        else\r\n        {\r\n            // if no tile info, force untextured\r\n            glDraw(pos.x, pos.y, size.x, size.y, angle, 0, 0, 0, 0, 0, color.rgbaInt()); \r\n        }\r\n    }\r\n    else\r\n    {\r\n        // normal canvas 2D rendering method (slower)\r\n        showWatermark && ++drawCount;\r\n        drawCanvas2D(pos, size, angle, mirror, (context)=>\r\n        {\r\n            if (textureInfo)\r\n            {\r\n                // calculate uvs and render\r\n                const x = tileInfo.pos.x + tileFixBleedScale;\r\n                const y = tileInfo.pos.y + tileFixBleedScale;\r\n                const w = tileInfo.size.x - 2*tileFixBleedScale;\r\n                const h = tileInfo.size.y - 2*tileFixBleedScale;\r\n                context.globalAlpha = color.a; // only alpha is supported\r\n                context.drawImage(textureInfo.image, x, y, w, h, -.5, -.5, 1, 1);\r\n                context.globalAlpha = 1; // set back to full alpha\r\n            }\r\n            else\r\n            {\r\n                // if no tile info, force untextured\r\n                context.fillStyle = color;\r\n                context.fillRect(-.5, -.5, 1, 1);\r\n            }\r\n        }, screenSpace, context);\r\n    }\r\n}\r\n\r\n/** Draw colored rect centered on pos\r\n *  @param {Vector2} pos\r\n *  @param {Vector2} [size=(1,1)]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [angle]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */\r\nfunction drawRect(pos, size, color, angle, useWebGL, screenSpace, context)\r\n{ \r\n    drawTile(pos, size, undefined, color, angle, false, undefined, useWebGL, screenSpace, context); \r\n}\r\n\r\n/** Draw colored line between two points\r\n *  @param {Vector2} posA\r\n *  @param {Vector2} posB\r\n *  @param {Number}  [thickness]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context]\r\n *  @memberof Draw */\r\nfunction drawLine(posA, posB, thickness=.1, color, useWebGL, screenSpace, context)\r\n{\r\n    const halfDelta = vec2((posB.x - posA.x)/2, (posB.y - posA.y)/2);\r\n    const size = vec2(thickness, halfDelta.length()*2);\r\n    drawRect(posA.add(halfDelta), size, color, halfDelta.angle(), useWebGL, screenSpace, context);\r\n}\r\n\r\n/** Draw directly to a 2d canvas context in world space\r\n *  @param {Vector2}  pos\r\n *  @param {Vector2}  size\r\n *  @param {Number}   angle\r\n *  @param {Boolean}  mirror\r\n *  @param {Function} drawFunction\r\n *  @param {Boolean} [screenSpace=false]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */\r\nfunction drawCanvas2D(pos, size, angle, mirror, drawFunction, screenSpace, context=mainContext)\r\n{\r\n    if (!screenSpace)\r\n    {\r\n        // transform from world space to screen space\r\n        pos = worldToScreen(pos);\r\n        size = size.scale(cameraScale);\r\n    }\r\n    context.save();\r\n    context.translate(pos.x+.5, pos.y+.5);\r\n    context.rotate(angle);\r\n    context.scale(mirror ? -size.x : size.x, -size.y);\r\n    drawFunction(context);\r\n    context.restore();\r\n}\r\n\r\n/** Enable normal or additive blend mode\r\n *  @param {Boolean} [additive]\r\n *  @param {Boolean} [useWebGL=glEnable]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=mainContext]\r\n *  @memberof Draw */\r\nfunction setBlendMode(additive, useWebGL=glEnable, context)\r\n{\r\n    ASSERT(!context || !useWebGL, 'context only supported in canvas 2D mode');\r\n    if (useWebGL)\r\n        glAdditive = additive;\r\n    else\r\n    {\r\n        if (!context)\r\n            context = mainContext;\r\n        context.globalCompositeOperation = additive ? 'lighter' : 'source-over';\r\n    }\r\n}\r\n\r\n/** Draw text on overlay canvas in world space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign='center']\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */\r\nfunction drawText(text, pos, size=1, color, lineWidth=0, lineColor, textAlign, font, context)\r\n{\r\n    drawTextScreen(text, worldToScreen(pos), size*cameraScale, color, lineWidth*cameraScale, lineColor, textAlign, font, context);\r\n}\r\n\r\n/** Draw text on overlay canvas in screen space\r\n *  Automatically splits new lines into rows\r\n *  @param {String}  text\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [size]\r\n *  @param {Color}   [color=(1,1,1,1)]\r\n *  @param {Number}  [lineWidth]\r\n *  @param {Color}   [lineColor=(0,0,0,1)]\r\n *  @param {CanvasTextAlign}  [textAlign]\r\n *  @param {String}  [font=fontDefault]\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext]\r\n *  @memberof Draw */\r\nfunction drawTextScreen(text, pos, size=1, color=new Color, lineWidth=0, lineColor=new Color(0,0,0), textAlign='center', font=fontDefault, context=overlayContext)\r\n{\r\n    context.fillStyle = color.toString();\r\n    context.lineWidth = lineWidth;\r\n    context.strokeStyle = lineColor.toString();\r\n    context.textAlign = textAlign;\r\n    context.font = size + 'px '+ font;\r\n    context.textBaseline = 'middle';\r\n    context.lineJoin = 'round';\r\n\r\n    pos = pos.copy();\r\n    (text+'').split('\\n').forEach(line=>\r\n    {\r\n        lineWidth && context.strokeText(line, pos.x, pos.y);\r\n        context.fillText(line, pos.x, pos.y);\r\n        pos.y += size;\r\n    });\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nlet engineFontImage;\r\n\r\n/** \r\n * Font Image Object - Draw text on a 2D canvas by using characters in an image\r\n * - 96 characters (from space to tilde) are stored in an image\r\n * - Uses a default 8x8 font if none is supplied\r\n * - You can also use fonts from the main tile sheet\r\n * @example\r\n * // use built in font\r\n * const font = new ImageFont;\r\n * \r\n * // draw text\r\n * font.drawTextScreen(\"LittleJS\\nHello World!\", vec2(200, 50));\r\n */\r\nclass FontImage\r\n{\r\n    /** Create an image font\r\n     *  @param {HTMLImageElement} [image]    - Image for the font, if undefined default font is used\r\n     *  @param {Vector2} [tileSize=(8,8)]    - Size of the font source tiles\r\n     *  @param {Vector2} [paddingSize=(0,1)] - How much extra space to add between characters\r\n     *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} [context=overlayContext] - context to draw to\r\n     */\r\n    constructor(image, tileSize=vec2(8), paddingSize=vec2(0,1), context=overlayContext)\r\n    {\r\n        // load default font image\r\n        if (!engineFontImage)\r\n            (engineFontImage = new Image).src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAYAQAAAAA9+x6JAAAAAnRSTlMAAHaTzTgAAAGiSURBVHjaZZABhxxBEIUf6ECLBdFY+Q0PMNgf0yCgsSAGZcT9sgIPtBWwIA5wgAPEoHUyJeeSlW+gjK+fegWwtROWpVQEyWh2npdpBmTUFVhb29RINgLIukoXr5LIAvYQ5ve+1FqWEMqNKTX3FAJHyQDRZvmKWubAACcv5z5Gtg2oyCWE+Yk/8JZQX1jTTCpKAFGIgza+dJCNBF2UskRlsgwitHbSV0QLgt9sTPtsRlvJjEr8C/FARWA2bJ/TtJ7lko34dNDn6usJUMzuErP89UUBJbWeozrwLLncXczd508deAjLWipLO4Q5XGPcJvPu92cNDaN0P5G1FL0nSOzddZOrJ6rNhbXGmeDvO3TF7DeJWl4bvaYQTNHCTeuqKZmbjHaSOFes+IX/+IhHrnAkXOAsfn24EM68XieIECoccD4KZLk/odiwzeo2rovYdhvb2HYFgyznJyDpYJdYOmfXgVdJTaUi4xA2uWYNYec9BLeqdl9EsoTw582mSFDX2DxVLbNt9U3YYoeatBad1c2Tj8t2akrjaIGJNywKB/7h75/gN3vCMSaadIUTAAAAAElFTkSuQmCC';\r\n\r\n        this.image = image || engineFontImage;\r\n        this.tileSize = tileSize;\r\n        this.paddingSize = paddingSize;\r\n        this.context = context;\r\n    }\r\n\r\n    /** Draw text in world space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale=.25]\r\n     *  @param {Boolean} [center]\r\n     */\r\n    drawText(text, pos, scale=1, center)\r\n    {\r\n        this.drawTextScreen(text, worldToScreen(pos).floor(), scale*cameraScale|0, center);\r\n    }\r\n\r\n    /** Draw text in screen space using the image font\r\n     *  @param {String}  text\r\n     *  @param {Vector2} pos\r\n     *  @param {Number}  [scale]\r\n     *  @param {Boolean} [center]\r\n     */\r\n    drawTextScreen(text, pos, scale=4, center)\r\n    {\r\n        const context = this.context;\r\n        context.save();\r\n        context.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        const size = this.tileSize;\r\n        const drawSize = size.add(this.paddingSize).scale(scale);\r\n        const cols = this.image.width / this.tileSize.x |0;\r\n        (text+'').split('\\n').forEach((line, i)=>\r\n        {\r\n            const centerOffset = center ? line.length * size.x * scale / 2 |0 : 0;\r\n            for(let j=line.length; j--;)\r\n            {\r\n                // draw each character\r\n                let charCode = line[j].charCodeAt(0);\r\n                if (charCode < 32 || charCode > 127)\r\n                    charCode = 127; // unknown character\r\n\r\n                // get the character source location and draw it\r\n                const tile = charCode - 32;\r\n                const x = tile % cols;\r\n                const y = tile / cols |0;\r\n                const drawPos = pos.add(vec2(j,i).multiply(drawSize));\r\n                context.drawImage(this.image, x * size.x, y * size.y, size.x, size.y, \r\n                    drawPos.x - centerOffset, drawPos.y, size.x * scale, size.y * scale);\r\n            }\r\n        });\r\n\r\n        context.restore();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Fullscreen mode\r\n\r\n/** Returns true if fullscreen mode is active\r\n *  @return {Boolean}\r\n *  @memberof Draw */\r\nfunction isFullscreen() { return !!document.fullscreenElement; }\r\n\r\n/** Toggle fullsceen mode\r\n *  @memberof Draw */\r\nfunction toggleFullscreen()\r\n{\r\n    if (isFullscreen())\r\n    {\r\n        if (document.exitFullscreen)\r\n            document.exitFullscreen();\r\n    }\r\n    else if (document.body.requestFullscreen)\r\n            document.body.requestFullscreen();\r\n}\n/** \r\n * LittleJS Input System\r\n * - Tracks keyboard down, pressed, and released\r\n * - Tracks mouse buttons, position, and wheel\r\n * - Tracks multiple analog gamepads\r\n * - Touch input is handled as mouse input\r\n * - Virtual gamepad for touch devices\r\n * @namespace Input\r\n */\r\n\r\n\r\n\r\n/** Returns true if device key is down\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyIsDown(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 1); \r\n}\r\n\r\n/** Returns true if device key was pressed this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyWasPressed(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 2); \r\n}\r\n\r\n/** Returns true if device key was released this frame\r\n *  @param {String|Number} key\r\n *  @param {Number} [device]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction keyWasReleased(key, device=0)\r\n{ \r\n    ASSERT(device > 0 || typeof key !== 'number' || key < 3, 'use code string for keyboard');\r\n    return inputData[device] && !!(inputData[device][key] & 4);\r\n}\r\n\r\n/** Clears all input\r\n *  @memberof Input */\r\nfunction clearInput() { inputData = [[]]; }\r\n\r\n/** Returns true if mouse button is down\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseIsDown = keyIsDown;\r\n\r\n/** Returns true if mouse button was pressed\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseWasPressed = keyWasPressed;\r\n\r\n/** Returns true if mouse button was released\r\n *  @function\r\n *  @param {Number} button\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nconst mouseWasReleased = keyWasReleased;\r\n\r\n/** Mouse pos in world space\r\n *  @type {Vector2}\r\n *  @memberof Input */\r\nlet mousePos = vec2();\r\n\r\n/** Mouse pos in screen space\r\n *  @type {Vector2}\r\n *  @memberof Input */\r\nlet mousePosScreen = vec2();\r\n\r\n/** Mouse wheel delta this frame\r\n *  @type {Number}\r\n *  @memberof Input */\r\nlet mouseWheel = 0;\r\n\r\n/** Returns true if user is using gamepad (has more recently pressed a gamepad button)\r\n *  @type {Boolean}\r\n *  @memberof Input */\r\nlet isUsingGamepad = false;\r\n\r\n/** Prevents input continuing to the default browser handling (false by default)\r\n *  @type {Boolean}\r\n *  @memberof Input */\r\nlet preventDefaultInput = false;\r\n\r\n/** Returns true if gamepad button is down\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadIsDown(button, gamepad=0)\r\n{ return keyIsDown(button, gamepad+1); }\r\n\r\n/** Returns true if gamepad button was pressed\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadWasPressed(button, gamepad=0)\r\n{ return keyWasPressed(button, gamepad+1); }\r\n\r\n/** Returns true if gamepad button was released\r\n *  @param {Number} button\r\n *  @param {Number} [gamepad]\r\n *  @return {Boolean}\r\n *  @memberof Input */\r\nfunction gamepadWasReleased(button, gamepad=0)\r\n{ return keyWasReleased(button, gamepad+1); }\r\n\r\n/** Returns gamepad stick value\r\n *  @param {Number} stick\r\n *  @param {Number} [gamepad]\r\n *  @return {Vector2}\r\n *  @memberof Input */\r\nfunction gamepadStick(stick,  gamepad=0)\r\n{ return gamepadStickData[gamepad] ? gamepadStickData[gamepad][stick] || vec2() : vec2(); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input update called by engine\r\n\r\n// store input as a bit field for each key: 1 = isDown, 2 = wasPressed, 4 = wasReleased\r\n// mouse and keyboard are stored together in device 0, gamepads are in devices > 0\r\nlet inputData = [[]];\r\n\r\nfunction inputUpdate()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    // clear input when lost focus (prevent stuck keys)\r\n    if(!(touchInputEnable && isTouchDevice) && !document.hasFocus())\r\n        clearInput();\r\n\r\n    // update mouse world space position\r\n    mousePos = screenToWorld(mousePosScreen);\r\n\r\n    // update gamepads if enabled\r\n    gamepadsUpdate();\r\n}\r\n\r\nfunction inputUpdatePost()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    // clear input to prepare for next frame\r\n    for (const deviceInputData of inputData)\r\n    for (const i in deviceInputData)\r\n        deviceInputData[i] &= 1;\r\n    mouseWheel = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Input event handlers\r\n\r\nfunction inputInit()\r\n{\r\n    if (headlessMode) return;\r\n\r\n    onkeydown = (e)=>\r\n    {\r\n        if (debug && e.target != document.body) return;\r\n        if (!e.repeat)\r\n        {\r\n            isUsingGamepad = false;\r\n            inputData[0][e.code] = 3;\r\n            if (inputWASDEmulateDirection)\r\n                inputData[0][remapKey(e.code)] = 3;\r\n        }\r\n        preventDefaultInput && e.preventDefault();\r\n    }\r\n\r\n    onkeyup = (e)=>\r\n    {\r\n        if (debug && e.target != document.body) return;\r\n        inputData[0][e.code] = 4;\r\n        if (inputWASDEmulateDirection)\r\n            inputData[0][remapKey(e.code)] = 4;\r\n    }\r\n\r\n    // handle remapping wasd keys to directions\r\n    function remapKey(c)\r\n    {\r\n        return inputWASDEmulateDirection ? \r\n            c == 'KeyW' ? 'ArrowUp' : \r\n            c == 'KeyS' ? 'ArrowDown' : \r\n            c == 'KeyA' ? 'ArrowLeft' : \r\n            c == 'KeyD' ? 'ArrowRight' : c : c;\r\n    }\r\n    \r\n    // mouse event handlers\r\n    onmousedown   = (e)=>\r\n    {\r\n        isUsingGamepad = false; \r\n        inputData[0][e.button] = 3; \r\n        mousePosScreen = mouseToScreen(e); \r\n        e.button && e.preventDefault();\r\n    }\r\n    onmouseup     = (e)=> inputData[0][e.button] = inputData[0][e.button] & 2 | 4;\r\n    onmousemove   = (e)=> mousePosScreen = mouseToScreen(e);\r\n    onwheel       = (e)=> mouseWheel = e.ctrlKey ? 0 : sign(e.deltaY);\r\n    oncontextmenu = (e)=> false; // prevent right click menu\r\n\r\n    // init touch input\r\n    if (isTouchDevice && touchInputEnable && !headlessMode)\r\n        touchInputInit();\r\n}\r\n\r\n// convert a mouse or touch event position to screen space\r\nfunction mouseToScreen(mousePos)\r\n{\r\n    if (!mainCanvas || headlessMode)\r\n        return vec2(); // fix bug that can occur if user clicks before page loads\r\n\r\n    const rect = mainCanvas.getBoundingClientRect();\r\n    return vec2(mainCanvas.width, mainCanvas.height).multiply(\r\n        vec2(percent(mousePos.x, rect.left, rect.right), percent(mousePos.y, rect.top, rect.bottom)));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Gamepad input\r\n\r\n// gamepad internal variables\r\nconst gamepadStickData = [];\r\n\r\n// gamepads are updated by engine every frame automatically\r\nfunction gamepadsUpdate()\r\n{\r\n    const applyDeadZones = (v)=>\r\n    {\r\n        const min=.3, max=.8;\r\n        const deadZone = (v)=> \r\n            v >  min ?  percent( v, min, max) : \r\n            v < -min ? -percent(-v, min, max) : 0;\r\n        return vec2(deadZone(v.x), deadZone(-v.y)).clampLength();\r\n    }\r\n\r\n    // update touch gamepad if enabled\r\n    if (touchGamepadEnable && isTouchDevice)\r\n    {\r\n        ASSERT(touchGamepadButtons, 'set touchGamepadEnable before calling init!');\r\n        if (touchGamepadTimer.isSet())\r\n        {\r\n            // read virtual analog stick\r\n            const sticks = gamepadStickData[0] || (gamepadStickData[0] = []);\r\n            sticks[0] = vec2();\r\n            if (touchGamepadAnalog)\r\n                sticks[0] = applyDeadZones(touchGamepadStick);\r\n            else if (touchGamepadStick.lengthSquared() > .3)\r\n            {\r\n                // convert to 8 way dpad\r\n                sticks[0].x = Math.round(touchGamepadStick.x);\r\n                sticks[0].y = -Math.round(touchGamepadStick.y);\r\n                sticks[0] = sticks[0].clampLength();\r\n            }\r\n\r\n            // read virtual gamepad buttons\r\n            const data = inputData[1] || (inputData[1] = []);\r\n            for (let i=10; i--;)\r\n            {\r\n                const j = i == 3 ? 2 : i == 2 ? 3 : i; // fix button locations\r\n                const wasDown = gamepadIsDown(j,0);\r\n                data[j] = touchGamepadButtons[i] ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // return if gamepads are disabled or not supported\r\n    if (!gamepadsEnable || !navigator || !navigator.getGamepads)\r\n        return;\r\n\r\n    // only poll gamepads when focused or in debug mode\r\n    if (!debug && !document.hasFocus())\r\n        return;\r\n\r\n    // poll gamepads\r\n    const gamepads = navigator.getGamepads();\r\n    for (let i = gamepads.length; i--;)\r\n    {\r\n        // get or create gamepad data\r\n        const gamepad = gamepads[i];\r\n        const data = inputData[i+1] || (inputData[i+1] = []);\r\n        const sticks = gamepadStickData[i] || (gamepadStickData[i] = []);\r\n\r\n        if (gamepad)\r\n        {\r\n            // read analog sticks\r\n            for (let j = 0; j < gamepad.axes.length-1; j+=2)\r\n                sticks[j>>1] = applyDeadZones(vec2(gamepad.axes[j],gamepad.axes[j+1]));\r\n            \r\n            // read buttons\r\n            for (let j = gamepad.buttons.length; j--;)\r\n            {\r\n                const button = gamepad.buttons[j];\r\n                const wasDown = gamepadIsDown(j,i);\r\n                data[j] = button.pressed ? wasDown ? 1 : 3 : wasDown ? 4 : 0;\r\n                isUsingGamepad ||= !i && button.pressed;\r\n            }\r\n\r\n            if (gamepadDirectionEmulateStick)\r\n            {\r\n                // copy dpad to left analog stick when pressed\r\n                const dpad = vec2(\r\n                    (gamepadIsDown(15,i)&&1) - (gamepadIsDown(14,i)&&1), \r\n                    (gamepadIsDown(12,i)&&1) - (gamepadIsDown(13,i)&&1));\r\n                if (dpad.lengthSquared())\r\n                    sticks[0] = dpad.clampLength();\r\n            }\r\n\r\n            // disable touch gamepad if using real gamepad\r\n            touchGamepadEnable && isUsingGamepad && touchGamepadTimer.unset(); \r\n        }\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Pulse the vibration hardware if it exists\r\n *  @param {Number|Array} [pattern] - single value in ms or vibration interval array\r\n *  @memberof Input */\r\nfunction vibrate(pattern=100)\r\n{ vibrateEnable && !headlessMode && navigator && navigator.vibrate && navigator.vibrate(pattern); }\r\n\r\n/** Cancel any ongoing vibration\r\n *  @memberof Input */\r\nfunction vibrateStop() { vibrate(0); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Touch input & virtual on screen gamepad\r\n\r\n/** True if a touch device has been detected\r\n *  @memberof Input */\r\nconst isTouchDevice = window.ontouchstart !== undefined;\r\n\r\n// touch gamepad internal variables\r\nlet touchGamepadTimer = new Timer, touchGamepadButtons, touchGamepadStick;\r\n\r\n// enable touch input mouse passthrough\r\nfunction touchInputInit()\r\n{\r\n    // add non passive touch event listeners\r\n    let handleTouch = handleTouchDefault;\r\n    if (touchGamepadEnable)\r\n    {\r\n        // touch input internal variables\r\n        handleTouch = handleTouchGamepad;\r\n        touchGamepadButtons = [];\r\n        touchGamepadStick = vec2();\r\n    }\r\n    document.addEventListener('touchstart', (e) => handleTouch(e), { passive: false });\r\n    document.addEventListener('touchmove',  (e) => handleTouch(e), { passive: false });\r\n    document.addEventListener('touchend',   (e) => handleTouch(e), { passive: false });\r\n\r\n    // override mouse events\r\n    onmousedown = onmouseup = ()=> 0;\r\n\r\n    // handle all touch events the same way\r\n    let wasTouching;\r\n    function handleTouchDefault(e)\r\n    {\r\n        // fix stalled audio requiring user interaction\r\n        if (soundEnable && audioContext && audioContext.state != 'running')\r\n            zzfx(0);\r\n\r\n        // check if touching and pass to mouse events\r\n        const touching = e.touches.length;\r\n        const button = 0; // all touches are left mouse button\r\n        if (touching)\r\n        {\r\n            // set event pos and pass it along\r\n            const p = vec2(e.touches[0].clientX, e.touches[0].clientY);\r\n            mousePosScreen = mouseToScreen(p);\r\n            wasTouching ? isUsingGamepad = false : inputData[0][button] = 3;\r\n        }\r\n        else if (wasTouching)\r\n            inputData[0][button] = inputData[0][button] & 2 | 4;\r\n\r\n        // set was touching\r\n        wasTouching = touching;\r\n\r\n        // prevent default handling like copy and magnifier lens\r\n        if (document.hasFocus()) // allow document to get focus\r\n            e.preventDefault();\r\n        \r\n        // must return true so the document will get focus\r\n        return true;\r\n    }\r\n\r\n    // special handling for virtual gamepad mode\r\n    function handleTouchGamepad(e)\r\n    {\r\n        // clear touch gamepad input\r\n        touchGamepadStick = vec2();\r\n        touchGamepadButtons = [];\r\n        isUsingGamepad = true;\r\n            \r\n        const touching = e.touches.length;\r\n        if (touching)\r\n        {\r\n            touchGamepadTimer.set();\r\n            if (paused)\r\n            {\r\n                // touch anywhere to press start when paused\r\n                touchGamepadButtons[9] = 1;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // get center of left and right sides\r\n        const stickCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n        const buttonCenter = mainCanvasSize.subtract(vec2(touchGamepadSize, touchGamepadSize));\r\n        const startCenter = mainCanvasSize.scale(.5);\r\n\r\n        // check each touch point\r\n        for (const touch of e.touches)\r\n        {\r\n            const touchPos = mouseToScreen(vec2(touch.clientX, touch.clientY));\r\n            if (touchPos.distance(stickCenter) < touchGamepadSize)\r\n            {\r\n                // virtual analog stick\r\n                touchGamepadStick = touchPos.subtract(stickCenter).scale(2/touchGamepadSize).clampLength();\r\n            }\r\n            else if (touchPos.distance(buttonCenter) < touchGamepadSize)\r\n            {\r\n                // virtual face buttons\r\n                const button = touchPos.subtract(buttonCenter).direction();\r\n                touchGamepadButtons[button] = 1;\r\n            }\r\n            else if (touchPos.distance(startCenter) < touchGamepadSize)\r\n            {\r\n                // virtual start button in center\r\n                touchGamepadButtons[9] = 1;\r\n            }\r\n        }\r\n\r\n        // call default touch handler so normal touch events still work\r\n        handleTouchDefault(e);\r\n        \r\n        // must return true so the document will get focus\r\n        return true;\r\n    }\r\n}\r\n\r\n// render the touch gamepad, called automatically by the engine\r\nfunction touchGamepadRender()\r\n{\r\n    if (!touchInputEnable || !isTouchDevice || headlessMode) return;\r\n    if (!touchGamepadEnable || !touchGamepadTimer.isSet())\r\n        return;\r\n    \r\n    // fade off when not touching or paused\r\n    const alpha = percent(touchGamepadTimer.get(), 4, 3);\r\n    if (!alpha || paused)\r\n        return;\r\n\r\n    // setup the canvas\r\n    const context = overlayContext;\r\n    context.save();\r\n    context.globalAlpha = alpha*touchGamepadAlpha;\r\n    context.strokeStyle = '#fff';\r\n    context.lineWidth = 3;\r\n\r\n    // draw left analog stick\r\n    context.fillStyle = touchGamepadStick.lengthSquared() > 0 ? '#fff' : '#000';\r\n    context.beginPath();\r\n\r\n    const leftCenter = vec2(touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n    if (touchGamepadAnalog) // draw circle shaped gamepad\r\n    {\r\n        context.arc(leftCenter.x, leftCenter.y, touchGamepadSize/2, 0, 9);\r\n        context.fill();\r\n        context.stroke();\r\n    }\r\n    else // draw cross shaped gamepad\r\n    {\r\n        for(let i=10; i--;)\r\n        {\r\n            const angle = i*PI/4;\r\n            context.arc(leftCenter.x, leftCenter.y,touchGamepadSize*.6, angle + PI/8, angle + PI/8);\r\n            i%2 && context.arc(leftCenter.x, leftCenter.y, touchGamepadSize*.33, angle, angle);\r\n            i==1 && context.fill();\r\n        }\r\n        context.stroke();\r\n    }\r\n    \r\n    // draw right face buttons\r\n    const rightCenter = vec2(mainCanvasSize.x-touchGamepadSize, mainCanvasSize.y-touchGamepadSize);\r\n    for (let i=4; i--;)\r\n    {\r\n        const pos = rightCenter.add(vec2().setDirection(i, touchGamepadSize/2));\r\n        context.fillStyle = touchGamepadButtons[i] ? '#fff' : '#000';\r\n        context.beginPath();\r\n        context.arc(pos.x, pos.y, touchGamepadSize/4, 0,9);\r\n        context.fill();\r\n        context.stroke();\r\n    }\r\n\r\n    // set canvas back to normal\r\n    context.restore();\r\n}\n/** \r\n * LittleJS Audio System\r\n * - <a href=https://killedbyapixel.github.io/ZzFX/>ZzFX Sound Effects</a> - ZzFX Sound Effect Generator\r\n * - <a href=https://keithclark.github.io/ZzFXM/>ZzFXM Music</a> - ZzFXM Music System\r\n * - Caches sounds and music for fast playback\r\n * - Can attenuate and apply stereo panning to sounds\r\n * - Ability to play mp3, ogg, and wave files\r\n * - Speech synthesis functions\r\n * @namespace Audio\r\n */\r\n\r\n\r\n\r\n/** Audio context used by the engine\r\n *  @type {AudioContext}\r\n *  @memberof Audio */\r\nlet audioContext;\r\n\r\n/** Master gain node for all audio to pass through\r\n *  @type {GainNode}\r\n *  @memberof Audio */\r\nlet audioGainNode;\r\n\r\nfunction audioInit()\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n    \r\n    // create audio context\r\n    audioContext = new AudioContext;\r\n\r\n    // create and connect gain node\r\n    // (createGain is more widely spported then GainNode construtor)\r\n    audioGainNode = audioContext.createGain();\r\n    audioGainNode.connect(audioContext.destination);\r\n    setSoundVolume(soundVolume); // update gain volume\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Sound Object - Stores a sound for later use and can be played positionally\r\n * \r\n * <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n * @example\r\n * // create a sound\r\n * const sound_example = new Sound([.5,.5]);\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */\r\nclass Sound\r\n{\r\n    /** Create a sound object and cache the zzfx samples for later use\r\n     *  @param {Array}  zzfxSound - Array of zzfx parameters, ex. [.5,.5]\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering\r\n     */\r\n    constructor(zzfxSound, range=soundDefaultRange, taper=soundDefaultTaper)\r\n    {\r\n        if (!soundEnable || headlessMode) return;\r\n\r\n        /** @property {Number} - World space max range of sound, will not play if camera is farther away */\r\n        this.range = range;\r\n\r\n        /** @property {Number} - At what percentage of range should it start tapering off */\r\n        this.taper = taper;\r\n\r\n        /** @property {Number} - How much to randomize frequency each time sound plays */\r\n        this.randomness = 0;\r\n\r\n        if (zzfxSound)\r\n        {\r\n            // generate zzfx sound now for fast playback\r\n            const defaultRandomness = .05;\r\n            this.randomness = zzfxSound[1] || defaultRandomness;\r\n            this.sampleChannels = [zzfxG(...zzfxSound)];\r\n            this.sampleRate = zzfxR;\r\n        }\r\n    }\r\n\r\n    /** Play the sound\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume] - How much to scale volume by (in addition to range fade)\r\n     *  @param {Number}  [pitch] - How much to scale pitch by (also adjusted by this.randomness)\r\n     *  @param {Number}  [randomnessScale] - How much to scale randomness\r\n     *  @param {Boolean} [loop] - Should the sound loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    play(pos, volume=1, pitch=1, randomnessScale=1, loop=false)\r\n    {\r\n        if (!soundEnable || headlessMode) return;\r\n        if (!this.sampleChannels) return;\r\n\r\n        let pan;\r\n        if (pos)\r\n        {\r\n            const range = this.range;\r\n            if (range)\r\n            {\r\n                // apply range based fade\r\n                const lengthSquared = cameraPos.distanceSquared(pos);\r\n                if (lengthSquared > range*range)\r\n                    return; // out of range\r\n\r\n                // attenuate volume by distance\r\n                volume *= percent(lengthSquared**.5, range, range*this.taper);\r\n            }\r\n\r\n            // get pan from screen space coords\r\n            pan = worldToScreen(pos).x * 2/mainCanvas.width - 1;\r\n        }\r\n\r\n        // play the sound\r\n        const playbackRate = pitch + pitch * this.randomness*randomnessScale*rand(-1,1);\r\n        this.gainNode = audioContext.createGain();\r\n        return this.source = playSamples(this.sampleChannels, volume, playbackRate, pan, loop, this.sampleRate, this.gainNode);\r\n    }\r\n\r\n    /** Set the sound volume\r\n     *  @param {Number}  [volume] - How much to scale volume by\r\n     */\r\n    setVolume(volume=1)\r\n    {\r\n        if (this.gainNode)\r\n            this.gainNode.gain.value = volume;\r\n    }\r\n\r\n    /** Stop the last instance of this sound that was played */\r\n    stop()\r\n    {\r\n        if (this.source)\r\n            this.source.stop();\r\n        this.source = undefined;\r\n    }\r\n    \r\n    /** Get source of most recent instance of this sound that was played\r\n     *  @return {AudioBufferSourceNode}\r\n     */\r\n    getSource() { return this.source; }\r\n\r\n    /** Play the sound as a note with a semitone offset\r\n     *  @param {Number}  semitoneOffset - How many semitones to offset pitch\r\n     *  @param {Vector2} [pos] - World space position to play the sound, sound is not attenuated if null\r\n     *  @param {Number}  [volume=1] - How much to scale volume by (in addition to range fade)\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    playNote(semitoneOffset, pos, volume)\r\n    { return this.play(pos, volume, 2**(semitoneOffset/12), 0); }\r\n\r\n    /** Get how long this sound is in seconds\r\n     *  @return {Number} - How long the sound is in seconds (undefined if loading)\r\n     */\r\n    getDuration() \r\n    { return this.sampleChannels && this.sampleChannels[0].length / this.sampleRate; }\r\n    \r\n    /** Check if sound is loading, for sounds fetched from a url\r\n     *  @return {Boolean} - True if sound is loading and not ready to play\r\n     */\r\n    isLoading() { return !this.sampleChannels; }\r\n}\r\n\r\n/** \r\n * Sound Wave Object - Stores a wave sound for later use and can be played positionally\r\n * - this can be used to play wave, mp3, and ogg files\r\n * @example\r\n * // create a sound\r\n * const sound_example = new SoundWave('sound.mp3');\r\n * \r\n * // play the sound\r\n * sound_example.play();\r\n */\r\nclass SoundWave extends Sound\r\n{\r\n    /** Create a sound object and cache the wave file for later use\r\n     *  @param {String} filename - Filename of audio file to load\r\n     *  @param {Number} [randomness] - How much to randomize frequency each time sound plays\r\n     *  @param {Number} [range=soundDefaultRange] - World space max range of sound, will not play if camera is farther away\r\n     *  @param {Number} [taper=soundDefaultTaper] - At what percentage of range should it start tapering off\r\n     *  @param {Function} [onloadCallback] - callback function to call when sound is loaded\r\n     */\r\n    constructor(filename, randomness=0, range, taper, onloadCallback)\r\n    {\r\n        super(undefined, range, taper);\r\n        if (!soundEnable || headlessMode) return;\r\n\r\n        this.randomness = randomness;\r\n        fetch(filename)\r\n        .then(response => response.arrayBuffer())\r\n        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\r\n        .then(audioBuffer => \r\n        {\r\n            this.sampleChannels = [];\r\n            for (let i = audioBuffer.numberOfChannels; i--;)\r\n                this.sampleChannels[i] = Array.from(audioBuffer.getChannelData(i));\r\n            this.sampleRate = audioBuffer.sampleRate;\r\n        }).then(() => onloadCallback && onloadCallback(this));\r\n    }\r\n}\r\n\r\n/** Play an mp3, ogg, or wav audio from a local file or url\r\n *  @param {String}  filename - Location of sound file to play\r\n *  @param {Number}  [volume] - How much to scale volume by\r\n *  @param {Boolean} [loop] - True if the music should loop\r\n *  @return {SoundWave} - The sound object for this file\r\n *  @memberof Audio */\r\nfunction playAudioFile(filename, volume=1, loop=false)\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n\r\n    return new SoundWave(filename,0,0,0, s=>s.play(undefined, volume, 1, 1, loop));\r\n}\r\n\r\n/**\r\n * Music Object - Stores a zzfx music track for later use\r\n * \r\n * <a href=https://keithclark.github.io/ZzFXM/>Create music with the ZzFXM tracker.</a>\r\n * @example\r\n * // create some music\r\n * const music_example = new Music(\r\n * [\r\n *     [                         // instruments\r\n *       [,0,400]                // simple note\r\n *     ], \r\n *     [                         // patterns\r\n *         [                     // pattern 1\r\n *             [                 // channel 0\r\n *                 0, -1,        // instrument 0, left speaker\r\n *                 1, 0, 9, 1    // channel notes\r\n *             ], \r\n *             [                 // channel 1\r\n *                 0, 1,         // instrument 0, right speaker\r\n *                 0, 12, 17, -1 // channel notes\r\n *             ]\r\n *         ],\r\n *     ],\r\n *     [0, 0, 0, 0], // sequence, play pattern 0 four times\r\n *     90            // BPM\r\n * ]);\r\n * \r\n * // play the music\r\n * music_example.play();\r\n */\r\nclass Music extends Sound\r\n{\r\n    /** Create a music object and cache the zzfx music samples for later use\r\n     *  @param {[Array, Array, Array, Number]} zzfxMusic - Array of zzfx music parameters\r\n     */\r\n    constructor(zzfxMusic)\r\n    {\r\n        super(undefined);\r\n\r\n        if (!soundEnable || headlessMode) return;\r\n        this.randomness = 0;\r\n        this.sampleChannels = zzfxM(...zzfxMusic);\r\n        this.sampleRate = zzfxR;\r\n    }\r\n\r\n    /** Play the music\r\n     *  @param {Number}  [volume=1] - How much to scale volume by\r\n     *  @param {Boolean} [loop] - True if the music should loop\r\n     *  @return {AudioBufferSourceNode} - The audio source node\r\n     */\r\n    playMusic(volume, loop=false)\r\n    { return super.play(undefined, volume, 1, 1, loop); }\r\n}\r\n\r\n/** Speak text with passed in settings\r\n *  @param {String} text - The text to speak\r\n *  @param {String} [language] - The language/accent to use (examples: en, it, ru, ja, zh)\r\n *  @param {Number} [volume] - How much to scale volume by\r\n *  @param {Number} [rate] - How quickly to speak\r\n *  @param {Number} [pitch] - How much to change the pitch by\r\n *  @return {SpeechSynthesisUtterance} - The utterance that was spoken\r\n *  @memberof Audio */\r\nfunction speak(text, language='', volume=1, rate=1, pitch=1)\r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n    if (!speechSynthesis) return;\r\n\r\n    // common languages (not supported by all browsers)\r\n    // en - english,  it - italian, fr - french,  de - german, es - spanish\r\n    // ja - japanese, ru - russian, zh - chinese, hi - hindi,  ko - korean\r\n\r\n    // build utterance and speak\r\n    const utterance = new SpeechSynthesisUtterance(text);\r\n    utterance.lang = language;\r\n    utterance.volume = 2*volume*soundVolume;\r\n    utterance.rate = rate;\r\n    utterance.pitch = pitch;\r\n    speechSynthesis.speak(utterance);\r\n    return utterance;\r\n}\r\n\r\n/** Stop all queued speech\r\n *  @memberof Audio */\r\nfunction speakStop() {speechSynthesis && speechSynthesis.cancel();}\r\n\r\n/** Get frequency of a note on a musical scale\r\n *  @param {Number} semitoneOffset - How many semitones away from the root note\r\n *  @param {Number} [rootFrequency=220] - Frequency at semitone offset 0\r\n *  @return {Number} - The frequency of the note\r\n *  @memberof Audio */\r\nfunction getNoteFrequency(semitoneOffset, rootFrequency=220)\r\n{ return rootFrequency * 2**(semitoneOffset/12); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// internal tracking if audio was suspended when last sound was played\r\n// allows first suspended sound to play when audio is resumed\r\nlet audioSuspended = false;\r\n\r\n/** Play cached audio samples with given settings\r\n *  @param {Array}    sampleChannels - Array of arrays of samples to play (for stereo playback)\r\n *  @param {Number}   [volume] - How much to scale volume by\r\n *  @param {Number}   [rate] - The playback rate to use\r\n *  @param {Number}   [pan] - How much to apply stereo panning\r\n *  @param {Boolean}  [loop] - True if the sound should loop when it reaches the end\r\n *  @param {Number}   [sampleRate=44100] - Sample rate for the sound\r\n *  @param {GainNode} [gainNode] - Optional gain node for volume control while playing\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */\r\nfunction playSamples(sampleChannels, volume=1, rate=1, pan=0, loop=false, sampleRate=zzfxR, gainNode) \r\n{\r\n    if (!soundEnable || headlessMode) return;\r\n\r\n    // prevent sounds from building up if they can't be played\r\n    const audioWasSuspended = audioSuspended;\r\n    if (audioSuspended = audioContext.state != 'running')\r\n    {\r\n        // fix stalled audio\r\n        audioContext.resume();\r\n\r\n        // prevent suspended sounds from building up\r\n        if (audioWasSuspended)\r\n            return;\r\n    }\r\n\r\n    // create buffer and source\r\n    const buffer = audioContext.createBuffer(sampleChannels.length, sampleChannels[0].length, sampleRate), \r\n        source = audioContext.createBufferSource();\r\n\r\n    // copy samples to buffer and setup source\r\n    sampleChannels.forEach((c,i)=> buffer.getChannelData(i).set(c));\r\n    source.buffer = buffer;\r\n    source.playbackRate.value = rate;\r\n    source.loop = loop;\r\n\r\n    // create and connect gain node\r\n    gainNode = gainNode || audioContext.createGain();\r\n    gainNode.gain.value = volume;\r\n    gainNode.connect(audioGainNode);\r\n\r\n    // connect source to stereo panner and gain\r\n    source.connect(new StereoPannerNode(audioContext, {'pan':clamp(pan, -1, 1)})).connect(gainNode);\r\n\r\n    // play and return sound\r\n    source.start();\r\n    return source;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// ZzFXMicro - Zuper Zmall Zound Zynth - v1.3.1 by Frank Force\r\n\r\n/** Generate and play a ZzFX sound\r\n *  \r\n *  <a href=https://killedbyapixel.github.io/ZzFX/>Create sounds using the ZzFX Sound Designer.</a>\r\n *  @param {Array} zzfxSound - Array of ZzFX parameters, ex. [.5,.5]\r\n *  @return {AudioBufferSourceNode} - The audio node of the sound played\r\n *  @memberof Audio */\r\nfunction zzfx(...zzfxSound) { return new Sound(zzfxSound).play(); }\r\n\r\n/** Sample rate used for all ZzFX sounds\r\n *  @default 44100\r\n *  @memberof Audio */\r\nconst zzfxR = 44100; \r\n\r\n/** Generate samples for a ZzFX sound\r\n *  @param {Number}  [volume] - Volume scale (percent)\r\n *  @param {Number}  [randomness] - Unused in this fuction, handled by Sound class\r\n *  @param {Number}  [frequency] - Frequency of sound (Hz)\r\n *  @param {Number}  [attack] - Attack time, how fast sound starts (seconds)\r\n *  @param {Number}  [sustain] - Sustain time, how long sound holds (seconds)\r\n *  @param {Number}  [release] - Release time, how fast sound fades out (seconds)\r\n *  @param {Number}  [shape] - Shape of the sound wave\r\n *  @param {Number}  [shapeCurve] - Squarenes of wave (0=square, 1=normal, 2=pointy)\r\n *  @param {Number}  [slide] - How much to slide frequency (kHz/s)\r\n *  @param {Number}  [deltaSlide] - How much to change slide (kHz/s/s)\r\n *  @param {Number}  [pitchJump] - Frequency of pitch jump (Hz)\r\n *  @param {Number}  [pitchJumpTime] - Time of pitch jump (seconds)\r\n *  @param {Number}  [repeatTime] - Resets some parameters periodically (seconds)\r\n *  @param {Number}  [noise] - How much random noise to add (percent)\r\n *  @param {Number}  [modulation] - Frequency of modulation wave, negative flips phase (Hz)\r\n *  @param {Number}  [bitCrush] - Resamples at a lower frequency in (samples*100)\r\n *  @param {Number}  [delay] - Overlap sound with itself for reverb and flanger effects (seconds)\r\n *  @param {Number}  [sustainVolume] - Volume level for sustain (percent)\r\n *  @param {Number}  [decay] - Decay time, how long to reach sustain after attack (seconds)\r\n *  @param {Number}  [tremolo] - Trembling effect, rate controlled by repeat time (precent)\r\n *  @param {Number}  [filter] - Filter cutoff frequency, positive for HPF, negative for LPF (Hz)\r\n *  @return {Array} - Array of audio samples\r\n *  @memberof Audio\r\n */\r\nfunction zzfxG\r\n(\r\n    // parameters\r\n    volume = 1, randomness = 0, frequency = 220, attack = 0, sustain = 0,\r\n    release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0,\r\n    pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0,\r\n    bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0, filter = 0\r\n)\r\n{\r\n    // LJS Note: ZZFX modded so randomness is handled by Sound class\r\n\r\n    // init parameters\r\n    let PI2 = PI*2, sampleRate = zzfxR,\r\n        startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,\r\n        startFrequency = frequency *= PI2 / sampleRate,\r\n        b = [], t = 0, tm = 0, i = 0, j = 1, r = 0, c = 0, s = 0, f, length,\r\n\r\n        // biquad LP/HP filter\r\n        quality = 2, w = PI2 * abs(filter) * 2 / sampleRate,\r\n        cos = Math.cos(w), alpha = Math.sin(w) / 2 / quality,\r\n        a0 = 1 + alpha, a1 = -2*cos / a0, a2 = (1 - alpha) / a0,\r\n        b0 = (1 + sign(filter) * cos) / 2 / a0, \r\n        b1 = -(sign(filter) + cos) / a0, b2 = b0,\r\n        x2 = 0, x1 = 0, y2 = 0, y1 = 0;\r\n\r\n    // scale by sample rate\r\n    attack = attack * sampleRate + 9; // minimum attack to prevent pop\r\n    decay *= sampleRate;\r\n    sustain *= sampleRate;\r\n    release *= sampleRate;\r\n    delay *= sampleRate;\r\n    deltaSlide *= 500 * PI2 / sampleRate**3;\r\n    modulation *= PI2 / sampleRate;\r\n    pitchJump *= PI2 / sampleRate;\r\n    pitchJumpTime *= sampleRate;\r\n    repeatTime = repeatTime * sampleRate | 0;\r\n\r\n    // generate waveform\r\n    for(length = attack + decay + sustain + release + delay | 0;\r\n        i < length; b[i++] = s * volume)               // sample\r\n    {\r\n        if (!(++c%(bitCrush*100|0)))                   // bit crush\r\n        {\r\n            s = shape? shape>1? shape>2? shape>3?      // wave shape\r\n                Math.sin(t**3) :                       // 4 noise\r\n                clamp(Math.tan(t),1,-1):               // 3 tan\r\n                1-(2*t/PI2%2+2)%2:                     // 2 saw\r\n                1-4*abs(Math.round(t/PI2)-t/PI2):      // 1 triangle\r\n                Math.sin(t);                           // 0 sin\r\n\r\n            s = (repeatTime ?\r\n                    1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo\r\n                    : 1) *\r\n                sign(s)*(abs(s)**shapeCurve) *           // curve\r\n                (i < attack ? i/attack :                 // attack\r\n                i < attack + decay ?                     // decay\r\n                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff\r\n                i < attack  + decay + sustain ?          // sustain\r\n                sustainVolume :                          // sustain volume\r\n                i < length - delay ?                     // release\r\n                (length - i - delay)/release *           // release falloff\r\n                sustainVolume :                          // release volume\r\n                0);                                      // post release\r\n\r\n            s = delay ? s/2 + (delay > i ? 0 :           // delay\r\n                (i<length-delay? 1 : (length-i)/delay) * // release delay \r\n                b[i-delay|0]/2/volume) : s;              // sample delay\r\n\r\n            if (filter)                                   // apply filter\r\n                s = y1 = b2*x2 + b1*(x2=x1) + b0*(x1=s) - a2*y2 - a1*(y2=y1);\r\n        }\r\n\r\n        f = (frequency += slide += deltaSlide) *// frequency\r\n            Math.cos(modulation*tm++);          // modulation\r\n        t += f + f*noise*Math.sin(i**5);        // noise\r\n\r\n        if (j && ++j > pitchJumpTime)           // pitch jump\r\n        { \r\n            frequency += pitchJump;             // apply pitch jump\r\n            startFrequency += pitchJump;        // also apply to start\r\n            j = 0;                              // stop pitch jump time\r\n        } \r\n\r\n        if (repeatTime && !(++r % repeatTime))  // repeat\r\n        { \r\n            frequency = startFrequency;         // reset frequency\r\n            slide = startSlide;                 // reset slide\r\n            j = j || 1;                         // reset pitch jump time\r\n        }\r\n    }\r\n\r\n    return b;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// ZzFX Music Renderer v2.0.3 by Keith Clark and Frank Force\r\n\r\n/** Generate samples for a ZzFM song with given parameters\r\n *  @param {Array} instruments - Array of ZzFX sound paramaters\r\n *  @param {Array} patterns - Array of pattern data\r\n *  @param {Array} sequence - Array of pattern indexes\r\n *  @param {Number} [BPM] - Playback speed of the song in BPM\r\n *  @return {Array} - Left and right channel sample data\r\n *  @memberof Audio */\r\nfunction zzfxM(instruments, patterns, sequence, BPM = 125) \r\n{\r\n  let i, j, k;\r\n  let instrumentParameters;\r\n  let note;\r\n  let sample;\r\n  let patternChannel;\r\n  let notFirstBeat;\r\n  let stop;\r\n  let instrument;\r\n  let attenuation;\r\n  let outSampleOffset;\r\n  let isSequenceEnd;\r\n  let sampleOffset = 0;\r\n  let nextSampleOffset;\r\n  let sampleBuffer = [];\r\n  let leftChannelBuffer = [];\r\n  let rightChannelBuffer = [];\r\n  let channelIndex = 0;\r\n  let panning = 0;\r\n  let hasMore = 1;\r\n  let sampleCache = {};\r\n  let beatLength = zzfxR / BPM * 60 >> 2;\r\n\r\n  // for each channel in order until there are no more\r\n  for (; hasMore; channelIndex++) {\r\n\r\n    // reset current values\r\n    sampleBuffer = [hasMore = notFirstBeat = outSampleOffset = 0];\r\n\r\n    // for each pattern in sequence\r\n    sequence.forEach((patternIndex, sequenceIndex) => {\r\n      // get pattern for current channel, use empty 1 note pattern if none found\r\n      patternChannel = patterns[patternIndex][channelIndex] || [0, 0, 0];\r\n\r\n      // check if there are more channels\r\n      hasMore |= patterns[patternIndex][channelIndex]&&1;\r\n\r\n      // get next offset, use the length of first channel\r\n      nextSampleOffset = outSampleOffset + (patterns[patternIndex][0].length - 2 - (notFirstBeat?0:1)) * beatLength;\r\n      // for each beat in pattern, plus one extra if end of sequence\r\n      isSequenceEnd = sequenceIndex == sequence.length - 1;\r\n      for (i = 2, k = outSampleOffset; i < patternChannel.length + isSequenceEnd; notFirstBeat = ++i) {\r\n\r\n        // <channel-note>\r\n        note = patternChannel[i];\r\n\r\n        // stop if end, different instrument or new note\r\n        stop = i == patternChannel.length + isSequenceEnd - 1 && isSequenceEnd ||\r\n            instrument != (patternChannel[0] || 0) || note | 0;\r\n\r\n        // fill buffer with samples for previous beat, most cpu intensive part\r\n        for (j = 0; j < beatLength && notFirstBeat;\r\n\r\n            // fade off attenuation at end of beat if stopping note, prevents clicking\r\n            j++ > beatLength - 99 && stop && attenuation < 1? attenuation += 1 / 99 : 0\r\n        ) {\r\n          // copy sample to stereo buffers with panning\r\n          sample = (1 - attenuation) * sampleBuffer[sampleOffset++] / 2 || 0;\r\n          leftChannelBuffer[k] = (leftChannelBuffer[k] || 0) - sample * panning + sample;\r\n          rightChannelBuffer[k] = (rightChannelBuffer[k++] || 0) + sample * panning + sample;\r\n        }\r\n\r\n        // set up for next note\r\n        if (note) {\r\n          // set attenuation\r\n          attenuation = note % 1;\r\n          panning = patternChannel[1] || 0;\r\n          if (note |= 0) {\r\n            // get cached sample\r\n            sampleBuffer = sampleCache[\r\n              [\r\n                instrument = patternChannel[sampleOffset = 0] || 0,\r\n                note\r\n              ]\r\n            ] = sampleCache[[instrument, note]] || (\r\n                // add sample to cache\r\n                instrumentParameters = [...instruments[instrument]],\r\n                instrumentParameters[2] *= 2 ** ((note - 12) / 12),\r\n\r\n                // allow negative values to stop notes\r\n                note > 0 ? zzfxG(...instrumentParameters) : []\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // update the sample offset\r\n      outSampleOffset = nextSampleOffset;\r\n    });\r\n  }\r\n\r\n  return [leftChannelBuffer, rightChannelBuffer];\r\n}\n/** \r\n * LittleJS Tile Layer System\r\n * - Caches arrays of tiles to off screen canvas for fast rendering\r\n * - Unlimited numbers of layers, allocates canvases as needed\r\n * - Interfaces with EngineObject for collision\r\n * - Collision layer is separate from visible layers\r\n * - It is recommended to have a visible layer that matches the collision\r\n * - Tile layers can be drawn to using their context with canvas2d\r\n * - Drawn directly to the main canvas without using WebGL\r\n * @namespace TileCollision\r\n */\r\n\r\n\r\n\r\n/** The tile collision layer array, use setTileCollisionData and getTileCollisionData to access\r\n *  @type {Array} \r\n *  @memberof TileCollision */\r\nlet tileCollision = [];\r\n\r\n/** Size of the tile collision layer\r\n *  @type {Vector2} \r\n *  @memberof TileCollision */\r\nlet tileCollisionSize = vec2();\r\n\r\n/** Clear and initialize tile collision\r\n *  @param {Vector2} size\r\n *  @memberof TileCollision */\r\nfunction initTileCollision(size)\r\n{\r\n    tileCollisionSize = size;\r\n    tileCollision = [];\r\n    for (let i=tileCollision.length = tileCollisionSize.area(); i--;)\r\n        tileCollision[i] = 0;\r\n}\r\n\r\n/** Set tile collision data\r\n *  @param {Vector2} pos\r\n *  @param {Number}  [data]\r\n *  @memberof TileCollision */\r\nfunction setTileCollisionData(pos, data=0)\r\n{\r\n    pos.arrayCheck(tileCollisionSize) && (tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] = data);\r\n}\r\n\r\n/** Get tile collision data\r\n *  @param {Vector2} pos\r\n *  @return {Number}\r\n *  @memberof TileCollision */\r\nfunction getTileCollisionData(pos)\r\n{\r\n    return pos.arrayCheck(tileCollisionSize) ? tileCollision[(pos.y|0)*tileCollisionSize.x+pos.x|0] : 0;\r\n}\r\n\r\n/** Check if collision with another object should occur\r\n *  @param {Vector2}      pos\r\n *  @param {Vector2}      [size=(0,0)]\r\n *  @param {EngineObject} [object]\r\n *  @return {Boolean}\r\n *  @memberof TileCollision */\r\nfunction tileCollisionTest(pos, size=vec2(), object)\r\n{\r\n    const minX = max(pos.x - size.x/2|0, 0);\r\n    const minY = max(pos.y - size.y/2|0, 0);\r\n    const maxX = min(pos.x + size.x/2, tileCollisionSize.x);\r\n    const maxY = min(pos.y + size.y/2, tileCollisionSize.y);\r\n    for (let y = minY; y < maxY; ++y)\r\n    for (let x = minX; x < maxX; ++x)\r\n    {\r\n        const tileData = tileCollision[y*tileCollisionSize.x+x];\r\n        if (tileData && (!object || object.collideWithTile(tileData, vec2(x, y))))\r\n            return true;\r\n    }\r\n}\r\n\r\n/** Return the center of first tile hit (does not return the exact intersection)\r\n *  @param {Vector2}      posStart\r\n *  @param {Vector2}      posEnd\r\n *  @param {EngineObject} [object]\r\n *  @return {Vector2}\r\n *  @memberof TileCollision */\r\nfunction tileCollisionRaycast(posStart, posEnd, object)\r\n{\r\n    // test if a ray collides with tiles from start to end\r\n    // todo: a way to get the exact hit point, it must still be inside the hit tile\r\n    const delta = posEnd.subtract(posStart);\r\n    const totalLength = delta.length();\r\n    const normalizedDelta = delta.normalize();\r\n    const unit = vec2(abs(1/normalizedDelta.x), abs(1/normalizedDelta.y));\r\n    const flooredPosStart = posStart.floor();\r\n\r\n    // setup iteration variables\r\n    let pos = flooredPosStart;\r\n    let xi = unit.x * (delta.x < 0 ? posStart.x - pos.x : pos.x - posStart.x + 1);\r\n    let yi = unit.y * (delta.y < 0 ? posStart.y - pos.y : pos.y - posStart.y + 1);\r\n\r\n    while (1)\r\n    {\r\n        // check for tile collision\r\n        const tileData = getTileCollisionData(pos);\r\n        if (tileData && (!object || object.collideWithTile(tileData, pos)))\r\n        {\r\n            debugRaycast && debugLine(posStart, posEnd, '#f00', .02);\r\n            debugRaycast && debugPoint(pos.add(vec2(.5)), '#ff0');\r\n            return pos.add(vec2(.5));\r\n        }\r\n\r\n        // check if past the end\r\n        if (xi > totalLength && yi > totalLength)\r\n            break;\r\n\r\n        // get coordinates of the next tile to check\r\n        if (xi > yi)\r\n            pos.y += sign(delta.y), yi += unit.y;\r\n        else\r\n            pos.x += sign(delta.x), xi += unit.x;\r\n    }\r\n\r\n    debugRaycast && debugLine(posStart, posEnd, '#00f', .02);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Tile Layer Rendering System\r\n\r\n/**\r\n * Tile layer data object stores info about how to render a tile\r\n * @example\r\n * // create tile layer data with tile index 0 and random orientation and color\r\n * const tileIndex = 0;\r\n * const direction = randInt(4)\r\n * const mirror = randInt(2);\r\n * const color = randColor();\r\n * const data = new TileLayerData(tileIndex, direction, mirror, color);\r\n */\r\nclass TileLayerData\r\n{\r\n    /** Create a tile layer data object, one for each tile in a TileLayer\r\n     *  @param {Number}  [tile]      - The tile to use, untextured if undefined\r\n     *  @param {Number}  [direction] - Integer direction of tile, in 90 degree increments\r\n     *  @param {Boolean} [mirror]    - If the tile should be mirrored along the x axis\r\n     *  @param {Color}   [color]     - Color of the tile */\r\n    constructor(tile, direction=0, mirror=false, color=new Color)\r\n    {\r\n        /** @property {Number}  - The tile to use, untextured if undefined */\r\n        this.tile      = tile;\r\n        /** @property {Number}  - Integer direction of tile, in 90 degree increments */\r\n        this.direction = direction;\r\n        /** @property {Boolean} - If the tile should be mirrored along the x axis */\r\n        this.mirror    = mirror;\r\n        /** @property {Color}   - Color of the tile */\r\n        this.color     = color;\r\n    }\r\n\r\n    /** Set this tile to clear, it will not be rendered */\r\n    clear() { this.tile = this.direction = 0; this.mirror = false; this.color = new Color; }\r\n}\r\n\r\n/**\r\n * Tile Layer - cached rendering system for tile layers\r\n * - Each Tile layer is rendered to an off screen canvas\r\n * - To allow dynamic modifications, layers are rendered using canvas 2d\r\n * - Some devices like mobile phones are limited to 4k texture resolution\r\n * - So with 16x16 tiles this limits layers to 256x256 on mobile devices\r\n * @extends EngineObject\r\n * @example\r\n * // create tile collision and visible tile layer\r\n * initTileCollision(vec2(200,100));\r\n * const tileLayer = new TileLayer();\r\n */\r\nclass TileLayer extends EngineObject\r\n{\r\n    /** Create a tile layer object\r\n    *  @param {Vector2}  [position=(0,0)]     - World space position\r\n    *  @param {Vector2}  [size=tileCollisionSize] - World space size\r\n    *  @param {TileInfo} [tileInfo]    - Tile info for layer\r\n    *  @param {Vector2}  [scale=(1,1)] - How much to scale this layer when rendered\r\n    *  @param {Number}   [renderOrder] - Objects are sorted by renderOrder\r\n    */\r\n    constructor(position, size=tileCollisionSize, tileInfo=tile(), scale=vec2(1), renderOrder=0)\r\n    {\r\n        super(position, size, tileInfo, 0, undefined, renderOrder);\r\n\r\n        /** @property {HTMLCanvasElement} - The canvas used by this tile layer */\r\n        this.canvas = document.createElement('canvas');\r\n        /** @property {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} - The 2D canvas context used by this tile layer */\r\n        this.context = this.canvas.getContext('2d');\r\n        /** @property {Vector2} - How much to scale this layer when rendered */\r\n        this.scale = scale;\r\n        /** @property {Boolean} - If true this layer will render to overlay canvas and appear above all objects */\r\n        this.isOverlay = false;\r\n\r\n        // init tile data\r\n        this.data = [];\r\n        for (let j = this.size.area(); j--;)\r\n            this.data.push(new TileLayerData);\r\n\r\n        if (headlessMode)\r\n        {\r\n            // disable rendering\r\n            this.redraw       = () => {};\r\n            this.render       = () => {};\r\n            this.redrawStart  = () => {};\r\n            this.redrawEnd    = () => {};\r\n            this.drawTileData = () => {};\r\n            this.drawCanvas2D = () => {};\r\n        }\r\n    }\r\n    \r\n    /** Set data at a given position in the array \r\n     *  @param {Vector2}       layerPos - Local position in array\r\n     *  @param {TileLayerData} data     - Data to set\r\n     *  @param {Boolean}       [redraw] - Force the tile to redraw if true */\r\n    setData(layerPos, data, redraw=false)\r\n    {\r\n        if (layerPos.arrayCheck(this.size))\r\n        {\r\n            this.data[(layerPos.y|0)*this.size.x+layerPos.x|0] = data;\r\n            redraw && this.drawTileData(layerPos);\r\n        }\r\n    }\r\n    \r\n    /** Get data at a given position in the array \r\n     *  @param {Vector2} layerPos - Local position in array\r\n     *  @return {TileLayerData} */\r\n    getData(layerPos)\r\n    { return layerPos.arrayCheck(this.size) && this.data[(layerPos.y|0)*this.size.x+layerPos.x|0]; }\r\n    \r\n    // Tile layers are not updated\r\n    update() {}\r\n\r\n    // Render the tile layer, called automatically by the engine\r\n    render()\r\n    {\r\n        ASSERT(mainContext != this.context, 'must call redrawEnd() after drawing tiles');\r\n\r\n        // flush and copy gl canvas because tile canvas does not use webgl\r\n        !glOverlay && !this.isOverlay && glCopyToContext(mainContext);\r\n        \r\n        // draw the entire cached level onto the canvas\r\n        const pos = worldToScreen(this.pos.add(vec2(0,this.size.y*this.scale.y)));\r\n        (this.isOverlay ? overlayContext : mainContext).drawImage\r\n        (\r\n            this.canvas, pos.x, pos.y,\r\n            cameraScale*this.size.x*this.scale.x, cameraScale*this.size.y*this.scale.y\r\n        );\r\n    }\r\n\r\n    /** Draw all the tile data to an offscreen canvas \r\n     *  - This may be slow in some browsers but only needs to be done once */\r\n    redraw()\r\n    {\r\n        this.redrawStart(true);\r\n        for (let x = this.size.x; x--;)\r\n        for (let y = this.size.y; y--;)\r\n            this.drawTileData(vec2(x,y), false);\r\n        this.redrawEnd();\r\n    }\r\n\r\n    /** Call to start the redraw process\r\n     *  - This can be used to manually update small parts of the level\r\n     *  @param {Boolean} [clear] - Should it clear the canvas before drawing */\r\n    redrawStart(clear=false)\r\n    {\r\n        // save current render settings\r\n        /** @type {[HTMLCanvasElement, CanvasRenderingContext2D, Vector2, Vector2, number]} */\r\n        this.savedRenderSettings = [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale];\r\n\r\n        // use webgl rendering system to render the tiles if enabled\r\n        // this works by temporally taking control of the rendering system\r\n        mainCanvas = this.canvas;\r\n        mainContext = this.context;\r\n        mainCanvasSize = this.size.multiply(this.tileInfo.size);\r\n        cameraPos = this.size.scale(.5);\r\n        cameraScale = this.tileInfo.size.x;\r\n\r\n        if (clear)\r\n        {\r\n            // clear and set size\r\n            mainCanvas.width  = mainCanvasSize.x;\r\n            mainCanvas.height = mainCanvasSize.y;\r\n        }\r\n\r\n        // disable smoothing for pixel art\r\n        this.context.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        // setup gl rendering if enabled\r\n        glPreRender();\r\n    }\r\n\r\n    /** Call to end the redraw process */\r\n    redrawEnd()\r\n    {\r\n        ASSERT(mainContext == this.context, 'must call redrawStart() before drawing tiles');\r\n        glCopyToContext(mainContext, true);\r\n        //debugSaveCanvas(this.canvas);\r\n\r\n        // set stuff back to normal\r\n        [mainCanvas, mainContext, mainCanvasSize, cameraPos, cameraScale] = this.savedRenderSettings;\r\n    }\r\n\r\n    /** Draw the tile at a given position in the tile grid\r\n     *  This can be used to clear out tiles when they are destroyed\r\n     *  Tiles can also be redrawn if isinde a redrawStart/End block\r\n     *  @param {Vector2} layerPos \r\n     *  @param {Boolean} [clear] - should the old tile be cleared out\r\n     */\r\n    drawTileData(layerPos, clear=true)\r\n    {\r\n        // clear out where the tile was, for full opaque tiles this can be skipped\r\n        const s = this.tileInfo.size;\r\n        if (clear)\r\n        {\r\n            const pos = layerPos.multiply(s);\r\n            this.context.clearRect(pos.x, this.canvas.height-pos.y, s.x, -s.y);\r\n        }\r\n\r\n        // draw the tile if not undefined\r\n        const d = this.getData(layerPos);\r\n        if (d.tile != undefined)\r\n        {\r\n            const pos = this.pos.add(layerPos).add(vec2(.5));\r\n            ASSERT(mainContext == this.context, 'must call redrawStart() before drawing tiles');\r\n            const tileInfo = tile(d.tile, s, this.tileInfo.textureIndex);\r\n            drawTile(pos, vec2(1), tileInfo, d.color, d.direction*PI/2, d.mirror);\r\n        }\r\n    }\r\n\r\n    /** Draw directly to the 2D canvas in world space (bipass webgl)\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  size\r\n     *  @param {Number}   angle\r\n     *  @param {Boolean}  mirror\r\n     *  @param {Function} drawFunction */\r\n    drawCanvas2D(pos, size, angle, mirror, drawFunction)\r\n    {\r\n        const context = this.context;\r\n        context.save();\r\n        pos = pos.subtract(this.pos).multiply(this.tileInfo.size);\r\n        size = size.multiply(this.tileInfo.size);\r\n        context.translate(pos.x, this.canvas.height - pos.y);\r\n        context.rotate(angle);\r\n        context.scale(mirror ? -size.x : size.x, size.y);\r\n        drawFunction(context);\r\n        context.restore();\r\n    }\r\n\r\n    /** Draw a tile directly onto the layer canvas in world space\r\n     *  @param {Vector2}  pos\r\n     *  @param {Vector2}  [size=(1,1)]\r\n     *  @param {TileInfo} [tileInfo]\r\n     *  @param {Color}    [color=(1,1,1,1)]\r\n     *  @param {Number}   [angle=0]\r\n     *  @param {Boolean}  [mirror=0] */\r\n    drawTile(pos, size=vec2(1), tileInfo, color=new Color, angle, mirror)\r\n    {\r\n        this.drawCanvas2D(pos, size, angle, mirror, (context)=>\r\n        {\r\n            const textureInfo = tileInfo && tileInfo.getTextureInfo();\r\n            if (textureInfo)\r\n            {\r\n                context.globalAlpha = color.a; // only alpha is supported\r\n                context.drawImage(textureInfo.image, \r\n                    tileInfo.pos.x,  tileInfo.pos.y, \r\n                    tileInfo.size.x, tileInfo.size.y, -.5, -.5, 1, 1);\r\n                context.globalAlpha = 1;\r\n            }\r\n            else\r\n            {\r\n                // untextured\r\n                context.fillStyle = color;\r\n                context.fillRect(-.5, -.5, 1, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Draw a rectangle directly onto the layer canvas in world space\r\n     *  @param {Vector2} pos\r\n     *  @param {Vector2} [size=(1,1)]\r\n     *  @param {Color}   [color=(1,1,1,1)]\r\n     *  @param {Number}  [angle=0] */\r\n    drawRect(pos, size, color, angle) \r\n    { this.drawTile(pos, size, undefined, color, angle); }\r\n}\n/** \r\n * LittleJS Particle System\r\n */\r\n\r\n\r\n\r\n/**\r\n * Particle Emitter - Spawns particles with the given settings\r\n * @extends EngineObject\r\n * @example\r\n * // create a particle emitter\r\n * let pos = vec2(2,3);\r\n * let particleEmitter = new ParticleEmitter\r\n * (\r\n *     pos, 0, 1, 0, 500, PI,      // pos, angle, emitSize, emitTime, emitRate, emiteCone\r\n *     tile(0, 16),                // tileInfo\r\n *     rgb(1,1,1),   rgb(0,0,0),   // colorStartA, colorStartB\r\n *     rgb(1,1,1,0), rgb(0,0,0,0), // colorEndA, colorEndB\r\n *     2, .2, .2, .1, .05,  // particleTime, sizeStart, sizeEnd, particleSpeed, particleAngleSpeed\r\n *     .99, 1, 1, PI, .05,  // damping, angleDamping, gravityScale, particleCone, fadeRate, \r\n *     .5, 1                // randomness, collide, additive, randomColorLinear, renderOrder\r\n * );\r\n */\r\nclass ParticleEmitter extends EngineObject\r\n{\r\n    /** Create a particle system with the given settings\r\n     *  @param {Vector2} position - World space position of the emitter\r\n     *  @param {Number} [angle] - Angle to emit the particles\r\n     *  @param {Number|Vector2}  [emitSize] - World space size of the emitter (float for circle diameter, vec2 for rect)\r\n     *  @param {Number} [emitTime] - How long to stay alive (0 is forever)\r\n     *  @param {Number} [emitRate] - How many particles per second to spawn, does not emit if 0\r\n     *  @param {Number} [emitConeAngle=PI] - Local angle to apply velocity to particles from emitter\r\n     *  @param {TileInfo} [tileInfo] - Tile info to render particles (undefined is untextured)\r\n     *  @param {Color} [colorStartA=(1,1,1,1)] - Color at start of life 1, randomized between start colors\r\n     *  @param {Color} [colorStartB=(1,1,1,1)] - Color at start of life 2, randomized between start colors\r\n     *  @param {Color} [colorEndA=(1,1,1,0)] - Color at end of life 1, randomized between end colors\r\n     *  @param {Color} [colorEndB=(1,1,1,0)] - Color at end of life 2, randomized between end colors\r\n     *  @param {Number} [particleTime]      - How long particles live\r\n     *  @param {Number} [sizeStart]         - How big are particles at start\r\n     *  @param {Number} [sizeEnd]           - How big are particles at end\r\n     *  @param {Number} [speed]             - How fast are particles when spawned\r\n     *  @param {Number} [angleSpeed]        - How fast are particles rotating\r\n     *  @param {Number} [damping]           - How much to dampen particle speed\r\n     *  @param {Number} [angleDamping]      - How much to dampen particle angular speed\r\n     *  @param {Number} [gravityScale]      - How much gravity effect particles\r\n     *  @param {Number} [particleConeAngle] - Cone for start particle angle\r\n     *  @param {Number} [fadeRate]          - How quick to fade particles at start/end in percent of life\r\n     *  @param {Number} [randomness]    - Apply extra randomness percent\r\n     *  @param {Boolean} [collideTiles] - Do particles collide against tiles\r\n     *  @param {Boolean} [additive]     - Should particles use addtive blend\r\n     *  @param {Boolean} [randomColorLinear] - Should color be randomized linearly or across each component\r\n     *  @param {Number} [renderOrder] - Render order for particles (additive is above other stuff by default)\r\n     *  @param {Boolean}  [localSpace] - Should it be in local space of emitter (world space is default)\r\n     */\r\n    constructor\r\n    ( \r\n        position,\r\n        angle,\r\n        emitSize = 0,\r\n        emitTime = 0,\r\n        emitRate = 100,\r\n        emitConeAngle = PI,\r\n        tileInfo,\r\n        colorStartA = new Color,\r\n        colorStartB = new Color,\r\n        colorEndA = new Color(1,1,1,0),\r\n        colorEndB = new Color(1,1,1,0),\r\n        particleTime = .5,\r\n        sizeStart = .1,\r\n        sizeEnd = 1,\r\n        speed = .1,\r\n        angleSpeed = .05,\r\n        damping = 1,\r\n        angleDamping = 1,\r\n        gravityScale = 0,\r\n        particleConeAngle = PI,\r\n        fadeRate = .1,\r\n        randomness = .2, \r\n        collideTiles = false,\r\n        additive = false,\r\n        randomColorLinear = true,\r\n        renderOrder = additive ? 1e9 : 0,\r\n        localSpace = false\r\n    )\r\n    {\r\n        super(position, vec2(), tileInfo, angle, undefined, renderOrder);\r\n\r\n        // emitter settings\r\n        /** @property {Number|Vector2} - World space size of the emitter (float for circle diameter, vec2 for rect) */\r\n        this.emitSize = emitSize\r\n        /** @property {Number} - How long to stay alive (0 is forever) */\r\n        this.emitTime = emitTime;\r\n        /** @property {Number} - How many particles per second to spawn, does not emit if 0 */\r\n        this.emitRate = emitRate;\r\n        /** @property {Number} - Local angle to apply velocity to particles from emitter */\r\n        this.emitConeAngle = emitConeAngle;\r\n\r\n        // color settings\r\n        /** @property {Color} - Color at start of life 1, randomized between start colors */\r\n        this.colorStartA = colorStartA;\r\n        /** @property {Color} - Color at start of life 2, randomized between start colors */\r\n        this.colorStartB = colorStartB;\r\n        /** @property {Color} - Color at end of life 1, randomized between end colors */\r\n        this.colorEndA   = colorEndA;\r\n        /** @property {Color} - Color at end of life 2, randomized between end colors */\r\n        this.colorEndB   = colorEndB;\r\n        /** @property {Boolean} - Should color be randomized linearly or across each component */\r\n        this.randomColorLinear = randomColorLinear;\r\n\r\n        // particle settings\r\n        /** @property {Number} - How long particles live */\r\n        this.particleTime      = particleTime;\r\n        /** @property {Number} - How big are particles at start */\r\n        this.sizeStart         = sizeStart;\r\n        /** @property {Number} - How big are particles at end */\r\n        this.sizeEnd           = sizeEnd;\r\n        /** @property {Number} - How fast are particles when spawned */\r\n        this.speed             = speed;\r\n        /** @property {Number} - How fast are particles rotating */\r\n        this.angleSpeed        = angleSpeed;\r\n        /** @property {Number} - How much to dampen particle speed */\r\n        this.damping           = damping;\r\n        /** @property {Number} - How much to dampen particle angular speed */\r\n        this.angleDamping      = angleDamping;\r\n        /** @property {Number} - How much does gravity effect particles */\r\n        this.gravityScale      = gravityScale;\r\n        /** @property {Number} - Cone for start particle angle */\r\n        this.particleConeAngle = particleConeAngle;\r\n        /** @property {Number} - How quick to fade in particles at start/end in percent of life */\r\n        this.fadeRate          = fadeRate;\r\n        /** @property {Number} - Apply extra randomness percent */\r\n        this.randomness        = randomness;\r\n        /** @property {Boolean} - Do particles collide against tiles */\r\n        this.collideTiles      = collideTiles;\r\n        /** @property {Boolean} - Should particles use addtive blend */\r\n        this.additive          = additive;\r\n        /** @property {Boolean} - Should it be in local space of emitter */\r\n        this.localSpace        = localSpace;\r\n        /** @property {Number} - If non zero the partile is drawn as a trail, stretched in the drection of velocity */\r\n        this.trailScale        = 0;\r\n        /** @property {Function}   - Callback when particle is destroyed */\r\n        this.particleDestroyCallback = undefined;\r\n        /** @property {Function}   - Callback when particle is created */\r\n        this.particleCreateCallback = undefined;\r\n        /** @property {Number} - Track particle emit time */\r\n        this.emitTimeBuffer    = 0;\r\n    }\r\n    \r\n    /** Update the emitter to spawn particles, called automatically by engine once each frame */\r\n    update()\r\n    {\r\n        // only do default update to apply parent transforms\r\n        this.parent && super.update();\r\n\r\n        // update emitter\r\n        if (!this.emitTime || this.getAliveTime() <= this.emitTime)\r\n        {\r\n            // emit particles\r\n            if (this.emitRate * particleEmitRateScale)\r\n            {\r\n                const rate = 1/this.emitRate/particleEmitRateScale;\r\n                for (this.emitTimeBuffer += timeDelta; this.emitTimeBuffer > 0; this.emitTimeBuffer -= rate)\r\n                    this.emitParticle();\r\n            }\r\n        }\r\n        else\r\n            this.destroy();\r\n\r\n        debugParticles && debugRect(this.pos, vec2(this.emitSize), '#0f0', 0, this.angle);\r\n    }\r\n\r\n    /** Spawn one particle\r\n     *  @return {Particle} */\r\n    emitParticle()\r\n    {\r\n        // spawn a particle\r\n        let pos = typeof this.emitSize === 'number' ? // check if number was used\r\n            randInCircle(this.emitSize/2)              // circle emitter\r\n            : vec2(rand(-.5,.5), rand(-.5,.5))         // box emitter\r\n                .multiply(this.emitSize).rotate(this.angle)\r\n        let angle = rand(this.particleConeAngle, -this.particleConeAngle);\r\n        if (!this.localSpace)\r\n        {\r\n            pos = this.pos.add(pos);\r\n            angle += this.angle;\r\n        }\r\n\r\n        // randomness scales each paremeter by a percentage\r\n        const randomness = this.randomness;\r\n        const randomizeScale = (v)=> v + v*rand(randomness, -randomness);\r\n\r\n        // randomize particle settings\r\n        const particleTime  = randomizeScale(this.particleTime);\r\n        const sizeStart     = randomizeScale(this.sizeStart);\r\n        const sizeEnd       = randomizeScale(this.sizeEnd);\r\n        const speed         = randomizeScale(this.speed);\r\n        const angleSpeed    = randomizeScale(this.angleSpeed) * randSign();\r\n        const coneAngle     = rand(this.emitConeAngle, -this.emitConeAngle);\r\n        const colorStart    = randColor(this.colorStartA, this.colorStartB, this.randomColorLinear);\r\n        const colorEnd      = randColor(this.colorEndA,   this.colorEndB, this.randomColorLinear);\r\n        const velocityAngle = this.localSpace ? coneAngle : this.angle + coneAngle;\r\n        \r\n        // build particle\r\n        const particle = new Particle(pos, this.tileInfo, angle, colorStart, colorEnd, particleTime, sizeStart, sizeEnd, this.fadeRate, this.additive,  this.trailScale, this.localSpace && this, this.particleDestroyCallback);\r\n        particle.velocity      = vec2().setAngle(velocityAngle, speed);\r\n        particle.angleVelocity = angleSpeed;\r\n        particle.fadeRate      = this.fadeRate;\r\n        particle.damping       = this.damping;\r\n        particle.angleDamping  = this.angleDamping;\r\n        particle.elasticity    = this.elasticity;\r\n        particle.friction      = this.friction;\r\n        particle.gravityScale  = this.gravityScale;\r\n        particle.collideTiles  = this.collideTiles;\r\n        particle.renderOrder   = this.renderOrder;\r\n        particle.mirror        = !!randInt(2);\r\n\r\n        // call particle create callaback\r\n        this.particleCreateCallback && this.particleCreateCallback(particle);\r\n\r\n        // return the newly created particle\r\n        return particle;\r\n    }\r\n\r\n    // Particle emitters are not rendered, only the particles are\r\n    render() {}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Particle Object - Created automatically by Particle Emitters\r\n * @extends EngineObject\r\n */\r\nclass Particle extends EngineObject\r\n{\r\n    /**\r\n     * Create a particle with the passed in settings\r\n     * Typically this is created automatically by a ParticleEmitter\r\n     * @param {Vector2}  position   - World space position of the particle\r\n     * @param {TileInfo} tileInfo   - Tile info to render particles\r\n     * @param {Number}   angle      - Angle to rotate the particle\r\n     * @param {Color}    colorStart - Color at start of life\r\n     * @param {Color}    colorEnd   - Color at end of life\r\n     * @param {Number}   lifeTime   - How long to live for\r\n     * @param {Number}   sizeStart  - Size at start of life\r\n     * @param {Number}   sizeEnd    - Size at end of life\r\n     * @param {Number}   fadeRate   - How quick to fade in/out\r\n     * @param {Boolean}  additive   - Does it use additive blend mode\r\n     * @param {Number}   trailScale - If a trail, how long to make it\r\n     * @param {ParticleEmitter} [localSpaceEmitter] - Parent emitter if local space\r\n     * @param {Function} [destroyCallback] - Callback when particle dies\r\n     */\r\n    constructor(position, tileInfo, angle, colorStart, colorEnd, lifeTime, sizeStart, sizeEnd, fadeRate, additive, trailScale, localSpaceEmitter, destroyCallback\r\n    )\r\n    { \r\n        super(position, vec2(), tileInfo, angle); \r\n    \r\n        /** @property {Color} - Color at start of life */\r\n        this.colorStart = colorStart;\r\n        /** @property {Color} - Calculated change in color */\r\n        this.colorEndDelta = colorEnd.subtract(colorStart);\r\n        /** @property {Number} - How long to live for */\r\n        this.lifeTime = lifeTime;\r\n        /** @property {Number} - Size at start of life */\r\n        this.sizeStart = sizeStart;\r\n        /** @property {Number} - Calculated change in size */\r\n        this.sizeEndDelta = sizeEnd - sizeStart;\r\n        /** @property {Number} - How quick to fade in/out */\r\n        this.fadeRate = fadeRate;\r\n        /** @property {Boolean} - Is it additive */\r\n        this.additive = additive;\r\n        /** @property {Number} - If a trail, how long to make it */\r\n        this.trailScale = trailScale;\r\n        /** @property {ParticleEmitter} - Parent emitter if local space */\r\n        this.localSpaceEmitter = localSpaceEmitter;\r\n        /** @property {Function} - Called when particle dies */\r\n        this.destroyCallback = destroyCallback;\r\n\r\n        // particles use circular clamped speed\r\n        this.clampSpeedLinear = false;\r\n    }\r\n\r\n    /** Render the particle, automatically called each frame, sorted by renderOrder */\r\n    render()\r\n    {\r\n        // modulate size and color\r\n        const p = min((time - this.spawnTime) / this.lifeTime, 1);\r\n        const radius = this.sizeStart + p * this.sizeEndDelta;\r\n        const size = vec2(radius);\r\n        const fadeRate = this.fadeRate/2;\r\n        const color = new Color(\r\n            this.colorStart.r + p * this.colorEndDelta.r,\r\n            this.colorStart.g + p * this.colorEndDelta.g,\r\n            this.colorStart.b + p * this.colorEndDelta.b,\r\n            (this.colorStart.a + p * this.colorEndDelta.a) * \r\n             (p < fadeRate ? p/fadeRate : p > 1-fadeRate ? (1-p)/fadeRate : 1)); // fade alpha\r\n\r\n        // draw the particle\r\n        this.additive && setBlendMode(true);\r\n\r\n        let pos = this.pos, angle = this.angle;\r\n        if (this.localSpaceEmitter)\r\n        {\r\n            // in local space of emitter\r\n            pos = this.localSpaceEmitter.pos.add(pos.rotate(-this.localSpaceEmitter.angle)); \r\n            angle += this.localSpaceEmitter.angle;\r\n        }\r\n        if (this.trailScale)\r\n        {\r\n            // trail style particles\r\n            let velocity = this.velocity;\r\n            if (this.localSpaceEmitter)\r\n                velocity = velocity.rotate(-this.localSpaceEmitter.angle);\r\n            const speed = velocity.length();\r\n            if (speed)\r\n            {\r\n                const direction = velocity.scale(1/speed);\r\n                const trailLength = speed * this.trailScale;\r\n                size.y = max(size.x, trailLength);\r\n                angle = direction.angle();\r\n                drawTile(pos.add(direction.multiply(vec2(0,-trailLength/2))), size, this.tileInfo, color, angle, this.mirror);\r\n            }\r\n        }\r\n        else\r\n            drawTile(pos, size, this.tileInfo, color, angle, this.mirror);\r\n        this.additive && setBlendMode();\r\n        debugParticles && debugRect(pos, size, '#f005', 0, angle);\r\n\r\n        if (p == 1)\r\n        {\r\n            // destroy particle when it's time runs out\r\n            this.color = color;\r\n            this.size = size;\r\n            this.destroyCallback && this.destroyCallback(this);\r\n            this.destroyed = 1;\r\n        }\r\n    }\r\n}\n/** \r\n * LittleJS Medal System\r\n * - Tracks and displays medals\r\n * - Saves medals to local storage\r\n * - Newgrounds integration\r\n * @namespace Medals\r\n */\r\n\r\n\r\n\r\n/** List of all medals\r\n *  @type {Object}\r\n *  @memberof Medals */\r\nconst medals = {};\r\n\r\n// Engine internal variables not exposed to documentation\r\nlet medalsDisplayQueue = [], medalsSaveName, medalsDisplayTimeLast;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Initialize medals with a save name used for storage\r\n *  - Call this after creating all medals\r\n *  - Checks if medals are unlocked\r\n *  @param {String} saveName\r\n *  @memberof Medals */\r\nfunction medalsInit(saveName)\r\n{\r\n    // check if medals are unlocked\r\n    medalsSaveName = saveName;\r\n    if (!debugMedals)\r\n        medalsForEach(medal=> medal.unlocked = (localStorage[medal.storageKey()] | 0));\r\n\r\n    // engine automatically renders medals\r\n    engineAddPlugin(undefined, medalsRender);\r\n    function medalsRender()\r\n    {\r\n        if (!medalsDisplayQueue.length)\r\n            return;\r\n        \r\n        // update first medal in queue\r\n        const medal = medalsDisplayQueue[0];\r\n        const time = timeReal - medalsDisplayTimeLast;\r\n        if (!medalsDisplayTimeLast)\r\n            medalsDisplayTimeLast = timeReal;\r\n        else if (time > medalDisplayTime)\r\n        {\r\n            medalsDisplayTimeLast = 0;\r\n            medalsDisplayQueue.shift();\r\n        }\r\n        else\r\n        {\r\n            // slide on/off medals\r\n            const slideOffTime = medalDisplayTime - medalDisplaySlideTime;\r\n            const hidePercent = \r\n                time < medalDisplaySlideTime ? 1 - time / medalDisplaySlideTime :\r\n                time > slideOffTime ? (time - slideOffTime) / medalDisplaySlideTime : 0;\r\n            medal.render(hidePercent);\r\n        }\r\n    }\r\n}\r\n\r\n/** Calls a function for each medal\r\n *  @param {Function} callback\r\n *  @memberof Medals */\r\nfunction medalsForEach(callback)\r\n{ Object.values(medals).forEach(medal=>callback(medal)); }\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/** \r\n * Medal - Tracks an unlockable medal \r\n * @example\r\n * // create a medal\r\n * const medal_example = new Medal(0, 'Example Medal', 'More info about the medal goes here.', '');\r\n * \r\n * // initialize medals\r\n * medalsInit('Example Game');\r\n * \r\n * // unlock the medal\r\n * medal_example.unlock();\r\n */\r\nclass Medal\r\n{\r\n    /** Create a medal object and adds it to the list of medals\r\n     *  @param {Number} id            - The unique identifier of the medal\r\n     *  @param {String} name          - Name of the medal\r\n     *  @param {String} [description] - Description of the medal\r\n     *  @param {String} [icon]        - Icon for the medal\r\n     *  @param {String} [src]         - Image location for the medal\r\n     */\r\n    constructor(id, name, description='', icon='', src)\r\n    {\r\n        ASSERT(id >= 0 && !medals[id]);\r\n\r\n        // save attributes and add to list of medals\r\n        medals[this.id = id] = this;\r\n        this.name = name;\r\n        this.description = description;\r\n        this.icon = icon;\r\n        if (src)\r\n            (this.image = new Image).src = src;\r\n    }\r\n\r\n    /** Unlocks a medal if not already unlocked */\r\n    unlock()\r\n    {\r\n        if (medalsPreventUnlock || this.unlocked)\r\n            return;\r\n\r\n        // save the medal\r\n        ASSERT(medalsSaveName, 'save name must be set');\r\n        localStorage[this.storageKey()] = this.unlocked = 1;\r\n        medalsDisplayQueue.push(this);\r\n    }\r\n\r\n    /** Render a medal\r\n     *  @param {Number} [hidePercent] - How much to slide the medal off screen\r\n     */\r\n    render(hidePercent=0)\r\n    {\r\n        const context = overlayContext;\r\n        const width = min(medalDisplaySize.x, mainCanvas.width);\r\n        const x = overlayCanvas.width - width;\r\n        const y = -medalDisplaySize.y*hidePercent;\r\n\r\n        // draw containing rect and clip to that region\r\n        context.save();\r\n        context.beginPath();\r\n        context.fillStyle = new Color(.9,.9,.9).toString();\r\n        context.strokeStyle = new Color(0,0,0).toString();\r\n        context.lineWidth = 3;\r\n        context.rect(x, y, width, medalDisplaySize.y);\r\n        context.fill();\r\n        context.stroke();\r\n        context.clip();\r\n\r\n        // draw the icon and text\r\n        this.renderIcon(vec2(x+15+medalDisplayIconSize/2, y+medalDisplaySize.y/2));\r\n        const pos = vec2(x+medalDisplayIconSize+30, y+28);\r\n        drawTextScreen(this.name, pos, 38, new Color(0,0,0), 0, undefined, 'left');\r\n        pos.y += 32;\r\n        drawTextScreen(this.description, pos, 24, new Color(0,0,0), 0, undefined, 'left');\r\n        context.restore();\r\n    }\r\n\r\n    /** Render the icon for a medal\r\n     *  @param {Vector2} pos - Screen space position\r\n     *  @param {Number} [size=medalDisplayIconSize] - Screen space size\r\n     */\r\n    renderIcon(pos, size=medalDisplayIconSize)\r\n    {\r\n        // draw the image or icon\r\n        if (this.image)\r\n            overlayContext.drawImage(this.image, pos.x-size/2, pos.y-size/2, size, size);\r\n        else\r\n            drawTextScreen(this.icon, pos, size*.7, new Color(0,0,0));\r\n    }\r\n \r\n    // Get local storage key used by the medal\r\n    storageKey() { return medalsSaveName + '_' + this.id; }\r\n}\n/**\r\n * LittleJS WebGL Interface\r\n * - All webgl used by the engine is wrapped up here\r\n * - For normal stuff you won't need to see or call anything in this file\r\n * - For advanced stuff there are helper functions to create shaders, textures, etc\r\n * - Can be disabled with glEnable to revert to 2D canvas rendering\r\n * - Batches sprite rendering on GPU for incredibly fast performance\r\n * - Sprite transform math is done in the shader where possible\r\n * - Supports shadertoy style post processing shaders\r\n * @namespace WebGL\r\n */\r\n\r\n\r\n\r\n/** The WebGL canvas which appears above the main canvas and below the overlay canvas\r\n *  @type {HTMLCanvasElement}\r\n *  @memberof WebGL */\r\nlet glCanvas;\r\n\r\n/** 2d context for glCanvas\r\n *  @type {WebGL2RenderingContext}\r\n *  @memberof WebGL */\r\nlet glContext;\r\n\r\n// WebGL internal variables not exposed to documentation\r\nlet glShader, glActiveTexture, glArrayBuffer, glGeometryBuffer, glPositionData, glColorData, glInstanceCount, glAdditive, glBatchAdditive;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// Initalize WebGL, called automatically by the engine\r\nfunction glInit()\r\n{\r\n    if (!glEnable || headlessMode) return;\r\n\r\n    // create the canvas and textures\r\n    glCanvas = document.createElement('canvas');\r\n    glContext = glCanvas.getContext('webgl2');\r\n\r\n    // some browsers are much faster without copying the gl buffer so we just overlay it instead\r\n    glOverlay && document.body.appendChild(glCanvas);\r\n\r\n    // setup vertex and fragment shaders\r\n    glShader = glCreateProgram(\r\n        '#version 300 es\\n' +     // specify GLSL ES version\r\n        'precision highp float;'+ // use highp for better accuracy\r\n        'uniform mat4 m;'+        // transform matrix\r\n        'in vec2 g;'+             // in: geometry\r\n        'in vec4 p,u,c,a;'+       // in: position/size, uvs, color, additiveColor\r\n        'in float r;'+            // in: rotation\r\n        'out vec2 v;'+            // out: uv\r\n        'out vec4 d,e;'+          // out: color, additiveColor\r\n        'void main(){'+           // shader entry point\r\n        'vec2 s=(g-.5)*p.zw;'+    // get size offset\r\n        'gl_Position=m*vec4(p.xy+s*cos(r)-vec2(-s.y,s)*sin(r),1,1);'+ // transform position\r\n        'v=mix(u.xw,u.zy,g);'+    // pass uv to fragment shader\r\n        'd=c;e=a;'+               // pass colors to fragment shader\r\n        '}'                       // end of shader\r\n        ,\r\n        '#version 300 es\\n' +     // specify GLSL ES version\r\n        'precision highp float;'+ // use highp for better accuracy\r\n        'uniform sampler2D s;'+   // texture\r\n        'in vec2 v;'+             // in: uv\r\n        'in vec4 d,e;'+           // in: color, additiveColor\r\n        'out vec4 c;'+            // out: color\r\n        'void main(){'+           // shader entry point\r\n        'c=texture(s,v)*d+e;'+    // modulate texture by color plus additive\r\n        '}'                       // end of shader\r\n    );\r\n\r\n    // init buffers\r\n    const glInstanceData = new ArrayBuffer(gl_INSTANCE_BUFFER_SIZE);\r\n    glPositionData = new Float32Array(glInstanceData);\r\n    glColorData = new Uint32Array(glInstanceData);\r\n    glArrayBuffer = glContext.createBuffer();\r\n    glGeometryBuffer = glContext.createBuffer();\r\n\r\n    // create the geometry buffer, triangle strip square\r\n    const geometry = new Float32Array([glInstanceCount=0,0,1,0,0,1,1,1]);\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\r\n    glContext.bufferData(gl_ARRAY_BUFFER, geometry, gl_STATIC_DRAW);\r\n}\r\n\r\n// Setup render each frame, called automatically by engine\r\nfunction glPreRender()\r\n{\r\n    if (!glEnable || headlessMode) return;\r\n\r\n    // clear and set to same size as main canvas\r\n    glContext.viewport(0, 0, glCanvas.width=mainCanvas.width, glCanvas.height=mainCanvas.height);\r\n    glContext.clear(gl_COLOR_BUFFER_BIT);\r\n\r\n    // set up the shader\r\n    glContext.useProgram(glShader);\r\n    glContext.activeTexture(gl_TEXTURE0);\r\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = textureInfos[0].glTexture);\r\n\r\n    // set vertex attributes\r\n    let offset = glAdditive = glBatchAdditive = 0;\r\n    let initVertexAttribArray = (name, type, typeSize, size)=>\r\n    {\r\n        const location = glContext.getAttribLocation(glShader, name);\r\n        const stride = typeSize && gl_INSTANCE_BYTE_STRIDE; // only if not geometry\r\n        const divisor = typeSize && 1; // only if not geometry\r\n        const normalize = typeSize==1; // only if color\r\n        glContext.enableVertexAttribArray(location);\r\n        glContext.vertexAttribPointer(location, size, type, normalize, stride, offset);\r\n        glContext.vertexAttribDivisor(location, divisor);\r\n        offset += size*typeSize;\r\n    }\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glGeometryBuffer);\r\n    initVertexAttribArray('g', gl_FLOAT, 0, 2); // geometry\r\n    glContext.bindBuffer(gl_ARRAY_BUFFER, glArrayBuffer);\r\n    glContext.bufferData(gl_ARRAY_BUFFER, gl_INSTANCE_BUFFER_SIZE, gl_DYNAMIC_DRAW);\r\n    initVertexAttribArray('p', gl_FLOAT, 4, 4); // position & size\r\n    initVertexAttribArray('u', gl_FLOAT, 4, 4); // texture coords\r\n    initVertexAttribArray('c', gl_UNSIGNED_BYTE, 1, 4); // color\r\n    initVertexAttribArray('a', gl_UNSIGNED_BYTE, 1, 4); // additiveColor\r\n    initVertexAttribArray('r', gl_FLOAT, 4, 1); // rotation\r\n\r\n    // build the transform matrix\r\n    const s = vec2(2*cameraScale).divide(mainCanvasSize);\r\n    const p = vec2(-1).subtract(cameraPos.multiply(s));\r\n    glContext.uniformMatrix4fv(glContext.getUniformLocation(glShader, 'm'), false,\r\n        [\r\n            s.x, 0,   0,   0,\r\n            0,   s.y, 0,   0,\r\n            1,   1,   1,   1,\r\n            p.x, p.y, 0,   0\r\n        ]\r\n    );\r\n}\r\n\r\n/** Set the WebGl texture, called automatically if using multiple textures\r\n *  - This may also flush the gl buffer resulting in more draw calls and worse performance\r\n *  @param {WebGLTexture} texture\r\n *  @memberof WebGL */\r\nfunction glSetTexture(texture)\r\n{\r\n    // must flush cache with the old texture to set a new one\r\n    if (headlessMode || texture == glActiveTexture)\r\n        return;\r\n\r\n    glFlush();\r\n    glContext.bindTexture(gl_TEXTURE_2D, glActiveTexture = texture);\r\n}\r\n\r\n/** Compile WebGL shader of the given type, will throw errors if in debug mode\r\n *  @param {String} source\r\n *  @param {Number} type\r\n *  @return {WebGLShader}\r\n *  @memberof WebGL */\r\nfunction glCompileShader(source, type)\r\n{\r\n    // build the shader\r\n    const shader = glContext.createShader(type);\r\n    glContext.shaderSource(shader, source);\r\n    glContext.compileShader(shader);\r\n\r\n    // check for errors\r\n    if (debug && !glContext.getShaderParameter(shader, gl_COMPILE_STATUS))\r\n        throw glContext.getShaderInfoLog(shader);\r\n    return shader;\r\n}\r\n\r\n/** Create WebGL program with given shaders\r\n *  @param {String} vsSource\r\n *  @param {String} fsSource\r\n *  @return {WebGLProgram}\r\n *  @memberof WebGL */\r\nfunction glCreateProgram(vsSource, fsSource)\r\n{\r\n    // build the program\r\n    const program = glContext.createProgram();\r\n    glContext.attachShader(program, glCompileShader(vsSource, gl_VERTEX_SHADER));\r\n    glContext.attachShader(program, glCompileShader(fsSource, gl_FRAGMENT_SHADER));\r\n    glContext.linkProgram(program);\r\n\r\n    // check for errors\r\n    if (debug && !glContext.getProgramParameter(program, gl_LINK_STATUS))\r\n        throw glContext.getProgramInfoLog(program);\r\n    return program;\r\n}\r\n\r\n/** Create WebGL texture from an image and init the texture settings\r\n *  @param {HTMLImageElement} image\r\n *  @return {WebGLTexture}\r\n *  @memberof WebGL */\r\nfunction glCreateTexture(image)\r\n{\r\n    // build the texture\r\n    const texture = glContext.createTexture();\r\n    glContext.bindTexture(gl_TEXTURE_2D, texture);\r\n    if (image)\r\n        glContext.texImage2D(gl_TEXTURE_2D, 0, gl_RGBA, gl_RGBA, gl_UNSIGNED_BYTE, image);\r\n\r\n    // use point filtering for pixelated rendering\r\n    const filter = canvasPixelated ? gl_NEAREST : gl_LINEAR;\r\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MIN_FILTER, filter);\r\n    glContext.texParameteri(gl_TEXTURE_2D, gl_TEXTURE_MAG_FILTER, filter);\r\n    return texture;\r\n}\r\n\r\n/** Draw all sprites and clear out the buffer, called automatically by the system whenever necessary\r\n *  @memberof WebGL */\r\nfunction glFlush()\r\n{\r\n    if (!glInstanceCount) return;\r\n\r\n    const destBlend = glBatchAdditive ? gl_ONE : gl_ONE_MINUS_SRC_ALPHA;\r\n    glContext.blendFuncSeparate(gl_SRC_ALPHA, destBlend, gl_ONE, destBlend);\r\n    glContext.enable(gl_BLEND);\r\n\r\n    // draw all the sprites in the batch and reset the buffer\r\n    glContext.bufferSubData(gl_ARRAY_BUFFER, 0, glPositionData);\r\n    glContext.drawArraysInstanced(gl_TRIANGLE_STRIP, 0, 4, glInstanceCount);\r\n    if (showWatermark)\r\n        drawCount += glInstanceCount;\r\n    glInstanceCount = 0;\r\n    glBatchAdditive = glAdditive;\r\n}\r\n\r\n/** Draw any sprites still in the buffer, copy to main canvas and clear\r\n *  @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} context\r\n *  @param {Boolean} [forceDraw]\r\n *  @memberof WebGL */\r\nfunction glCopyToContext(context, forceDraw=false)\r\n{\r\n    if (!glEnable || !glInstanceCount && !forceDraw) return;\r\n\r\n    glFlush();\r\n\r\n    // do not draw in overlay mode because the canvas is visible\r\n    if (!glOverlay || forceDraw)\r\n        context.drawImage(glCanvas, 0, 0);\r\n}\r\n\r\n/** Add a sprite to the gl draw list, used by all gl draw functions\r\n *  @param {Number} x\r\n *  @param {Number} y\r\n *  @param {Number} sizeX\r\n *  @param {Number} sizeY\r\n *  @param {Number} angle\r\n *  @param {Number} uv0X\r\n *  @param {Number} uv0Y\r\n *  @param {Number} uv1X\r\n *  @param {Number} uv1Y\r\n *  @param {Number} rgba\r\n *  @param {Number} [rgbaAdditive=0]\r\n *  @memberof WebGL */\r\nfunction glDraw(x, y, sizeX, sizeY, angle, uv0X, uv0Y, uv1X, uv1Y, rgba, rgbaAdditive=0)\r\n{\r\n    ASSERT(typeof rgba == 'number' && typeof rgbaAdditive == 'number', 'invalid color');\r\n\r\n    // flush if there is not enough room or if different blend mode\r\n    if (glInstanceCount >= gl_MAX_INSTANCES || glBatchAdditive != glAdditive)\r\n        glFlush();\r\n\r\n    let offset = glInstanceCount * gl_INDICIES_PER_INSTANCE;\r\n    glPositionData[offset++] = x;\r\n    glPositionData[offset++] = y;\r\n    glPositionData[offset++] = sizeX;\r\n    glPositionData[offset++] = sizeY;\r\n    glPositionData[offset++] = uv0X;\r\n    glPositionData[offset++] = uv0Y;\r\n    glPositionData[offset++] = uv1X;\r\n    glPositionData[offset++] = uv1Y;\r\n    glColorData[offset++] = rgba;\r\n    glColorData[offset++] = rgbaAdditive;\r\n    glPositionData[offset++] = angle;\r\n    glInstanceCount++;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// store gl constants as integers so their name doesn't use space in minifed\r\nconst\r\ngl_ONE = 1,\r\ngl_TRIANGLE_STRIP = 5,\r\ngl_SRC_ALPHA = 770,\r\ngl_ONE_MINUS_SRC_ALPHA = 771,\r\ngl_BLEND = 3042,\r\ngl_TEXTURE_2D = 3553,\r\ngl_UNSIGNED_BYTE = 5121,\r\ngl_FLOAT = 5126,\r\ngl_RGBA = 6408,\r\ngl_NEAREST = 9728,\r\ngl_LINEAR = 9729,\r\ngl_TEXTURE_MAG_FILTER = 10240,\r\ngl_TEXTURE_MIN_FILTER = 10241,\r\ngl_COLOR_BUFFER_BIT = 16384,\r\ngl_TEXTURE0 = 33984,\r\ngl_ARRAY_BUFFER = 34962,\r\ngl_STATIC_DRAW = 35044,\r\ngl_DYNAMIC_DRAW = 35048,\r\ngl_FRAGMENT_SHADER = 35632,\r\ngl_VERTEX_SHADER = 35633,\r\ngl_COMPILE_STATUS = 35713,\r\ngl_LINK_STATUS = 35714,\r\ngl_UNPACK_FLIP_Y_WEBGL = 37440,\r\n\r\n// constants for batch rendering\r\ngl_INDICIES_PER_INSTANCE = 11,\r\ngl_MAX_INSTANCES = 1e4,\r\ngl_INSTANCE_BYTE_STRIDE = gl_INDICIES_PER_INSTANCE * 4, // 11 * 4\r\ngl_INSTANCE_BUFFER_SIZE = gl_MAX_INSTANCES * gl_INSTANCE_BYTE_STRIDE;\n/** \r\n * LittleJS - The Tiny Fast JavaScript Game Engine\r\n * MIT License - Copyright 2021 Frank Force\r\n * \r\n * Engine Features\r\n * - Object oriented system with base class engine object\r\n * - Base class object handles update, physics, collision, rendering, etc\r\n * - Engine helper classes and functions like Vector2, Color, and Timer\r\n * - Super fast rendering system for tile sheets\r\n * - Sound effects audio with zzfx and music with zzfxm\r\n * - Input processing system with gamepad and touchscreen support\r\n * - Tile layer rendering and collision system\r\n * - Particle effect system\r\n * - Medal system tracks and displays achievements\r\n * - Debug tools and debug rendering system\r\n * - Post processing effects\r\n * - Call engineInit() to start it up!\r\n * @namespace Engine\r\n */\r\n\r\n\r\n\r\n/** Name of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */\r\nconst engineName = 'LittleJS';\r\n\r\n/** Version of engine\r\n *  @type {String}\r\n *  @default\r\n *  @memberof Engine */\r\nconst engineVersion = '1.9.9';\r\n\r\n/** Frames per second to update\r\n *  @type {Number}\r\n *  @default\r\n *  @memberof Engine */\r\nconst frameRate = 60;\r\n\r\n/** How many seconds each frame lasts, engine uses a fixed time step\r\n *  @type {Number}\r\n *  @default 1/60\r\n *  @memberof Engine */\r\nconst timeDelta = 1/frameRate;\r\n\r\n/** Array containing all engine objects\r\n *  @type {Array}\r\n *  @memberof Engine */\r\nlet engineObjects = [];\r\n\r\n/** Array with only objects set to collide with other objects this frame (for optimization)\r\n *  @type {Array}\r\n *  @memberof Engine */\r\nlet engineObjectsCollide = [];\r\n\r\n/** Current update frame, used to calculate time\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet frame = 0;\r\n\r\n/** Current engine time since start in seconds\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet time = 0;\r\n\r\n/** Actual clock time since start in seconds (not affected by pause or frame rate clamping)\r\n *  @type {Number}\r\n *  @memberof Engine */\r\nlet timeReal = 0;\r\n\r\n/** Is the game paused? Causes time and objects to not be updated\r\n *  @type {Boolean}\r\n *  @default false\r\n *  @memberof Engine */\r\nlet paused = false;\r\n\r\n/** Set if game is paused\r\n *  @param {Boolean} isPaused\r\n *  @memberof Engine */\r\nfunction setPaused(isPaused) { paused = isPaused; }\r\n\r\n// Frame time tracking\r\nlet frameTimeLastMS = 0, frameTimeBufferMS = 0, averageFPS = 0;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// plugin hooks\r\n\r\nconst pluginUpdateList = [], pluginRenderList = [];\r\n\r\n/** Add a new update function for a plugin\r\n *  @param {Function} [updateFunction]\r\n *  @param {Function} [renderFunction]\r\n *  @memberof Engine */\r\nfunction engineAddPlugin(updateFunction, renderFunction)\r\n{\r\n    updateFunction && pluginUpdateList.push(updateFunction);\r\n    renderFunction && pluginRenderList.push(renderFunction);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// Main engine functions\r\n\r\n/** Startup LittleJS engine with your callback functions\r\n *  @param {Function} gameInit       - Called once after the engine starts up, setup the game\r\n *  @param {Function} gameUpdate     - Called every frame at 60 frames per second, handle input and update the game state\r\n *  @param {Function} gameUpdatePost - Called after physics and objects are updated, setup camera and prepare for render\r\n *  @param {Function} gameRender     - Called before objects are rendered, draw any background effects that appear behind objects\r\n *  @param {Function} gameRenderPost - Called after objects are rendered, draw effects or hud that appear above all objects\r\n *  @param {Array} [imageSources=['tiles.png']] - Image to load\r\n *  @memberof Engine */\r\nfunction engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost, imageSources=['tiles.png'])\r\n{\r\n    ASSERT(Array.isArray(imageSources), 'pass in images as array');\r\n\r\n    // Called automatically by engine to setup render system\r\n    function enginePreRender()\r\n    {\r\n        // save canvas size\r\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\r\n\r\n        // disable smoothing for pixel art\r\n        mainContext.imageSmoothingEnabled = !canvasPixelated;\r\n\r\n        // setup gl rendering if enabled\r\n        glPreRender();\r\n    }\r\n\r\n    // internal update loop for engine\r\n    function engineUpdate(frameTimeMS=0)\r\n    {\r\n        // update time keeping\r\n        let frameTimeDeltaMS = frameTimeMS - frameTimeLastMS;\r\n        frameTimeLastMS = frameTimeMS;\r\n        if (debug || showWatermark)\r\n            averageFPS = lerp(.05, averageFPS, 1e3/(frameTimeDeltaMS||1));\r\n        const debugSpeedUp   = debug && keyIsDown('Equal'); // +\r\n        const debugSpeedDown = debug && keyIsDown('Minus'); // -\r\n        if (debug) // +/- to speed/slow time\r\n            frameTimeDeltaMS *= debugSpeedUp ? 5 : debugSpeedDown ? .2 : 1;\r\n        timeReal += frameTimeDeltaMS / 1e3;\r\n        frameTimeBufferMS += paused ? 0 : frameTimeDeltaMS;\r\n        if (!debugSpeedUp)\r\n            frameTimeBufferMS = min(frameTimeBufferMS, 50); // clamp in case of slow framerate\r\n\r\n        updateCanvas();\r\n\r\n        if (paused)\r\n        {\r\n            // update object transforms even when paused\r\n            for (const o of engineObjects)\r\n                o.parent || o.updateTransforms();\r\n            inputUpdate();\r\n            debugUpdate();\r\n            gameUpdatePost();\r\n            inputUpdatePost();\r\n        }\r\n        else\r\n        {\r\n            // apply time delta smoothing, improves smoothness of framerate in some browsers\r\n            let deltaSmooth = 0;\r\n            if (frameTimeBufferMS < 0 && frameTimeBufferMS > -9)\r\n            {\r\n                // force at least one update each frame since it is waiting for refresh\r\n                deltaSmooth = frameTimeBufferMS;\r\n                frameTimeBufferMS = 0;\r\n            }\r\n            \r\n            // update multiple frames if necessary in case of slow framerate\r\n            for (;frameTimeBufferMS >= 0; frameTimeBufferMS -= 1e3 / frameRate)\r\n            {\r\n                // increment frame and update time\r\n                time = frame++ / frameRate;\r\n\r\n                // update game and objects\r\n                inputUpdate();\r\n                gameUpdate();\r\n                pluginUpdateList.forEach(f=>f());\r\n                engineObjectsUpdate();\r\n\r\n                // do post update\r\n                debugUpdate();\r\n                gameUpdatePost();\r\n                inputUpdatePost();\r\n            }\r\n\r\n            // add the time smoothing back in\r\n            frameTimeBufferMS += deltaSmooth;\r\n        }\r\n\r\n        if (!headlessMode)\r\n        {\r\n            // render sort then render while removing destroyed objects\r\n            enginePreRender();\r\n            gameRender();\r\n            engineObjects.sort((a,b)=> a.renderOrder - b.renderOrder);\r\n            for (const o of engineObjects)\r\n                o.destroyed || o.render();\r\n            gameRenderPost();\r\n            pluginRenderList.forEach(f=>f());\r\n            touchGamepadRender();\r\n            debugRender();\r\n            glCopyToContext(mainContext);\r\n\r\n            if (showWatermark)\r\n            {\r\n                // update fps\r\n                overlayContext.textAlign = 'right';\r\n                overlayContext.textBaseline = 'top';\r\n                overlayContext.font = '1em monospace';\r\n                overlayContext.fillStyle = '#000';\r\n                const text = engineName + ' ' + 'v' + engineVersion + ' / ' \r\n                    + drawCount + ' / ' + engineObjects.length + ' / ' + averageFPS.toFixed(1)\r\n                    + (glEnable ? ' GL' : ' 2D') ;\r\n                overlayContext.fillText(text, mainCanvas.width-3, 3);\r\n                overlayContext.fillStyle = '#fff';\r\n                overlayContext.fillText(text, mainCanvas.width-2, 2);\r\n                drawCount = 0;\r\n            }\r\n        }\r\n\r\n        requestAnimationFrame(engineUpdate);\r\n    }\r\n\r\n    function updateCanvas()\r\n    {\r\n        if (headlessMode) return;\r\n        \r\n        if (canvasFixedSize.x)\r\n        {\r\n            // clear canvas and set fixed size\r\n            mainCanvas.width  = canvasFixedSize.x;\r\n            mainCanvas.height = canvasFixedSize.y;\r\n            \r\n            // fit to window by adding space on top or bottom if necessary\r\n            const aspect = innerWidth / innerHeight;\r\n            const fixedAspect = mainCanvas.width / mainCanvas.height;\r\n            (glCanvas||mainCanvas).style.width = mainCanvas.style.width = overlayCanvas.style.width  = aspect < fixedAspect ? '100%' : '';\r\n            (glCanvas||mainCanvas).style.height = mainCanvas.style.height = overlayCanvas.style.height = aspect < fixedAspect ? '' : '100%';\r\n        }\r\n        else\r\n        {\r\n            // clear canvas and set size to same as window\r\n            mainCanvas.width  = min(innerWidth,  canvasMaxSize.x);\r\n            mainCanvas.height = min(innerHeight, canvasMaxSize.y);\r\n        }\r\n        \r\n        // clear overlay canvas and set size\r\n        overlayCanvas.width  = mainCanvas.width;\r\n        overlayCanvas.height = mainCanvas.height;\r\n\r\n        // save canvas size\r\n        mainCanvasSize = vec2(mainCanvas.width, mainCanvas.height);\r\n    }\r\n\r\n    function startEngine()\r\n    {\r\n        gameInit();\r\n        engineUpdate();\r\n    }\r\n\r\n    if (headlessMode)\r\n    {\r\n        startEngine();\r\n        return;\r\n    }\r\n\r\n    // setup html\r\n    const styleBody = \r\n        'margin:0;overflow:hidden;' + // fill the window\r\n        'background:#000;' +          // set background color\r\n        'user-select:none;' +         // prevent hold to select\r\n        '-webkit-user-select:none;' + // compatibility for ios\r\n        (!touchInputEnable ? '' :     // no touch css setttings\r\n        'touch-action:none;' +        // prevent mobile pinch to resize\r\n        '-webkit-touch-callout:none');// compatibility for ios\r\n    document.body.style.cssText = styleBody;\r\n    document.body.appendChild(mainCanvas = document.createElement('canvas'));\r\n    mainContext = mainCanvas.getContext('2d');\r\n\r\n    // init stuff and start engine\r\n    inputInit();\r\n    audioInit();\r\n    debugInit();\r\n    glInit();\r\n\r\n    // create overlay canvas for hud to appear above gl canvas\r\n    document.body.appendChild(overlayCanvas = document.createElement('canvas'));\r\n    overlayContext = overlayCanvas.getContext('2d');\r\n\r\n    // set canvas style\r\n    const styleCanvas = 'position:absolute;' +             // position\r\n        'top:50%;left:50%;transform:translate(-50%,-50%)'; // center\r\n    (glCanvas||mainCanvas).style.cssText = mainCanvas.style.cssText = overlayCanvas.style.cssText = styleCanvas;\r\n    updateCanvas();\r\n    \r\n    // create promises for loading images\r\n    const promises = imageSources.map((src, textureIndex)=>\r\n        new Promise(resolve => \r\n        {\r\n            const image = new Image;\r\n            image.onerror = image.onload = ()=> \r\n            {\r\n                textureInfos[textureIndex] = new TextureInfo(image);\r\n                resolve();\r\n            }\r\n            image.src = src;\r\n        })\r\n    );\r\n\r\n    // draw splash screen\r\n    showSplashScreen && promises.push(new Promise(resolve => \r\n    {\r\n        let t = 0;\r\n        console.log(`${engineName} Engine v${engineVersion}`);\r\n        updateSplash();\r\n        function updateSplash()\r\n        {\r\n            clearInput();\r\n            drawEngineSplashScreen(t+=.01);\r\n            t>1 ? resolve() : setTimeout(updateSplash, 16);\r\n        }\r\n    }));\r\n\r\n    // load all of the images\r\n    Promise.all(promises).then(startEngine);\r\n}\r\n\r\n/** Update each engine object, remove destroyed objects, and update time\r\n *  @memberof Engine */\r\nfunction engineObjectsUpdate()\r\n{\r\n    // get list of solid objects for physics optimzation\r\n    engineObjectsCollide = engineObjects.filter(o=>o.collideSolidObjects);\r\n\r\n    // recursive object update\r\n    function updateObject(o)\r\n    {\r\n        if (!o.destroyed)\r\n        {\r\n            o.update();\r\n            for (const child of o.children)\r\n                updateObject(child);\r\n        }\r\n    }\r\n    for (const o of engineObjects)\r\n    {\r\n        // update top level objects\r\n        if (!o.parent)\r\n        {\r\n            updateObject(o);\r\n            o.updateTransforms();\r\n        }\r\n    }\r\n\r\n    // remove destroyed objects\r\n    engineObjects = engineObjects.filter(o=>!o.destroyed);\r\n}\r\n\r\n/** Destroy and remove all objects\r\n *  @memberof Engine */\r\nfunction engineObjectsDestroy()\r\n{\r\n    for (const o of engineObjects)\r\n        o.parent || o.destroy();\r\n    engineObjects = engineObjects.filter(o=>!o.destroyed);\r\n}\r\n\r\n/** Collects all object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array}                        - List of collected objects\r\n *  @memberof Engine */\r\nfunction engineObjectsCollect(pos, size, objects=engineObjects)\r\n{\r\n    const collectedObjects = [];\r\n    if (!pos) // all objects\r\n    {\r\n        for (const o of objects)\r\n            collectedObjects.push(o);\r\n    }\r\n    else if (size instanceof Vector2)  // bounding box test\r\n    {\r\n        for (const o of objects)\r\n            isOverlapping(pos, size, o.pos, o.size) && collectedObjects.push(o);\r\n    }\r\n    else  // circle test\r\n    {\r\n        const sizeSquared = size*size;\r\n        for (const o of objects)\r\n            pos.distanceSquared(o.pos) < sizeSquared && collectedObjects.push(o);\r\n    }\r\n    return collectedObjects;\r\n}\r\n\r\n/** Triggers a callback for each object within a given area\r\n *  @param {Vector2} [pos]                 - Center of test area, or undefined for all objects\r\n *  @param {Number|Vector2} [size]         - Radius of circle if float, rectangle size if Vector2\r\n *  @param {Function} [callbackFunction]   - Calls this function on every object that passes the test\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @memberof Engine */\r\nfunction engineObjectsCallback(pos, size, callbackFunction, objects=engineObjects)\r\n{ engineObjectsCollect(pos, size, objects).forEach(o => callbackFunction(o)); }\r\n\r\n/** Return a list of objects intersecting a ray\r\n *  @param {Vector2} start\r\n *  @param {Vector2} end\r\n *  @param {Array} [objects=engineObjects] - List of objects to check\r\n *  @return {Array} - List of objects hit\r\n *  @memberof Engine */\r\nfunction engineObjectsRaycast(start, end, objects=engineObjects)\r\n{\r\n    const hitObjects = [];\r\n    for (const o of objects)\r\n    {\r\n        if (o.collideRaycast && isIntersecting(start, end, o.pos, o.size))\r\n        {\r\n            debugRaycast && debugRect(o.pos, o.size, '#f00');\r\n            hitObjects.push(o);\r\n        }\r\n    }\r\n\r\n    debugRaycast && debugLine(start, end, hitObjects.length ? '#f00' : '#00f', .02);\r\n    return hitObjects;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// LittleJS splash screen and logo\r\n\r\nfunction drawEngineSplashScreen(t)\r\n{\r\n    const x = overlayContext;\r\n    const w = overlayCanvas.width = innerWidth;\r\n    const h = overlayCanvas.height = innerHeight;\r\n\r\n    {\r\n        // background\r\n        const p3 = percent(t, 1, .8);\r\n        const p4 = percent(t, 0, .5);\r\n        const g = x.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.hypot(w,h)*.7);\r\n        g.addColorStop(0,hsl(0,0,lerp(p4,0,p3/2),p3).toString());\r\n        g.addColorStop(1,hsl(0,0,0,p3).toString());\r\n        x.save();\r\n        x.fillStyle = g;\r\n        x.fillRect(0,0,w,h);\r\n    }\r\n\r\n    // draw LittleJS logo...\r\n    const rect = (X, Y, W, H, C)=>\r\n    {\r\n        x.beginPath();\r\n        x.rect(X,Y,W,C?H*p:H);\r\n        x.fillStyle = C;\r\n        C ? x.fill() : x.stroke();\r\n    };\r\n    const line = (X, Y, Z, W)=>\r\n    {\r\n        x.beginPath();\r\n        x.lineTo(X,Y);\r\n        x.lineTo(Z,W);\r\n        x.stroke();\r\n    };\r\n    const circle = (X, Y, R, A=0, B=2*PI, C, F)=>\r\n    {\r\n        const D = (A+B)/2, E = p*(B-A)/2;\r\n        x.beginPath();\r\n        F && x.lineTo(X,Y);\r\n        x.arc(X,Y,R,D-E,D+E);\r\n        x.fillStyle = C;\r\n        C ? x.fill() : x.stroke();\r\n    };\r\n    const color = (c=0, l=0) =>\r\n        hsl([.98,.3,.57,.14][c%4]-10,.8,[0,.3,.5,.8,.9][l]).toString();\r\n    const alpha = wave(1,1,t);\r\n    const p = percent(alpha, .1, .5);\r\n\r\n    // setup\r\n    x.translate(w/2,h/2);\r\n    const size = min(6, min(w,h)/99); // fit to screen\r\n    x.scale(size,size);\r\n    x.translate(-40,-35);\r\n    x.lineJoin = x.lineCap = 'round';\r\n    x.lineWidth = .1 + p*1.9;\r\n\r\n    // drawing effect\r\n    const p2 = percent(alpha,.1,1);\r\n    x.setLineDash([99*p2,99]);\r\n\r\n    // cab top\r\n    rect(7,16,18,-8,color(2,2));\r\n    rect(7,8,18,4,color(2,3));\r\n    rect(25,8,8,8,color(2,1));\r\n    rect(25,8,-18,8);\r\n    rect(25,8,8,8);\r\n\r\n    // cab\r\n    rect(25,16,7,23,color());\r\n    rect(11,39,14,-23,color(1,1));\r\n    rect(11,16,14,18,color(1,2));\r\n    rect(11,16,14,8,color(1,3));\r\n    rect(25,16,-14,24);\r\n\r\n    // cab window\r\n    rect(15,29,6,-9,color(2,2));\r\n    circle(15,21,5,0,PI/2,color(2,4),1);\r\n    rect(21,21,-6,9);\r\n\r\n    // little stack\r\n    rect(37,14,9,6,color(3,2));\r\n    rect(37,14,4.5,6,color(3,3));\r\n    rect(37,14,9,6);\r\n\r\n    // big stack\r\n    rect(50,20,10,-8,color(0,1));\r\n    rect(50,20,6.5,-8,color(0,2));\r\n    rect(50,20,3.5,-8,color(0,3));\r\n    rect(50,20,10,-8);\r\n    circle(55,2,11.4,.5,PI-.5,color(3,3));\r\n    circle(55,2,11.4,.5,PI/2,color(3,2),1);\r\n    circle(55,2,11.4,.5,PI-.5);\r\n    rect(45,7,20,-7,color(0,2));\r\n    rect(45,-1,20,4,color(0,3));\r\n    rect(45,-1,20,8);\r\n\r\n    // engine\r\n    for (let i=5; i--;)\r\n    {\r\n        // stagger radius to fix slight seam\r\n        circle(60-i*6,30, 9.9,0,2*PI,color(i+2,3));\r\n        circle(60-i*6,30,10.0,-.5,PI+.5,color(i+2,2));\r\n        circle(60-i*6,30,10.1,.5,PI-.5,color(i+2,1));\r\n    }\r\n\r\n    // engine outline\r\n    circle(36,30,10,PI/2,PI*3/2);\r\n    circle(48,30,10,PI/2,PI*3/2);\r\n    circle(60,30,10);\r\n    line(36,20,60,20);\r\n\r\n    // engine front light\r\n    circle(60,30,4,PI,3*PI,color(3,2)); \r\n    circle(60,30,4,PI,2*PI,color(3,3));\r\n    circle(60,30,4,PI,3*PI);\r\n\r\n    // front brush\r\n    for (let i=6; i--;)\r\n    {\r\n        x.beginPath();\r\n        x.lineTo(53,54);\r\n        x.lineTo(53,40);\r\n        x.lineTo(53+(1+i*2.9)*p,40);\r\n        x.lineTo(53+(4+i*3.5)*p,54);\r\n        x.fillStyle = color(0,i%2+2);\r\n        x.fill();\r\n        i%2 && x.stroke();\r\n    }\r\n\r\n    // wheels\r\n    rect(6,40,5,5);\r\n    rect(6,40,5,5,color());\r\n    rect(15,54,38,-14,color());\r\n    for (let i=3; i--;)\r\n    for (let j=2; j--;)\r\n    {\r\n        circle(15*i+15,47,j?7:1,PI,3*PI,color(i,3));\r\n        x.stroke();\r\n        circle(15*i+15,47,j?7:1,0,PI,color(i,2));\r\n        x.stroke();\r\n    }\r\n    line(6,40,68,40); // center\r\n    line(77,54,4,54); // bottom\r\n\r\n    // draw engine name\r\n    const s = engineName;\r\n    x.font = '900 16px arial';\r\n    x.textAlign = 'center';\r\n    x.textBaseline = 'top';\r\n    x.lineWidth = .1+p*3.9;\r\n    let w2 = 0;\r\n    for (let i=0; i<s.length; ++i)\r\n        w2 += x.measureText(s[i]).width;\r\n    for (let j=2; j--;)\r\n    for (let i=0, X=41-w2/2; i<s.length; ++i)\r\n    {\r\n        x.fillStyle = color(i,2);\r\n        const w = x.measureText(s[i]).width;\r\n        x[j?'strokeText':'fillText'](s[i],X+w/2,55.5,17*p);\r\n        X += w;\r\n    }\r\n    \r\n    x.restore();\r\n}\n\n/** \r\n * LittleJS Module Export\r\n * - Export engine as a module\r\n */\r\n\r\nexport {\r\n\r\n\t// Engine\r\n\tengineName,\r\n\tengineVersion,\r\n\tframeRate,\r\n\ttimeDelta,\r\n\tengineObjects,\r\n\tframe,\r\n\ttime,\r\n\ttimeReal,\r\n\tpaused,\r\n\tsetPaused,\r\n\tengineInit,\r\n\tengineObjectsUpdate,\r\n\tengineObjectsDestroy,\r\n\tengineObjectsCallback,\r\n\tengineAddPlugin,\r\n\t\r\n\t// Globals\r\n\tdebug,\r\n\tdebugOverlay,\r\n\tshowWatermark,\r\n\r\n\t// Debug\r\n\tASSERT,\r\n\tdebugRect,\r\n\tdebugPoly,\r\n\tdebugCircle,\r\n\tdebugPoint,\r\n\tdebugLine,\r\n\tdebugOverlap,\r\n\tdebugText,\r\n\tdebugClear,\r\n\tdebugSaveCanvas,\r\n\tdebugSaveText,\r\n\tdebugSaveDataURL,\r\n\r\n\t// Settings\r\n\tcameraPos,\r\n\tcameraScale,\r\n\tcanvasMaxSize,\r\n\tcanvasFixedSize,\r\n\tcanvasPixelated,\r\n\tfontDefault,\r\n\tshowSplashScreen,\r\n\theadlessMode,\r\n\ttileSizeDefault,\r\n\ttileFixBleedScale,\r\n\tenablePhysicsSolver,\r\n\tobjectDefaultMass,\r\n\tobjectDefaultDamping,\r\n\tobjectDefaultAngleDamping,\r\n\tobjectDefaultElasticity,\r\n\tobjectDefaultFriction,\r\n\tobjectMaxSpeed,\r\n\tgravity,\r\n\tparticleEmitRateScale,\r\n\tglEnable,\r\n\tglOverlay,\r\n\tgamepadsEnable,\r\n\tgamepadDirectionEmulateStick,\r\n\tinputWASDEmulateDirection,\r\n\ttouchGamepadEnable,\r\n\ttouchGamepadAnalog,\r\n\ttouchGamepadSize,\r\n\ttouchGamepadAlpha,\r\n\tvibrateEnable,\r\n\tsoundEnable,\r\n\tsoundVolume,\r\n\tsoundDefaultRange,\r\n\tsoundDefaultTaper,\r\n\tmedalDisplayTime,\r\n\tmedalDisplaySlideTime,\r\n\tmedalDisplaySize,\r\n\tmedalDisplayIconSize,\r\n\r\n\t// Setters for globals\r\n\tsetCameraPos,\r\n\tsetCameraScale,\r\n\tsetCanvasMaxSize,\r\n\tsetCanvasFixedSize,\r\n\tsetCanvasPixelated,\r\n\tsetFontDefault,\r\n\tsetShowSplashScreen,\r\n\tsetHeadlessMode,\r\n\tsetGlEnable,\r\n\tsetGlOverlay,\r\n\tsetTileSizeDefault,\r\n\tsetTileFixBleedScale,\r\n\tsetEnablePhysicsSolver,\r\n\tsetObjectDefaultMass,\r\n\tsetObjectDefaultDamping,\r\n\tsetObjectDefaultAngleDamping,\r\n\tsetObjectDefaultElasticity,\r\n\tsetObjectDefaultFriction,\r\n\tsetObjectMaxSpeed,\r\n\tsetGravity,\r\n\tsetParticleEmitRateScale,\r\n\tsetTouchInputEnable,\r\n\tsetGamepadsEnable,\r\n\tsetGamepadDirectionEmulateStick,\r\n\tsetInputWASDEmulateDirection,\r\n\tsetTouchGamepadEnable,\r\n\tsetTouchGamepadAnalog,\r\n\tsetTouchGamepadSize,\r\n\tsetTouchGamepadAlpha,\r\n\tsetVibrateEnable,\r\n\tsetSoundEnable,\r\n\tsetSoundVolume,\r\n\tsetSoundDefaultRange,\r\n\tsetSoundDefaultTaper,\r\n\tsetMedalDisplayTime,\r\n\tsetMedalDisplaySlideTime,\r\n\tsetMedalDisplaySize,\r\n\tsetMedalDisplayIconSize,\r\n\tsetMedalsPreventUnlock,\r\n\tsetShowWatermark,\r\n\tsetDebugKey,\r\n\r\n\t// Utilities\r\n\tPI,\r\n\tabs,\r\n\tmin,\r\n\tmax,\r\n\tsign,\r\n\tmod,\r\n\tclamp,\r\n\tpercent,\r\n\tdistanceWrap,\r\n\tlerpWrap,\r\n\tdistanceAngle,\r\n\tlerpAngle,\r\n\tlerp,\r\n\tsmoothStep,\r\n\tnearestPowerOfTwo,\r\n\tisOverlapping,\r\n\twave,\r\n\tformatTime,\r\n\r\n\t// Random\r\n\trand,\r\n\trandInt,\r\n\trandSign,\r\n\trandInCircle,\r\n\trandVector,\r\n\trandColor,\r\n\r\n\t// Utility Classes\r\n\tRandomGenerator,\r\n\tVector2,\r\n\tColor,\r\n\tTimer,\r\n\tvec2,\r\n\trgb,\r\n\thsl,\r\n\r\n\t// Draw\r\n\ttextureInfos,\r\n\ttile,\r\n\tTileInfo,\r\n\tTextureInfo,\r\n\tmainCanvas,\r\n\tmainContext,\r\n\toverlayCanvas,\r\n\toverlayContext,\r\n\tmainCanvasSize,\r\n\tscreenToWorld,\r\n\tworldToScreen,\r\n\tdrawTile,\r\n\tdrawRect,\r\n\tdrawLine,\r\n\tdrawCanvas2D,\r\n\tsetBlendMode,\r\n\tdrawTextScreen,\r\n\tdrawText,\r\n\tengineFontImage,\r\n\tFontImage,\r\n\tisFullscreen,\r\n\ttoggleFullscreen,\r\n\tgetCameraSize,\r\n\r\n\t// WebGL\r\n\tglCanvas,\r\n\tglContext,\r\n\tglSetTexture,\r\n\tglCompileShader,\r\n\tglCreateProgram,\r\n\tglCreateTexture,\r\n\r\n\t// Input\r\n\tkeyIsDown,\r\n\tkeyWasPressed,\r\n\tkeyWasReleased,\r\n\tclearInput,\r\n\tmouseIsDown,\r\n\tmouseWasPressed,\r\n\tmouseWasReleased,\r\n\tmousePos,\r\n\tmousePosScreen,\r\n\tmouseWheel,\r\n\tisUsingGamepad,\r\n\tpreventDefaultInput,\r\n\tgamepadIsDown,\r\n\tgamepadWasPressed,\r\n\tgamepadWasReleased,\r\n\tgamepadStick,\r\n\tmouseToScreen,\r\n\tgamepadsUpdate,\r\n\tvibrate,\r\n\tvibrateStop,\r\n\tisTouchDevice,\r\n\r\n\t// Audio\r\n\tSound,\r\n\tSoundWave,\r\n\tMusic,\r\n\tplayAudioFile,\r\n\tspeak,\r\n\tspeakStop,\r\n\tgetNoteFrequency,\r\n\taudioContext,\r\n\tplaySamples,\r\n\tzzfx,\r\n\r\n\t// Base Object\r\n\tEngineObject,\r\n\r\n\t// Tiles\r\n\ttileCollision,\r\n\ttileCollisionSize,\r\n\tinitTileCollision,\r\n\tsetTileCollisionData,\r\n\tgetTileCollisionData,\r\n\ttileCollisionTest,\r\n\ttileCollisionRaycast,\r\n\tTileLayerData,\r\n\tTileLayer,\r\n\r\n\t// Particles\r\n\tParticleEmitter,\r\n\tParticle,\r\n\r\n\t// Medals\r\n\tmedals,\r\n\tmedalsPreventUnlock,\r\n\tmedalsInit,\r\n\tMedal,\r\n};\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","import { DIFFICULTY, MAX_NUMBER, OPERATION_SEQUENCES } from \"./constants\";\nimport { OPERATION_TYPE } from \"./types\";\n\nexport const randomAddNumber = (currentNumber: number) => {\n    return Math.floor(Math.random()) * (MAX_NUMBER - currentNumber) + 1\n}\n\nexport const randomSubstractNumber = (currentNumber: number) => {\n    return Math.floor(Math.random() * currentNumber) + 1;\n}\n\nexport const randomMultiplyNumber = (currentNumber: number) => {\n    const multiplicands = [];\n    for (let i = 2; i <= MAX_NUMBER; i++) {\n        if (currentNumber * i <= MAX_NUMBER) {\n            multiplicands.push(i);\n        }\n    }\n    return multiplicands[Math.floor(Math.random() * multiplicands.length)];\n}\n\nexport const randomDivideNumber = (currentNumber: number) => {\n    if (currentNumber === 1) {\n        return 1;\n    }\n    let n = currentNumber - 1;\n    let divisors = [];\n    while(n--) {\n        if (currentNumber % n === 0) {\n            divisors.push(n); \n        }\n    }\n    return divisors[Math.floor(Math.random() * divisors.length)];\n}\n\nexport const startGameRound = (difficulty = DIFFICULTY.easy) => {\n    let current = 13;\n    const ops = OPERATION_SEQUENCES[difficulty][Math.floor(Math.random() * 6)];\n    const sequence = ops.map(op => {\n        // for adding and substraction just use any value 1-99 that gives a positive value\n        // for multiplication and division only some values are posible\n        if (op === OPERATION_TYPE.ADD) {\n            const value = randomSubstractNumber(current);\n            current -= value;\n            return {\n                type: op,\n                value\n            }\n        } else if (op === OPERATION_TYPE.SUB) {\n            const value = randomAddNumber(current);\n            current += value;\n            return {\n                type: op,\n                value\n            }\n        } else if (op === OPERATION_TYPE.MUL) {\n            const value = randomDivideNumber(current);\n            if (value === 1) {\n                return null;\n            }\n            current /= value;\n            return {\n                type: op,\n                value\n            }\n        } else if (op === OPERATION_TYPE.DIV) {\n            const value = randomMultiplyNumber(current);\n            current *= value;\n            return {\n                type: op,\n                value\n            }\n        }\n    });\n    return {\n        initialNumber: current,\n        sequence: sequence.filter(s => s)\n    }\n}\n","import { Color } from \"littlejsengine\";\nimport { OPERATION_TYPE } from \"./types\";\n\nexport const MAX_NUMBER = 99;\n\nexport enum DIFFICULTY {\n    easy = \"easy\", medium = \"medium\", hard = \"hard\"\n};\n\nexport enum GAME_STATE {\n    PLAYING, LOSE, WIN\n}\n\nexport const OPERATION_SEQUENCES = {\n    easy: [\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.MUL],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.ADD],\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.DIV],\n        [OPERATION_TYPE.SUB, OPERATION_TYPE.MUL],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.SUB],\n        [OPERATION_TYPE.SUB, OPERATION_TYPE.DIV],\n    ],\n    medium: [\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.MUL, OPERATION_TYPE.SUB],\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.DIV, OPERATION_TYPE.SUB],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.ADD, OPERATION_TYPE.DIV],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.SUB, OPERATION_TYPE.DIV],\n        [OPERATION_TYPE.SUB, OPERATION_TYPE.MUL, OPERATION_TYPE.ADD],\n        [OPERATION_TYPE.SUB, OPERATION_TYPE.DIV, OPERATION_TYPE.ADD],\n\n    ],\n    hard: [\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.MUL, OPERATION_TYPE.SUB, OPERATION_TYPE.DIV],\n        [OPERATION_TYPE.ADD, OPERATION_TYPE.DIV, OPERATION_TYPE.SUB, OPERATION_TYPE.MUL],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.ADD, OPERATION_TYPE.DIV, OPERATION_TYPE.SUB],\n        [OPERATION_TYPE.MUL, OPERATION_TYPE.SUB, OPERATION_TYPE.DIV, OPERATION_TYPE.ADD], \n        [OPERATION_TYPE.SUB, OPERATION_TYPE.MUL, OPERATION_TYPE.ADD, OPERATION_TYPE.DIV],\n        [OPERATION_TYPE.SUB, OPERATION_TYPE.DIV, OPERATION_TYPE.ADD, OPERATION_TYPE.MUL],\n    ]\n};\n\nexport const COLOR_PALETTE = {\n    RED: new Color(231/255, 111/255, 81/255, 1), // #E76F51\n    ORANGE: new Color(244/255, 162/255, 97/255, 1), // #F4A261\n    YELLOW: new Color(233/255, 196/255, 106/255, 1), // #E9C46A\n    GREEN: new Color(42/255, 157/255, 143/255, 1), // #2A9D8F\n    BLUE: new Color(38/255, 70/255, 83/255, 1), // #264653\n    WHITE: new Color(238/255, 238/255, 238/255, 1), // #EEEEEE\n    TRANSPARENT: new Color(0, 0, 0, 0)\n};","export enum OPERATION_TYPE {\n    ADD = \"ADD\",\n    SUB = \"SUB\",\n    MUL = \"MUL\",\n    DIV = \"DIV\"\n};\n\nexport interface Operation {\n    type: OPERATION_TYPE,\n    value: number\n}\n\nexport type OperationSequence = Operation[];\n\nexport interface GameRound {\n    initialNumber: number;\n    sequence: OperationSequence;\n}","import { drawRect, drawText, mainCanvas, vec2 } from \"littlejsengine\"\nimport { COLOR_PALETTE } from \"./constants\"\n\nexport const renderBackground = () => {\n    drawRect(vec2(0,0), vec2(mainCanvas.width, mainCanvas.height), COLOR_PALETTE.YELLOW);\n    // drawRect(vec2(-10, 0), vec2(mainCanvas.width, 1), COLOR_PALETTE.ORANGE);\n    // drawRect(vec2(0, -10), vec2(1, mainCanvas.height), COLOR_PALETTE.ORANGE);\n}\n\nexport const renderLevel = (level: number) => {\n    drawText(`Level ${level}`, vec2(0, 12), 1, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n}\n\nexport const renderInstructions = () => {\n    drawRect(vec2(-20, -9), vec2(100, 4), COLOR_PALETTE.BLUE);\n    drawText(\"Welcome to 10 + 3! This game will help you with your phobia to... that number.\", vec2(0, -9), 0.5 , COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n    drawText(\"Use the arrow keys to perform the operations in the correct order to get... that number.\", vec2(-0.85, -9.5), 0.5 , COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n}\n\nexport const renderMaxLevel = (maxLevel: string) => {\n    drawText(`Your max. level: ${maxLevel}`, vec2(12, 12), 0.5, COLOR_PALETTE.WHITE, 2, COLOR_PALETTE.TRANSPARENT);\n}"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","gameRound","addOperand","subOperand","divOperand","mulOperand","_littlejsengine","_helpers","_types","_constants","_renderFunctions","setCanvasPixelated","setShowWatermark","sound_goodMove","Sound","sound_badMove","gameState","GAME_STATE","PLAYING","level","maxLevel","localStorage","getItem","createOperands","sequence","forEach","op","type","OPERATION_TYPE","ADD","value","SUB","MUL","DIV","resetOperands","undefined","resetGame","currentDifficulty","DIFFICULTY","easy","hard","medium","startGameRound","nextLevel","updateCurrentResult","initialNumber","engineInit","sendAnswer","answerOperation","pop","play","WIN","LOSE","Number","setItem","String","keyWasPressed","renderBackground","renderLevel","renderMaxLevel","drawRect","vec2","COLOR_PALETTE","GREEN","BLUE","drawText","toString","WHITE","TRANSPARENT","ORANGE","renderInstructions","RED","mainCanvas","mainContext","overlayCanvas","overlayContext","drawCount","engineFontImage","audioContext","audioGainNode","glCanvas","glContext","glShader","glActiveTexture","glArrayBuffer","glGeometryBuffer","glPositionData","glColorData","glInstanceCount","glAdditive","glBatchAdditive","parcelHelpers","defineInteropFlag","export","engineName","engineVersion","frameRate","timeDelta","engineObjects","frame","time","timeReal","paused","setPaused","engineObjectsUpdate","engineObjectsDestroy","engineObjectsCallback","engineAddPlugin","debug","debugOverlay","showWatermark","ASSERT","debugRect","debugPoly","debugCircle","debugPoint","debugLine","debugOverlap","debugText","debugClear","debugSaveCanvas","debugSaveText","debugSaveDataURL","cameraPos","cameraScale","canvasMaxSize","canvasFixedSize","canvasPixelated","fontDefault","showSplashScreen","headlessMode","tileSizeDefault","tileFixBleedScale","enablePhysicsSolver","objectDefaultMass","objectDefaultDamping","objectDefaultAngleDamping","objectDefaultElasticity","objectDefaultFriction","objectMaxSpeed","gravity","particleEmitRateScale","glEnable","glOverlay","gamepadsEnable","gamepadDirectionEmulateStick","inputWASDEmulateDirection","touchGamepadEnable","touchGamepadAnalog","touchGamepadSize","touchGamepadAlpha","vibrateEnable","soundEnable","soundVolume","soundDefaultRange","soundDefaultTaper","medalDisplayTime","medalDisplaySlideTime","medalDisplaySize","medalDisplayIconSize","setCameraPos","setCameraScale","setCanvasMaxSize","setCanvasFixedSize","setFontDefault","setShowSplashScreen","setHeadlessMode","setGlEnable","setGlOverlay","setTileSizeDefault","setTileFixBleedScale","setEnablePhysicsSolver","setObjectDefaultMass","setObjectDefaultDamping","setObjectDefaultAngleDamping","setObjectDefaultElasticity","setObjectDefaultFriction","setObjectMaxSpeed","setGravity","setParticleEmitRateScale","setTouchInputEnable","setGamepadsEnable","setGamepadDirectionEmulateStick","setInputWASDEmulateDirection","setTouchGamepadEnable","setTouchGamepadAnalog","setTouchGamepadSize","setTouchGamepadAlpha","setVibrateEnable","setSoundEnable","setSoundVolume","setSoundDefaultRange","setSoundDefaultTaper","setMedalDisplayTime","setMedalDisplaySlideTime","setMedalDisplaySize","setMedalDisplayIconSize","setMedalsPreventUnlock","setDebugKey","PI","abs","min","max","sign","mod","clamp","percent","distanceWrap","lerpWrap","distanceAngle","lerpAngle","lerp","smoothStep","nearestPowerOfTwo","isOverlapping","wave","formatTime","rand","randInt","randSign","randInCircle","randVector","randColor","RandomGenerator","Vector2","Color","Timer","rgb","hsl","textureInfos","tile","TileInfo","TextureInfo","mainCanvasSize","screenToWorld","worldToScreen","drawTile","drawLine","drawCanvas2D","setBlendMode","drawTextScreen","FontImage","isFullscreen","toggleFullscreen","getCameraSize","glSetTexture","glCompileShader","glCreateProgram","glCreateTexture","keyIsDown","keyWasReleased","clearInput","mouseIsDown","mouseWasPressed","mouseWasReleased","mousePos","mousePosScreen","mouseWheel","isUsingGamepad","preventDefaultInput","gamepadIsDown","gamepadWasPressed","gamepadWasReleased","gamepadStick","mouseToScreen","gamepadsUpdate","vibrate","vibrateStop","isTouchDevice","SoundWave","Music","playAudioFile","speak","speakStop","getNoteFrequency","playSamples","zzfx","EngineObject","tileCollision","tileCollisionSize","initTileCollision","setTileCollisionData","getTileCollisionData","tileCollisionTest","tileCollisionRaycast","TileLayerData","TileLayer","ParticleEmitter","Particle","medals","medalsPreventUnlock","medalsInit","Medal","debugKey","debugPrimitives","debugPhysics","debugRaycast","debugParticles","debugGamepads","debugTakeScreenshot","downloadLink","assert","output","console","pos","size","color","angle","fill","push","points","radius","posA","posB","thickness","halfDelta","y","add","pA","sA","pB","sB","minPos","maxPos","subtract","text","font","canvas","filename","toDataURL","URL","createObjectURL","Blob","dataURL","download","href","click","debugUpdate","Math","valueA","valueB","dividend","divisor","wrapSize","d","angleA","angleB","ceil","log2","sizeA","sizeB","frequency","amplitude","t","cos","random","floor","setAngle","minRadius","colorA","colorB","linear","r","g","b","a","constructor","seed","float","int","isVector2","v","set","copy","multiply","divide","scale","s","lengthSquared","distance","distanceSquared","normalize","l","clampLength","dot","cross","atan2","sin","rotate","c","setDirection","direction","invert","area","arrayCheck","arraySize","digits","toFixed","h","setHSLA","isColor","alphaScale","q","p","f","HSLA","mutate","amount","alphaAmount","useAlpha","toHex","setHex","hex","fromHex","parseInt","slice","rgbaInt","timeLeft","setTime","unset","isSet","active","elapsed","getPercent","valueOf","touchInputEnable","pixelated","show","headless","enable","overlay","mass","damp","elasticity","friction","speed","newGravity","analog","alpha","volume","gain","range","taper","preventUnlock","key","tileInfo","renderOrder","drawSize","additiveColor","mirror","damping","angleDamping","gravityScale","velocity","angleVelocity","spawnTime","children","clampSpeedLinear","localPos","localAngle","collideTiles","collideSolidObjects","isSolid","collideRaycast","updateTransforms","getMirrorSign","child","update","length2","oldPos","wasMovingDown","groundObject","groundSpeed","o","engineObjectsCollide","destroyed","collide1","collideWithObject","collide2","deltaPos","pushAwayAccel","sizeBoth","smallStepUp","isBlockedX","isBlockedY","inelastic","elastic0","elastic1","render","destroy","removeChild","localToWorld","worldToLocal","localToWorldVector","vec","worldToLocalVector","collideWithTile","tileData","object","getAliveTime","applyAcceleration","acceleration","applyForce","force","addChild","includes","splice","indexOf","setCollision","renderDebugInfo","color1","color2","textureIndex","textureInfo","cols","offset","getTextureInfo","image","width","height","glTexture","fixBleedSize","screenPos","worldPos","useWebGL","screenSpace","context","w","tileImageFixBleed","glDraw","globalAlpha","drawImage","fillStyle","fillRect","drawFunction","save","translate","restore","additive","globalCompositeOperation","lineWidth","lineColor","textAlign","strokeStyle","textBaseline","lineJoin","split","line","strokeText","fillText","tileSize","paddingSize","Image","src","center","imageSmoothingEnabled","centerOffset","j","charCode","charCodeAt","drawPos","document","fullscreenElement","exitFullscreen","body","requestFullscreen","device","inputData","button","gamepad","stick","gamepadStickData","inputUpdate","hasFocus","inputUpdatePost","deviceInputData","rect","getBoundingClientRect","left","right","top","bottom","applyDeadZones","deadZone","touchGamepadButtons","touchGamepadTimer","sticks","touchGamepadStick","round","data","wasDown","navigator","getGamepads","gamepads","axes","buttons","pressed","dpad","pattern","ontouchstart","zzfxSound","randomness","sampleChannels","zzfxG","sampleRate","zzfxR","pitch","randomnessScale","loop","pan","playbackRate","gainNode","createGain","source","setVolume","stop","getSource","playNote","semitoneOffset","getDuration","isLoading","onloadCallback","fetch","then","response","arrayBuffer","decodeAudioData","audioBuffer","numberOfChannels","Array","from","getChannelData","zzfxMusic","zzfxM","instruments","patterns","BPM","k","instrumentParameters","note","sample","patternChannel","notFirstBeat","instrument","attenuation","outSampleOffset","isSequenceEnd","nextSampleOffset","sampleOffset","sampleBuffer","leftChannelBuffer","rightChannelBuffer","channelIndex","panning","hasMore","sampleCache","beatLength","patternIndex","sequenceIndex","playMusic","language","rate","speechSynthesis","utterance","SpeechSynthesisUtterance","lang","cancel","rootFrequency","audioSuspended","audioWasSuspended","state","resume","buffer","createBuffer","createBufferSource","connect","StereoPannerNode","start","attack","sustain","release","shape","shapeCurve","slide","deltaSlide","pitchJump","pitchJumpTime","repeatTime","noise","modulation","bitCrush","delay","sustainVolume","decay","tremolo","filter","PI2","startSlide","startFrequency","tm","a0","a1","a2","b0","b1","x2","x1","y2","y1","tan","b2","minX","minY","maxX","maxY","posStart","posEnd","delta","totalLength","normalizedDelta","unit","flooredPosStart","xi","yi","clear","position","createElement","getContext","isOverlay","redraw","redrawStart","redrawEnd","drawTileData","setData","layerPos","getData","glCopyToContext","savedRenderSettings","glPreRender","clearRect","emitSize","emitTime","emitRate","emitConeAngle","colorStartA","colorStartB","colorEndA","colorEndB","particleTime","sizeStart","sizeEnd","angleSpeed","particleConeAngle","fadeRate","randomColorLinear","localSpace","trailScale","particleDestroyCallback","particleCreateCallback","emitTimeBuffer","emitParticle","randomizeScale","coneAngle","colorStart","colorEnd","velocityAngle","particle","lifeTime","localSpaceEmitter","destroyCallback","colorEndDelta","sizeEndDelta","trailLength","medalsDisplayQueue","medalsSaveName","medalsDisplayTimeLast","saveName","callback","medal","unlocked","storageKey","values","shift","slideOffTime","hidePercent","description","icon","unlock","beginPath","stroke","clip","renderIcon","viewport","gl_COLOR_BUFFER_BIT","useProgram","activeTexture","gl_TEXTURE0","bindTexture","gl_TEXTURE_2D","initVertexAttribArray","typeSize","location","getAttribLocation","stride","gl_INSTANCE_BYTE_STRIDE","enableVertexAttribArray","vertexAttribPointer","vertexAttribDivisor","bindBuffer","gl_ARRAY_BUFFER","gl_FLOAT","bufferData","gl_INSTANCE_BUFFER_SIZE","gl_DYNAMIC_DRAW","gl_UNSIGNED_BYTE","uniformMatrix4fv","getUniformLocation","texture","glFlush","shader","createShader","shaderSource","compileShader","getShaderParameter","gl_COMPILE_STATUS","getShaderInfoLog","vsSource","fsSource","program","createProgram","attachShader","gl_VERTEX_SHADER","gl_FRAGMENT_SHADER","linkProgram","getProgramParameter","gl_LINK_STATUS","getProgramInfoLog","createTexture","texImage2D","gl_RGBA","gl_NEAREST","gl_LINEAR","texParameteri","gl_TEXTURE_MIN_FILTER","gl_TEXTURE_MAG_FILTER","destBlend","gl_ONE","gl_ONE_MINUS_SRC_ALPHA","blendFuncSeparate","gl_SRC_ALPHA","gl_BLEND","bufferSubData","drawArraysInstanced","gl_TRIANGLE_STRIP","forceDraw","sizeX","sizeY","uv0X","uv0Y","uv1X","uv1Y","rgba","rgbaAdditive","gl_MAX_INSTANCES","gl_INDICIES_PER_INSTANCE","isPaused","frameTimeLastMS","frameTimeBufferMS","averageFPS","pluginUpdateList","pluginRenderList","updateFunction","renderFunction","gameInit","gameUpdate","gameUpdatePost","gameRender","gameRenderPost","imageSources","updateCanvas","aspect","innerWidth","innerHeight","fixedAspect","style","startEngine","engineUpdate","frameTimeMS","frameTimeDeltaMS","debugSpeedUp","debugSpeedDown","deltaSmooth","sort","touchGamepadRender","leftCenter","arc","rightCenter","debugRender","debugObject","centerPos","stickPos","saveContext","cameraSize","bestDistance","Infinity","pointSize","debugPointSize","point","p2","lineTo","closePath","strokeRect","raycastHitPos","shadowColor","shadowBlur","keysPressed","buttonsPressed","requestAnimationFrame","isArray","styleBody","cssText","appendChild","inputInit","onkeydown","e","target","repeat","remapKey","preventDefault","onkeyup","onmousedown","onmouseup","onmousemove","onwheel","ctrlKey","deltaY","oncontextmenu","touchInputInit","wasTouching","handleTouch","handleTouchDefault","touching","touches","clientX","clientY","stickCenter","buttonCenter","startCenter","touch","touchPos","addEventListener","passive","AudioContext","destination","glInit","glInstanceData","ArrayBuffer","Float32Array","Uint32Array","geometry","promises","map","Promise","onerror","onload","log","updateSplash","drawEngineSplashScreen","p3","p4","createRadialGradient","hypot","addColorStop","X","Y","W","H","C","Z","circle","R","A","B","F","D","E","lineCap","setLineDash","w2","measureText","setTimeout","all","updateObject","callbackFunction","objects","engineObjectsCollect","collectedObjects","sizeSquared","interopDefault","__esModule","default","exportAll","dest","keys","prototype","hasOwnProperty","enumerable","destName","randomAddNumber","randomSubstractNumber","randomMultiplyNumber","randomDivideNumber","currentNumber","MAX_NUMBER","multiplicands","n","divisors","difficulty","current","ops","OPERATION_SEQUENCES","YELLOW"],"version":3,"file":"index.01cb6101.js.map"}